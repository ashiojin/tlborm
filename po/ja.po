msgid ""
msgstr ""
"Project-Id-Version: The Little Book of Rust Macros\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-09-17 15:35+0900\n"
"Last-Translator: ashiojin@gmail.com\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "はじめに"

#: src/SUMMARY.md:5 src/syntax-extensions.md:1
msgid "Syntax Extensions"
msgstr "構文拡張"

#: src/SUMMARY.md:6 src/syntax-extensions/source-analysis.md:1
msgid "Source Analysis"
msgstr "ソース分析"

#: src/SUMMARY.md:7
msgid "Macros in the Ast"
msgstr "AST内のマクロ"

#: src/SUMMARY.md:8 src/syntax-extensions/expansion.md:1
#, fuzzy
msgid "Expansion"
msgstr "拡張"

#: src/SUMMARY.md:9 src/SUMMARY.md:18 src/syntax-extensions/hygiene.md:1
#: src/decl-macros/minutiae/hygiene.md:1 src/decl-macros/macros2.md:56
#, fuzzy
msgid "Hygiene"
msgstr "衛生"

#: src/SUMMARY.md:10 src/SUMMARY.md:20 src/syntax-extensions/debugging.md:1
#: src/decl-macros/minutiae/debugging.md:1
msgid "Debugging"
msgstr "デバッキング"

#: src/SUMMARY.md:11 src/decl-macros.md:1
#, fuzzy
msgid "Declarative Macros"
msgstr "宣言的マクロ"

#: src/SUMMARY.md:12 src/SUMMARY.md:37 src/proc-macros/methodical.md:1
#, fuzzy
msgid "A Methodical Introduction"
msgstr "方法論的入門"

#: src/SUMMARY.md:13 src/SUMMARY.md:41
#, fuzzy
msgid "A Practical Introduction"
msgstr "実践入門"

#: src/SUMMARY.md:14 src/decl-macros/minutiae.md:1
#, fuzzy
msgid "Minutiae"
msgstr "瑣末なこと"

#: src/SUMMARY.md:15 src/decl-macros/minutiae/fragment-specifiers.md:1
#, fuzzy
msgid "Fragment Specifiers"
msgstr "フラグメント指定子"

#: src/SUMMARY.md:16 src/decl-macros/minutiae/metavar-and-expansion.md:1
#, fuzzy
msgid "Metavariables and Expansion Redux"
msgstr "メタ変数と拡張"

#: src/SUMMARY.md:17 src/decl-macros/macros-methodical.md:243
#: src/decl-macros/minutiae/metavar-expr.md:1
#, fuzzy
msgid "Metavariable Expressions"
msgstr "メタ変数式"

#: src/SUMMARY.md:19 src/decl-macros/minutiae/identifiers.md:1
#, fuzzy
msgid "Non-Identifier Identifiers"
msgstr "識別子以外の識別子"

#: src/SUMMARY.md:21 src/decl-macros/minutiae/scoping.md:1
#, fuzzy
msgid "Scoping"
msgstr "スコープ"

#: src/SUMMARY.md:22 src/decl-macros/minutiae/import-export.md:1
#, fuzzy
msgid "Import and Export"
msgstr "インポート と エクスポート"

#: src/SUMMARY.md:23 src/syntax-extensions/ast.md:103
#: src/decl-macros/patterns.md:1
msgid "Patterns"
msgstr "パターン"

#: src/SUMMARY.md:24 src/decl-macros/patterns/callbacks.md:1
#, fuzzy
msgid "Callbacks"
msgstr "コールバック"

#: src/SUMMARY.md:25 src/decl-macros/patterns/tt-muncher.md:1
#, fuzzy
msgid "Incremental TT Munchers"
msgstr "インクリメンタルTTマンチャー"

#: src/SUMMARY.md:26 src/decl-macros/patterns/internal-rules.md:1
#, fuzzy
msgid "Internal Rules"
msgstr "社内規定"

#: src/SUMMARY.md:27 src/decl-macros/patterns/push-down-acc.md:1
#, fuzzy
msgid "Push-down Accumulation"
msgstr "プッシュダウン・アキュムレーション"

#: src/SUMMARY.md:28 src/decl-macros/patterns/repetition-replacement.md:1
#, fuzzy
msgid "Repetition Replacement"
msgstr "リピート交換"

#: src/SUMMARY.md:29 src/decl-macros/patterns/tt-bundling.md:1
#, fuzzy
msgid "TT Bundling"
msgstr "TTバンドル"

#: src/SUMMARY.md:30 src/decl-macros/building-blocks.md:1
#, fuzzy
msgid "Building Blocks"
msgstr "ビルディングブロック"

#: src/SUMMARY.md:31 src/decl-macros/building-blocks/ast-coercion.md:1
#, fuzzy
msgid "AST Coercion"
msgstr "ASTの強制"

#: src/SUMMARY.md:32 src/decl-macros/building-blocks/counting.md:1
#, fuzzy
msgid "Counting"
msgstr "カウント"

#: src/SUMMARY.md:33
#, fuzzy
msgid "Abacus Counting"
msgstr "そろばん数え"

#: src/SUMMARY.md:34 src/decl-macros/building-blocks/parsing.md:1
#, fuzzy
msgid "Parsing Rust"
msgstr "ラストの解析"

#: src/SUMMARY.md:35 src/decl-macros/macros2.md:1
#, fuzzy
msgid "Macros 2.0"
msgstr "マクロ2.0"

#: src/SUMMARY.md:36 src/proc-macros.md:1
#, fuzzy
msgid "Procedural Macros"
msgstr "手続き型マクロ"

#: src/SUMMARY.md:38 src/SUMMARY.md:42
#: src/proc-macros/methodical/function-like.md:1
#, fuzzy
msgid "Function-like"
msgstr "機能的"

#: src/SUMMARY.md:39 src/SUMMARY.md:43 src/proc-macros/methodical/attr.md:1
msgid "Attribute"
msgstr "属性"

#: src/SUMMARY.md:40 src/SUMMARY.md:44 src/proc-macros/methodical/derive.md:1
#, fuzzy
msgid "Derive"
msgstr "導出"

#: src/SUMMARY.md:45 src/proc-macros/third-party-crates.md:1
#, fuzzy
msgid "Third-Party Crates"
msgstr "サードパーティのクレート"

#: src/SUMMARY.md:46 src/proc-macros/hygiene.md:1
#, fuzzy
msgid "Hygiene and Spans"
msgstr "衛生とスパン"

#: src/SUMMARY.md:47
#, fuzzy
msgid "Techniques"
msgstr "テクニック"

#: src/SUMMARY.md:48
msgid "Testing"
msgstr "テスト"

#: src/SUMMARY.md:50 src/glossary.md:1
msgid "Glossary"
msgstr "用語集"

#: src/introduction.md:2
msgid "The Little Book of Rust Macros"
msgstr "The Little Book of Rust Macros"

#: src/introduction.md:4
#, fuzzy
msgid ""
"**Note**: This is a continuation of [Daniel Keep's Book](https://github.com/"
"DanielKeep/tlborm) which has not been updated since the early summer of "
"2016, adapted to make use of [mdBook](https://github.com/rust-lang/mdBook)."
msgstr ""
"*注***：これは、2016年初夏以降更新されていない[Daniel Keep's Book](https://"
"github.com/DanielKeep/tlborm)の続編で、[mdBook](https://github.com/rust-lang/"
"mdBook)を利用するようにアレンジしたものです。"

#: src/introduction.md:6
#, fuzzy
msgid ""
"View the [rendered version here](https://veykril.github.io/tlborm/) and the "
"[repository here](https://github.com/veykril/tlborm)."
msgstr ""
"レンダリング版はこちら](https://veykril.github.io/tlborm/)と[リポジトリはこち"
"ら](https://github.com/veykril/tlborm)をご覧ください。"

#: src/introduction.md:8
#, fuzzy
msgid ""
"A chinese version of this book can be found [here](https://zjp-cn.github.io/"
"tlborm/)."
msgstr "本書の中国語版は[こちら](https://zjp-cn.github.io/tlborm/)。"

#: src/introduction.md:10
#, fuzzy
msgid ""
"This book is an attempt to distill the Rust community's collective knowledge "
"of Rust macros, the `Macros by Example` ones as well as procedural "
"macros(WIP). As such, both additions (in the form of pull requests) and "
"requests (in the form of issues) are very much welcome. If something's "
"unclear, opens up questions or is not understandable as written down, fear "
"not to make an issue asking for clarification. The goal is for this book to "
"become the best learning resource possible."
msgstr ""
"この本は、RustコミュニティのRustマクロに関する集合的な知識、「例によるマク"
"ロ」や手続き型マクロ(WIP)を抽出する試みです。そのため、（プルリクエストという"
"形での）追加や（issueという形での）要望は大歓迎です。不明な点、疑問点、書かれ"
"ていることが理解できない点などがあれば、issueを作成し、説明を求めてください。"
"この本が最高の学習リソースになることが目標です。"

#: src/introduction.md:15
#, fuzzy
msgid ""
"The [original Little Book of Rust Macros](https://github.com/DanielKeep/"
"tlborm) has helped me immensely with understanding _**Macros by Example**_ "
"style macros while I was still learning the language. Unfortunately, the "
"original book hasn't been updated since April of 2016, while the Rust "
"language as well as its macro-system keeps evolving. Which is why I took up "
"the task to update the book and keep it updated as well as I can while also "
"adding newfound things to it. In hopes that it will help out all the fresh "
"faces coming to Rust understanding its macro systems, a part of the language "
"a people tend to have trouble with."
msgstr ""
"元祖Rustマクロ小辞典](https://github.com/DanielKeep/tlborm)は、私がまだ言語を"
"学んでいる間、_**Macros by Example**_ スタイルのマクロを理解するのに非常に役"
"立ちました。しかし残念ながら、Rust言語とマクロシステムが進化し続ける中、この"
"本は2016年4月から更新されていません。そのため、私はこの本を更新し、新しい発見"
"を加えながら、できる限り最新の状態に保つ仕事を引き受けました。この本が、これ"
"からRustを学ぼうとする人たちが、Rustのマクロシステムを理解する助けになること"
"を願っています。"

#: src/introduction.md:20
#, fuzzy
msgid ""
"This book expects you to have basic knowledge of Rust, it will not explain "
"language features or constructs that are irrelevant to macros. No prior "
"knowledge of macros is assumed. Having read and understood the first seven "
"chapters of the [Rust Book](https://doc.rust-lang.org/stable/book/) is a "
"must, though having read the majority of the book is recommended."
msgstr ""
"本書では、Rustの基本的な知識があることを前提としており、マクロに関係のない言"
"語機能や構成要素については説明しません。マクロに関する予備知識は想定していま"
"せん。Rust Book](https://doc.rust-lang.org/stable/book/)の最初の7章を読んで理"
"解していることは必須ですが、この本の大部分を読んでいることを推奨します。"

#: src/introduction.md:24
msgid "Thanks"
msgstr "謝辞"

#: src/introduction.md:26
#, fuzzy
msgid ""
"A big thank you to Daniel Keep for the original work as well as all the "
"contributors that added to the original which can be found [here](https://"
"github.com/DanielKeep/tlborm)."
msgstr ""
"ダニエル・キープ氏の原作と、原作に加筆してくれたすべての貢献者に感謝します[こ"
"ちら](https://github.com/DanielKeep/tlborm)。"

#: src/introduction.md:28
msgid "License"
msgstr "ライセンス"

#: src/introduction.md:30
#, fuzzy
msgid ""
"This work inherits the licenses of the original, hence it is licensed under "
"both the [Creative Commons Attribution-ShareAlike 4.0 International License]"
"(http://creativecommons.org/licenses/by-sa/4.0/) and the [MIT license]"
"(http://opensource.org/licenses/MIT)."
msgstr ""
"この作品はオリジナルのライセンスを継承しているため、[Creative Commons "
"Attribution-ShareAlike 4.0 International License](http://creativecommons.org/"
"licenses/by-sa/4.0/)と[MIT license](http://opensource.org/licenses/MIT)の両方"
"でライセンスされています。"

#: src/syntax-extensions.md:3
msgid ""
"Before talking about Rust's different macro systems it is worthwhile to "
"discuss the general mechanism they are built on: _syntax extensions_."
msgstr ""
"Rustのさまざまなマクロシステムについて説明する前に、それらがどのような一般的"
"なメカニズムに基づいて構築されているかについて説明する価値があります： _構文"
"拡張_ です。"

#: src/syntax-extensions.md:5
msgid ""
"To do that, we must first discuss how Rust source is processed by the "
"compiler, and the general mechanisms on which user-defined macros and proc-"
"macros are built upon."
msgstr ""
"そのためにはまず、Rustのソースコードがコンパイラによってどのように処理される"
"のか、そしてユーザ定義マクロやprocマクロが構築される一般的なメカニズムについ"
"て説明する必要があります。"

#: src/syntax-extensions.md:7
msgid ""
"**Note**: This book will use the term _syntax extension_ from now on when "
"talking about all of rust's different macro kinds in general to reduce "
"potential confusion with the upcoming [declarative macro 2.0](https://github."
"com/rust-lang/rust/issues/39412) proposal which uses the `macro` keyword."
msgstr ""
"**注**： 本書では今後、Rustのさまざまな種類のマクロ全般について話すときには、"
"`macro` キーワードを使用する、来る[declarative macro 2.0](https://github.com/"
"rust-lang/rust/issues/39412) 提案との潜在的な混同を避けるために、_構文拡張_ "
"という用語を使用します。"

#: src/syntax-extensions/source-analysis.md:3
msgid "Tokenization"
msgstr "トークン化"

#: src/syntax-extensions/source-analysis.md:5
msgid ""
"The first stage of compilation for a Rust program is [tokenization](https://"
"en.wikipedia.org/wiki/Lexical_analysis#Tokenization). This is where the "
"source text is transformed into a sequence of tokens (_i.e._ indivisible "
"lexical units; the programming language equivalent of \"words\"). Rust has "
"various kinds of tokens, such as:"
msgstr ""
"Rustプログラムのコンパイルの最初の段階は[トークン化](https://en.wikipedia."
"org/wiki/Lexical_analysis#Tokenization)です。これは、ソーステキストを一連の"
"トークン( _i.e._ 不可分な語彙単位。プログラミング言語の「単語」に相当)に変換"
"する作業です。Rustには、以下のようなさまざまな種類のトークンがあります："

#: src/syntax-extensions/source-analysis.md:9
msgid "Identifiers: `foo`, `Bambous`, `self`, `we_can_dance`, `LaCaravane`, …"
msgstr "識別子： `foo`、`Bambous`、`self`、`we_can_dance`、`LaCaravane`、..."

#: src/syntax-extensions/source-analysis.md:10
msgid ""
"Literals: `42`, `72u32`, `0_______0`, `1.0e-40`, `\"ferris was here\"`, …"
msgstr ""
"リテラル: `42`, `72u32`, `0_______0`, `1.0e-40`, `\"ferris was here\"`, ..."

#: src/syntax-extensions/source-analysis.md:11
msgid "Keywords: `_`, `fn`, `self`, `match`, `yield`, `macro`, …"
msgstr "キーワード： `_`、`fn`、`self`、`match`、`yield`、`macro`、..."

#: src/syntax-extensions/source-analysis.md:12
msgid "Symbols: `[`, `:`, `::`, `?`, `~`, `@`[^wither-at], …"
msgstr "シンボル：`[`, `:`, `::`, `?`, `~`, `@`[^wither-at], ..."

#: src/syntax-extensions/source-analysis.md:14
msgid ""
"…among others. There are some things to note about the above: first, `self` "
"is both an identifier _and_ a keyword. In almost all cases, `self` is a "
"keyword, but it _is_ possible for it to be _treated_ as an identifier, which "
"will come up later (along with much cursing). Secondly, the list of keywords "
"includes some suspicious entries such as `yield` and `macro` that aren't "
"_actually_ in the language, but _are_ parsed by the compiler—these are "
"[reserved](https://doc.rust-lang.org/reference/keywords.html#reserved-"
"keywords) for future use. Third, the list of symbols _also_ includes entries "
"that aren't used by the language. In the case of `<-`, it is vestigial: it "
"was removed from the grammar, but not from the lexer. As a final point, note "
"that `::` is a distinct token; it is not simply two adjacent `:` tokens. The "
"same is true of all multi-character symbol tokens in Rust, as of Rust 1.2."
"[^two-lexers]"
msgstr ""
"... などがあります。ここにいくつか注記することがあります：第一に、`self` は識"
"別子である _と同時に_ キーワードでもあります。ほとんどの場合、`self`はキー"
"ワードですが、識別子として _扱われる_ こともあります。これは後に（たくさんの"
"悪口付きで）お話しします。第二に、キーワードのリストには、 `yield` や "
"`macro` のような、言語に _実際には存在しない_ にも関わらず、コンパイラによっ"
"て解析 _される_ 怪しい項目があります。第三に、記号のリストには、その言語で使"
"われていない項目 _も_ 含まれています。 `<-`の場合は、これは名残のようなもので"
"す：文法からは削除されていますが、辞書からは削除されていません。最後のポイン"
"トとして、`::` は１個のトークンです。これは隣り合う２個の `: ` トークンではあ"
"りません。Rust 1.2の時点では、Rustのすべての複数文字シンボルトークンについて"
"同じことが言えます[^two-lexers]。"

#: src/syntax-extensions/source-analysis.md:24
msgid ""
"`@` has a purpose, though most people seem to forget about it completely: it "
"is used in patterns to bind a non-terminal part of the pattern to a name."
msgstr ""
"ほとんどの人は完全に忘れているようですが、`@` には目的があります。パターンの"
"非終端部分を名前に束縛するために、パターン内で使われます。"

#: src/syntax-extensions/source-analysis.md:27
msgid ""
"Technically rust currently(1.46) has two lexers, [`rustc_lexer`](https://"
"github.com/rust-lang/rust/tree/master/compiler/rustc_lexer) which only emits "
"single character symbols as tokens and the [lexer](https://github.com/rust-"
"lang/rust/tree/master/compiler/rustc_parse/src/lexer) in [`rustc_parse`]"
"(https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse) which "
"sees multi-character symbols as distinct tokens."
msgstr ""
"技術的には、現在(1.46)のrustには2つのレキサがあります。[`rustc_lexer`]"
"(https://github.com/rust-lang/rust/tree/master/compiler/rustc_lexer)は1文字の"
"シンボルだけをトークンとして出力し、[`rustc_parse`](https://github.com/rust-"
"lang/rust/tree/master/compiler/rustc_parse)の[lexer](https://github.com/rust-"
"lang/rust/tree/master/compiler/rustc_parse/src/lexer)は複数文字のシンボルを別"
"個のトークンとして認識します。"

#: src/syntax-extensions/source-analysis.md:31
msgid ""
"As a point of comparison, it is at _this_ stage that some languages have "
"their macro layer, though Rust does _not_. For example, C/C++ macros are "
"_effectively_ processed at this point. [^lies-damn-lies-cpp] This is why the "
"following code works: [^cpp-it-seemed-like-a-good-idea-at-the-time]"
msgstr ""
"比較のポイントとして、いくつかの言語がマクロのレイヤーを持つのは _この_ 段階"
"であるのに対し、Rustは _そうではありません_ 。例えば、C/C++のマクロはこの段階"
"で _事実上_ 処理されます。[^lies-damn-lies-cpp] これが以下のコードが動作する"
"理由です：[^cpp-it-seemed-like-a-good-idea-the-the-time]。"

#: src/syntax-extensions/source-analysis.md:36
msgid ""
"```c\n"
"#define SUB int\n"
"#define BEGIN {\n"
"#define END }\n"
"\n"
"SUB main() BEGIN\n"
"    printf(\"Oh, the horror!\\n\");\n"
"END\n"
"```"
msgstr ""
"```c\n"
"#define SUB int\n"
"#define BEGIN {\n"
"#define END }\n"
"\n"
"SUB main() BEGIN\n"
"    printf(\"Oh, the horror!\\n\");\n"
"END\n"
"```"

#: src/syntax-extensions/source-analysis.md:46
msgid ""
"In fact, the C preprocessor uses a different lexical structure to C itself, "
"but the distinction is _broadly_ irrelevant."
msgstr ""
"実際、CプリプロセッサはCそのものとは異なる字句構造を使っていますが、この区別"
"は _大まかには_ 重要ではありません。"

#: src/syntax-extensions/source-analysis.md:49
msgid "_Whether_ it should work is an entirely _different_ question."
msgstr "それがうまくいくかどうかは、まったく _別の_ 問題です。"

#: src/syntax-extensions/source-analysis.md:52
msgid "Parsing"
msgstr "構文解析"

#: src/syntax-extensions/source-analysis.md:54
msgid ""
"The next stage is parsing, where the stream of tokens is turned into an "
"[Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) "
"(AST). This involves building up the syntactic structure of the program in "
"memory. For example, the token sequence `1 + 2` is transformed into the "
"equivalent of:"
msgstr ""
"次の段階は構文解析で、トークンのストリームを[抽象構文木](https://en."
"wikipedia.org/wiki/Abstract_syntax_tree) (Abstract Syntax Tree：AST)に変換し"
"ます。これは、メモリ上にプログラムの構文構造を構築することを含みます。例え"
"ば、トークン列 `1 + 2` は次のように変換されます："

#: src/syntax-extensions/source-analysis.md:58
msgid ""
"```text\n"
"┌─────────┐   ┌─────────┐\n"
"│ BinOp   │ ┌╴│ LitInt  │\n"
"│ op: Add │ │ │ val: 1  │\n"
"│ lhs: ◌  │╶┘ └─────────┘\n"
"│ rhs: ◌  │╶┐ ┌─────────┐\n"
"└─────────┘ └╴│ LitInt  │\n"
"              │ val: 2  │\n"
"              └─────────┘\n"
"```"
msgstr ""
"```text\n"
"┌─────────┐   ┌─────────┐\n"
"│ BinOp   │ ┌╴│ LitInt  │\n"
"│ op: Add │ │ │ val: 1  │\n"
"│ lhs: ◌  │╶┘ └─────────┘\n"
"│ rhs: ◌  │╶┐ ┌─────────┐\n"
"└─────────┘ └╴│ LitInt  │\n"
"              │ val: 2  │\n"
"              └─────────┘\n"
"```"

#: src/syntax-extensions/source-analysis.md:69
msgid ""
"The AST contains the structure of the _entire_ program, though it is based "
"on purely _lexical_ information. For example, although the compiler may know "
"that a particular expression is referring to a variable called `a`, at this "
"stage, it has _no way_ of knowing what `a` is, or even _where_ it comes from."
msgstr ""
"ASTはプログラム _全体の_ 構造を含んでいますが、これは純粋に _字句_ の情報に基"
"づいたものです。例えば、コンパイラは特定の式が `a` という変数を参照しているこ"
"とは知っていても、この段階では `a` が何なのか、あるいはそれがどこから来たもの"
"なのかを知る方法は _ありません_ 。"

#: src/syntax-extensions/source-analysis.md:74
msgid ""
"It is _after_ the AST has been constructed that macros are processed. "
"However, before we can discuss that, we have to talk about token trees."
msgstr ""
"マクロが処理されるのは、ASTが構築された _後_ です。しかしながら、その話をする"
"前に、トークンツリーの話をしなければなりません。"

#: src/syntax-extensions/source-analysis.md:77
msgid "Token trees"
msgstr "トークンツリー"

#: src/syntax-extensions/source-analysis.md:79
msgid ""
"Token trees are somewhere between tokens and the AST. Firstly, _almost_ all "
"tokens are also token trees; more specifically, they are _leaves_. There is "
"one other kind of thing that can be a token tree leaf, but we will come back "
"to that later."
msgstr ""
"トークンツリーはトークンとASTの中間に位置します。まず、 _ほとんど_ すべての"
"トークンはトークンツリーでもあり、より具体的にはそれらは _葉_ です。トークン"
"ツリーの葉になりうるものがもう1つありますが、これについては後で説明します。"

#: src/syntax-extensions/source-analysis.md:83
msgid ""
"The only basic tokens that are _not_ leaves are the \"grouping\" tokens: "
"`(...)`, `[...]`, and `{...}`. These three are the _interior nodes_ of token "
"trees, and what give them their structure. To give a concrete example, this "
"sequence of tokens:"
msgstr ""
"葉でない唯一の基本トークンは「グループ化」トークンです： `(...)`, `[...]`, "
"`{...}` 。この3つはトークン木の _内部ノード_ で、トークン木に構造を与えます。"
"具体的な例を挙げます。次のようなトークンの並び："

#: src/syntax-extensions/source-analysis.md:87
msgid ""
"```text\n"
"a + b + (c + d[0]) + e\n"
"```"
msgstr ""
"```text\n"
"a + b + (c + d[0]) + e\n"
"```"

#: src/syntax-extensions/source-analysis.md:91
msgid "would be parsed into the following token trees:"
msgstr "は以下のトークンツリーにパースされます："

#: src/syntax-extensions/source-analysis.md:93
msgid ""
"```text\n"
"«a» «+» «b» «+» «(   )» «+» «e»\n"
"          ╭────────┴──────────╮\n"
"           «c» «+» «d» «[   ]»\n"
"                        ╭─┴─╮\n"
"                         «0»\n"
"```"
msgstr ""
"```text\n"
"«a» «+» «b» «+» «(   )» «+» «e»\n"
"          ╭────────┴──────────╮\n"
"           «c» «+» «d» «[   ]»\n"
"                        ╭─┴─╮\n"
"                         «0»\n"
"```"

#: src/syntax-extensions/source-analysis.md:101
msgid ""
"Note that this has _no relationship_ to the AST the expression would "
"produce; instead of a single root node, there are _seven_ token trees at the "
"root level. For reference, the AST would be:"
msgstr ""
"この式が生成するASTとは _何の関係もない_ ことに注意してください：ルートノード"
"が1つではなく、ルートレベルにトークンツリーが7つあるのです。参考までに、ASTは"
"次のようになります："

#: src/syntax-extensions/source-analysis.md:104
msgid ""
"```text\n"
"                                          ┌─────────┐\n"
"                                          │ BinOp   │\n"
"                                          │ op: Add │\n"
"                                        ┌╴│ lhs: ◌  │\n"
"                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n"
"                            │ op: Add │                 │ name: e │\n"
"                          ┌╴│ lhs: ◌  │                 └─────────┘\n"
"┌─────────┐   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"│ Var     │╶┐ │ BinOp   │╶┘ └─────────┘ └╴│ BinOp   │\n"
"│ name: a │ │ │ op: Add │                 │ op: Add │\n"
"└─────────┘ └╴│ lhs: ◌  │               ┌╴│ lhs: ◌  │\n"
"┌─────────┐ ┌╴│ rhs: ◌  │   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"│ Var     │╶┘ └─────────┘   │ Var     │╶┘ └─────────┘ └╴│ Index   │\n"
"│ name: b │                 │ name: c │               ┌╴│ arr: ◌  │\n"
"└─────────┘                 └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐\n"
"                                          │ Var     │╶┘ └─────────┘ │\n"
"                                          │ name: d │   ┌─────────┐ │\n"
"                                          └─────────┘   │ LitInt  │╶┘\n"
"                                                        │ val: 0  │\n"
"                                                        └─────────┘\n"
"```"
msgstr ""
"```text\n"
"                                          ┌─────────┐\n"
"                                          │ BinOp   │\n"
"                                          │ op: Add │\n"
"                                        ┌╴│ lhs: ◌  │\n"
"                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n"
"                            │ op: Add │                 │ name: e │\n"
"                          ┌╴│ lhs: ◌  │                 └─────────┘\n"
"┌─────────┐   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"│ Var     │╶┐ │ BinOp   │╶┘ └─────────┘ └╴│ BinOp   │\n"
"│ name: a │ │ │ op: Add │                 │ op: Add │\n"
"└─────────┘ └╴│ lhs: ◌  │               ┌╴│ lhs: ◌  │\n"
"┌─────────┐ ┌╴│ rhs: ◌  │   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"│ Var     │╶┘ └─────────┘   │ Var     │╶┘ └─────────┘ └╴│ Index   │\n"
"│ name: b │                 │ name: c │               ┌╴│ arr: ◌  │\n"
"└─────────┘                 └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐\n"
"                                          │ Var     │╶┘ └─────────┘ │\n"
"                                          │ name: d │   ┌─────────┐ │\n"
"                                          └─────────┘   │ LitInt  │╶┘\n"
"                                                        │ val: 0  │\n"
"                                                        └─────────┘\n"
"```"

#: src/syntax-extensions/source-analysis.md:128
msgid ""
"It is important to understand the distinction between the AST and token "
"trees. When writing macros, you have to deal with _both_ as distinct things."
msgstr ""
"ASTとトークンツリーの差異を理解することは重要です。マクロを書くときには、そ"
"の _両方を_ 別個のものとして扱わなければなりません。"

#: src/syntax-extensions/source-analysis.md:131
msgid ""
"One other aspect of this to note: it is _impossible_ to have an unpaired "
"parenthesis, bracket or brace; nor is it possible to have incorrectly nested "
"groups in a token tree."
msgstr ""
"もう一つ注意すべき側面があります：対になっていない括弧や波括弧、鍵括弧を持つ"
"ことは _不可能_ です。またトークンツリーに正しく入れ子になっていないグループ"
"を持つことも不可能です。"

#: src/syntax-extensions/ast.md:1
#, fuzzy
msgid "Macros in the AST"
msgstr "AST内のマクロ"

#: src/syntax-extensions/ast.md:3
#, fuzzy
msgid ""
"As previously mentioned, macro processing in Rust happens _after_ the "
"construction of the AST. As such, the syntax used to invoke a macro _must_ "
"be a proper part of the language's syntax. In fact, there are several "
"\"syntax extension\" forms which are part of Rust's syntax. Specifically, "
"the following 4 forms (by way of examples):"
msgstr ""
"前述のとおり、Rust でのマクロ処理は AST の構築の後に行われます。そのため、マ"
"クロを呼び出す構文は、言語の構文の適切な一部でなければなりません。実際、Rust "
"の構文にはいくつかの「構文拡張」形式があります。具体的には、（例として）次の "
"4 つの形式があります："

#: src/syntax-extensions/ast.md:8
#, fuzzy
msgid "`# [ $arg ]`; _e.g._ `#[derive(Clone)]`, `#[no_mangle]`, …"
msgstr "`# [ $arg ]`; _e.g._ `#[derive(Clone)]`, `#[no_mangle]`, ...."

#: src/syntax-extensions/ast.md:9
#, fuzzy
msgid ""
"`# ! [ $arg ]`; _e.g._ `#![allow(dead_code)]`, `#![crate_name=\"blang\"]`, …"
msgstr ""
"`# ![ $arg ]`; _e.g._ `#![allow(dead_code)]`, `#![crate_name=\"blang\"]`, ..."

#: src/syntax-extensions/ast.md:10
#, fuzzy
msgid "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"
msgstr ""
"$name ！$arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, ...."

#: src/syntax-extensions/ast.md:11
#, fuzzy
msgid "`$name ! $arg0 $arg1`; _e.g._ `macro_rules! dummy { () => {}; }`."
msgstr "$name ！$arg0 $arg1`; _e.g._ `マクロルール！ダミー { () => {}; }`."

#: src/syntax-extensions/ast.md:13
#, fuzzy
msgid ""
"The first two are [attributes](https://doc.rust-lang.org/reference/"
"attributes.html) which annotate items, expressions and statements. They can "
"be classified into different kinds, [built-in attributes](https://doc.rust-"
"lang.org/reference/attributes.html#built-in-attributes-index), [proc-macro "
"attributes](https://doc.rust-lang.org/reference/procedural-macros."
"html#attribute-macros) and [derive attributes](https://doc.rust-lang.org/"
"reference/procedural-macros.html#derive-macro-helper-attributes). [proc-"
"macro attributes](https://doc.rust-lang.org/reference/procedural-macros."
"html#attribute-macros) and [derive attributes](https://doc.rust-lang.org/"
"reference/procedural-macros.html#derive-macro-helper-attributes) can be "
"implemented with the second macro system that Rust offers, [procedural "
"macros](https://doc.rust-lang.org/reference/procedural-macros.html). [built-"
"in attributes](https://doc.rust-lang.org/reference/attributes.html#built-in-"
"attributes-index) on the other hand are attributes implemented by the "
"compiler."
msgstr ""
"最初の2つは[属性](https://doc.rust-lang.org/reference/attributes.html)で、ア"
"イテム、式、ステートメントにアノテーションを付けます。これらの属性は、[組み込"
"み属性](https://doc.rust-lang.org/reference/attributes.html#built-in-"
"attributes-index)、[proc-macro属性](https://doc.rust-lang.org/reference/"
"procedural-macros.html#attribute-macros)、[derive属性](https://doc.rust-lang."
"org/reference/procedural-macros.html#derive-macro-helper-attributes)に分類さ"
"れます。[proc-macro属性](https://doc.rust-lang.org/reference/procedural-"
"macros.html#attribute-macros)と[derive属性](https://doc.rust-lang.org/"
"reference/procedural-macros.html#derive-macro-helper-attributes)は、Rustが提"
"供する2番目のマクロシステムである[手続きマクロ](https://doc.rust-lang.org/"
"reference/procedural-macros.html)で実装できます。一方、[組み込み属性]"
"(https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-"
"index) はコンパイラによって実装される属性です。"

#: src/syntax-extensions/ast.md:19
#, fuzzy
msgid ""
"The third form `$name ! $arg` are function-like macros. It is the form "
"available for use with `macro_rules!`, `macro` and also procedural macros. "
"Note that this form is not _limited_ to `macro_rules!` macros: it is a "
"generic syntax extension form. For example, whilst [`format!`](https://doc."
"rust-lang.org/std/macro.format.html) is a `macro_rules!` macro, "
"[`format_args!`](https://doc.rust-lang.org/std/macro.format_args.html) "
"(which is used to _implement_ [`format!`](https://doc.rust-lang.org/std/"
"macro.format.html)) is _not_ as it is a compiler builtin."
msgstr ""
"第3の形式 `$name ！arg` は関数のようなマクロです。これは `macro_rules!`, "
"`macro` や手続き型マクロで使用できる形式です。この書式は `macro_rules!` マク"
"ロに限定されたものではないことに注意してください。例えば、[`format!`]"
"(https://doc.rust-lang.org/std/macro.format.html) は `macro_rules!` マクロで"
"すが、[`format_args!`](https://doc.rust-lang.org/std/macro.format_args.html) "
"(_implement_ [`format!`](https://doc.rust-lang.org/std/macro.format.html)に使"
"用されます) はコンパイラのビルトインであるため _not_ です。"

#: src/syntax-extensions/ast.md:24
#, fuzzy
msgid ""
"The fourth form is essentially a variation which is _not_ available to "
"macros. In fact, the only case where this form is used _at all_ is with the "
"`macro_rules!` construct itself."
msgstr ""
"第4の形式は、基本的にマクロでは使用できないバリエーションです。実際、この形式"
"が使われるのは `macro_rules!"

#: src/syntax-extensions/ast.md:27
#, fuzzy
msgid ""
"So, starting with the third form, how does the Rust parser know what the "
"`$arg` in (`$name ! $arg`) looks like for every possible syntax extension? "
"The answer is that it doesn't _have to_. Instead, the argument of a syntax "
"extension invocation is a _single_ token tree. More specifically, it is a "
"single, _non-leaf_ token tree; `(...)`, `[...]`, or `{...}`. With that "
"knowledge, it should become apparent how the parser can understand all of "
"the following invocation forms:"
msgstr ""
"では、3番目の形式から始めるとして、Rustパーサーは (`$name ! $arg`) の `$arg` "
"がどのような構文拡張なのかをどうやって知るのでしょうか？答えは、その必要がな"
"いからです。代わりに、構文拡張の呼び出しの引数は_単一の_トークンツリーです。"
"より具体的には、`(...)`、`[...]`、`{...}`のような、単一の_非リーフトークンツ"
"リーです。この知識があれば、パーサがどのようにして以下のすべての呼び出し形式"
"を理解できるかがわかるはずです："

#: src/syntax-extensions/ast.md:34
#, fuzzy
msgid ""
"```rust,ignore\n"
"bitflags! {\n"
"    struct Color: u8 {\n"
"        const RED    = 0b0001,\n"
"        const GREEN  = 0b0010,\n"
"        const BLUE   = 0b0100,\n"
"        const BRIGHT = 0b1000,\n"
"    }\n"
"}\n"
"\n"
"lazy_static! {\n"
"    static ref FIB_100: u32 = {\n"
"        fn fib(a: u32) -> u32 {\n"
"            match a {\n"
"                0 => 0,\n"
"                1 => 1,\n"
"                a => fib(a-1) + fib(a-2)\n"
"            }\n"
"        }\n"
"\n"
"        fib(100)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    use Color::*;\n"
"    let colors = vec![RED, GREEN, BLUE];\n"
"    println!(\"Hello, World!\");\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"ビットフラグ{\n"
"    struct 色: u8 {.\n"
"        const RED = 0b0001、\n"
"        const GREEN = 0b0010、\n"
"        const BLUE = 0b0100、\n"
"        const BRIGHT = 0b1000、\n"
"    }\n"
"}\n"
"\n"
"lazy_static！{\n"
"    静的 ref FIB_100: u32 = { }.\n"
"        fn fib(a: u32) -> u32 { { fn fib(a: u32) -> u32 { { fn fib(a: u32) -"
"> u32\n"
"            マッチ a {\n"
"                0 => 0,\n"
"                1 => 1,\n"
"                a => fib(a-1) + fib(a-2)\n"
"            }\n"
"        }\n"
"\n"
"        fib(100)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    Color::* を使用します；\n"
"    let colors = vec![RED, GREEN, BLUE]；\n"
"    println!(\"Hello, World!\")；\n"
"}\n"
"```"

#: src/syntax-extensions/ast.md:65
#, fuzzy
msgid ""
"Although the above invocations may _look_ like they contain various kinds of "
"Rust code, the parser simply sees a collection of meaningless token trees. "
"To make this clearer, we can replace all these syntactic \"black boxes\" "
"with ⬚, leaving us with:"
msgstr ""
"上記の呼び出しは、様々な種類のRustコードを含んでいるように見えるかもしれませ"
"んが、パーサーは単に無意味なトークンツリーの集まりを見ているだけです。これを"
"明確にするために、これらの構文の「ブラックボックス」をすべて⬚に置き換えること"
"ができます："

#: src/syntax-extensions/ast.md:68
#, fuzzy
msgid ""
"```text\n"
"bitflags! ⬚\n"
"\n"
"lazy_static! ⬚\n"
"\n"
"fn main() {\n"
"    let colors = vec! ⬚;\n"
"    println! ⬚;\n"
"}\n"
"```"
msgstr ""
"テキスト\n"
"ビットフラグ⬚\n"
"\n"
"lazy_static！⬚\n"
"\n"
"fn main() {\n"
"    let colors = vec！⬚;\n"
"    println！⬚;\n"
"}\n"
"```"

#: src/syntax-extensions/ast.md:79
#, fuzzy
msgid ""
"Just to reiterate: the parser does not assume _anything_ about ⬚; it "
"remembers the tokens it contains, but doesn't try to _understand_ them. This "
"means ⬚ can be anything, even invalid Rust! As to why this is a good thing, "
"we will come back to that at a later point."
msgstr ""
"繰り返しますが、パーサーは⬚について何も仮定していません。パーサーは⬚に含まれ"
"るトークンを記憶しますが、それを理解しようとはしません。つまり、⬚は無効なRust"
"でも何でもあり得るということです！これがなぜ良いことなのかについては、また後"
"ほど説明します。"

#: src/syntax-extensions/ast.md:84
#, fuzzy
msgid ""
"So, does this also apply to `$arg` in form 1 and 2, and to the two args in "
"form 4? Kind of. The `$arg` for form 1 and 2 is a bit different in that it "
"is not directly a token tree, but a _simple path_ that is either followed by "
"an `=` token and a literal expression, or a token tree. We will explore this "
"more in-depth in the appropriate proc-macro chapter. The important part here "
"is that this form as well, makes use of token trees to describe the input. "
"The 4th form in general is more special and accepts a very specific grammar "
"that also makes use of token trees though. The specifics of this form do not "
"matter at this point so we will skip them until they become relevant."
msgstr ""
"では、これはフォーム1と2の`$arg`とフォーム4の2つの引数にも適用されるのでしょ"
"うか？そうですね。フォーム1と2の`$arg`は少し違っていて、直接トークンツリーで"
"はなく、`=`トークンとリテラル式、またはトークンツリーが続く_simple path_で"
"す。これについては、適切な proc-macro の章で詳しく説明します。ここで重要なの"
"は、この形式でもトークンツリーを使って入力を記述するということです。一般的な"
"第4の形式はもっと特殊で、トークンツリーを利用する非常に特殊な文法を受け入れま"
"す。この形式の詳細についてはこの時点では重要ではないので、関係するようになる"
"まで省略します。"

#: src/syntax-extensions/ast.md:91
#, fuzzy
msgid "The important takeaways from this are:"
msgstr "ここから得られる重要なことは"

#: src/syntax-extensions/ast.md:93
#, fuzzy
msgid "There are multiple kinds of syntax extensions in Rust."
msgstr "Rustには複数の構文拡張があります。"

#: src/syntax-extensions/ast.md:94
#, fuzzy
msgid ""
"Just seeing something of the form `$name! $arg`, doesn't tell you what kind "
"of syntax extension it might be. It could be a `macro_rules!` macro, a `proc-"
"macro` or maybe even a builtin."
msgstr ""
"name！arg`という形を見ただけでは、それがどのような構文拡張なのかはわかりませ"
"ん。macro_rules!`マクロかもしれないし、 `proc-macro` かもしれないし、組み込み"
"関数かもしれません。"

#: src/syntax-extensions/ast.md:96
#, fuzzy
msgid ""
"The input to every `!` macro invocation, that is form 3, is a single non-"
"leaf token tree."
msgstr ""
"すべての `!` マクロ呼び出しの入力、つまりフォーム3は、1つの非リーフトークンツ"
"リーです。"

#: src/syntax-extensions/ast.md:97
#, fuzzy
msgid "Syntax extensions are parsed as _part_ of the abstract syntax tree."
msgstr "構文拡張は抽象構文木の_part_として解析されます。"

#: src/syntax-extensions/ast.md:99
#, fuzzy
msgid ""
"The last point is the most important, as it has _significant_ implications. "
"Because syntax extensions are parsed into the AST, they can **only** appear "
"in positions where they are explicitly supported. Specifically syntax "
"extensions can appear in place of the following:"
msgstr ""
"重要な意味を持つので、最後の点が最も重要です。構文拡張はASTにパースされるた"
"め、明示的にサポートされている位置にのみ**出現させることができます。具体的に"
"は、シンタックス・エクステンションは以下のような場所に現れます："

#: src/syntax-extensions/ast.md:104
#, fuzzy
msgid "Statements"
msgstr "文"

#: src/syntax-extensions/ast.md:105
msgid "Expressions"
msgstr "式"

#: src/syntax-extensions/ast.md:106
#, fuzzy
msgid "Items(this includes `impl` items)"
msgstr "アイテム(これは `impl` アイテムを含みます)"

#: src/syntax-extensions/ast.md:107
msgid "Types"
msgstr "型"

#: src/syntax-extensions/ast.md:109
#, fuzzy
msgid "Some things _not_ on this list:"
msgstr "このリストにないものもあります："

#: src/syntax-extensions/ast.md:111
#, fuzzy
msgid "Identifiers"
msgstr "識別子"

#: src/syntax-extensions/ast.md:112
#, fuzzy
msgid "Match arms"
msgstr "マッチアーム"

#: src/syntax-extensions/ast.md:113
#, fuzzy
msgid "Struct fields"
msgstr "構造体フィールド"

#: src/syntax-extensions/ast.md:115
#, fuzzy
msgid ""
"There is absolutely, definitely _no way_ to use syntax extensions in any "
"position _not_ on the first list."
msgstr ""
"シンタックス・エクステンションを最初のリスト以外の位置で使用する方法は、絶対"
"に、絶対にありません。"

#: src/syntax-extensions/expansion.md:3
#, fuzzy
msgid ""
"Expansion is a relatively simple affair. At some point _after_ the "
"construction of the AST, but before the compiler begins constructing its "
"semantic understanding of the program, it will expand all syntax extensions."
msgstr ""
"拡張は比較的簡単です。ASTの構築後、コンパイラがプログラムの意味理解を構築し始"
"める前のある時点で、コンパイラはすべての構文拡張を行います。"

#: src/syntax-extensions/expansion.md:6
#, fuzzy
msgid ""
"This involves traversing the AST, locating syntax extension invocations and "
"replacing them with their expansion."
msgstr ""
"これは、ASTをトラバースし、構文拡張の呼び出しを見つけ、その展開に置き換えるこ"
"とを含みます。"

#: src/syntax-extensions/expansion.md:8
#, fuzzy
msgid ""
"Once the compiler has run a syntax extension, it expects the result to be "
"parsable as one of a limited set of syntax elements, based on context. For "
"example, if you invoke a syntax extension at module scope, the compiler will "
"parse the result into an AST node that represents an item. If you invoke a "
"syntax extension in expression position, the compiler will parse the result "
"into an expression AST node."
msgstr ""
"コンパイラが構文拡張を実行すると、その結果はコンテキストに基づいて、限られた"
"構文要素のセットの1つとして解析可能になることが期待されます。たとえば、モ"
"ジュール・スコープで構文拡張を実行した場合、コンパイラーは結果をアイテムを表"
"す AST ノードに解析します。式の位置で構文拡張を呼び出すと、コンパイラーは結果"
"を式の AST ノードに解析します。"

#: src/syntax-extensions/expansion.md:12
#, fuzzy
msgid ""
"In fact, it can turn a syntax extension result into any of the following:"
msgstr ""
"実際、シンタックス・エクステンションの結果を以下のいずれかに変えることができ"
"ます："

#: src/syntax-extensions/expansion.md:14
#, fuzzy
msgid "an expression,"
msgstr ""
"私たちの目標は、簡単な数式を後置記法([逆ポーランド記法](https://en.wikipedia."
"org/wiki/Reverse_Polish_notation)ともに変換することです。\n"
"簡略にするため、式は10桁の数字 `0`, ..., `9` と2つの演算 `+`, `-` で構成され"
"るとします。\n"
"例えば `2 + 4` という式は `2 4 +` に変換されます。"

#: src/syntax-extensions/expansion.md:15
#, fuzzy
msgid "a pattern,"
msgstr "このパターンは標準ライブラリ全体で使われています："

#: src/syntax-extensions/expansion.md:16
#, fuzzy
msgid "a type,"
msgstr ""
"単一のフィールドを持つタプル構造体を使用して、型の不透明なラッパーを作成しま"
"す。\n"
"これは、型のエイリアス (`type` によるもの) ではなく、新しい型を作成します。"

#: src/syntax-extensions/expansion.md:17
#, fuzzy
msgid "zero or more items, or"
msgstr "0個以上の項目、または"

#: src/syntax-extensions/expansion.md:18
#, fuzzy
msgid "zero or more statements."
msgstr "0個以上のステートメント。"

#: src/syntax-extensions/expansion.md:20
#, fuzzy
msgid ""
"In other words, _where_ you can invoke a syntax extension determines what "
"its result will be interpreted as."
msgstr ""
"言い換えれば、どこで構文拡張を呼び出せるかによって、その結果がどのように解釈"
"されるかが決まります。"

#: src/syntax-extensions/expansion.md:22
#, fuzzy
msgid ""
"The compiler will take this AST node and completely replace the syntax "
"extension's invocation node with the output node. _This is a structural "
"operation_, not a textual one!"
msgstr ""
"コンパイラーはこのASTノードを受け取り、構文拡張の呼び出しノードを出力ノードに"
"完全に置き換えます。これは構造的な操作であり、テキスト的な操作ではありませ"
"ん！"

#: src/syntax-extensions/expansion.md:25
#, fuzzy
msgid "For example, consider the following:"
msgstr "例えば、次のように考えてみてください："

#: src/syntax-extensions/expansion.md:27
#, fuzzy
msgid ""
"```rust,ignore\n"
"let eight = 2 * four!();\n"
"```"
msgstr ""
"錆、無視\n"
"let eight = 2 * four!()；\n"
"```"

#: src/syntax-extensions/expansion.md:31
#, fuzzy
msgid "We can visualize this partial AST as follows:"
msgstr "この部分的なASTを視覚化すると、次のようになります："

#: src/syntax-extensions/expansion.md:33
#, fuzzy
msgid ""
"```text\n"
"┌─────────────┐\n"
"│ Let         │\n"
"│ name: eight │   ┌─────────┐\n"
"│ init: ◌     │╶─╴│ BinOp   │\n"
"└─────────────┘   │ op: Mul │\n"
"                ┌╴│ lhs: ◌  │\n"
"     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐\n"
"     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │\n"
"     │ val: 2 │                 │ name: four │\n"
"     └────────┘                 │ body: ()   │\n"
"                                └────────────┘\n"
"```"
msgstr ""
"テキスト\n"
"┌─────────────┐\n"
"│ Let │ （レット\n"
"│ name: 8 │ ┌───────────────────────────────────────────────────────┐\n"
"\n"
"└─────────┘ │ op：ムル │ ┌ ╴ ┌\n"
"                \n"
"     ┌────┐ │ rhs: ◌ │ ╶┐ ┌────┐ │ LitInt\n"
"     \n"
"     \n"
"     \n"
"                                \n"
"```"

#: src/syntax-extensions/expansion.md:47
#, fuzzy
msgid ""
"From context, `four!()` _must_ expand to an expression (the initializer can "
"_only_ be an expression). Thus, whatever the actual expansion is, it will be "
"interpreted as a complete expression. In this case, we will assume `four!` "
"is defined such that it expands to the expression `1 + 3`. As a result, "
"expanding this invocation will result in the AST changing to:"
msgstr ""
"文脈から、`four!()`は式に展開されなければなりません（イニシャライザは式にしか"
"できません）。したがって、実際の展開が何であれ、それは完全な式として解釈され"
"ます。この場合、`four!その結果、この呼び出しを展開するとASTは次のようになりま"
"す："

#: src/syntax-extensions/expansion.md:52
#, fuzzy
msgid ""
"```text\n"
"┌─────────────┐\n"
"│ Let         │\n"
"│ name: eight │   ┌─────────┐\n"
"│ init: ◌     │╶─╴│ BinOp   │\n"
"└─────────────┘   │ op: Mul │\n"
"                ┌╴│ lhs: ◌  │\n"
"     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
"     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n"
"     │ val: 2 │                 │ op: Add │\n"
"     └────────┘               ┌╴│ lhs: ◌  │\n"
"                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n"
"                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n"
"                   │ val: 1 │                 │ val: 3 │\n"
"                   └────────┘                 └────────┘\n"
"```"
msgstr ""
"テキスト\n"
"┌─────────────┐\n"
"│ Let │ （レット\n"
"│ name: 8 │ ┌───────────────────────────────────────────────────────┐\n"
"\n"
"└────────┘ │ op：ムル │ ┌ ╴ ┌\n"
"                \n"
"     \n"
"     LitInt │ ╶└──┘ └──┘ ╴│ BinOp │.\n"
"     val: 2 │ │ op：\n"
"     └────┘ ┌╴│ lhs: ◌ │ └─────┘ ┌╴│ lhs: ◌ │ ┌\n"
"                   ┌────┐ │ rhs: ◌ │ ┌────┐ │ LitInt\n"
"                   \n"
"                   \n"
"                   \n"
"```"

#: src/syntax-extensions/expansion.md:69
#, fuzzy
msgid "This can be written out like so:"
msgstr "これは次のように書き出すことができます："

#: src/syntax-extensions/expansion.md:71
#, fuzzy
msgid ""
"```rust,ignore\n"
"let eight = 2 * (1 + 3);\n"
"```"
msgstr ""
"錆、無視\n"
"let eight = 2 * (1 + 3)；\n"
"```"

#: src/syntax-extensions/expansion.md:75
#, fuzzy
msgid ""
"Note that we added parentheses _despite_ them not being in the expansion. "
"Remember that the compiler always treats the expansion of a syntax extension "
"as a complete AST node, **not** as a mere sequence of tokens. To put it "
"another way, even if you don't explicitly wrap a complex expression in "
"parentheses, there is no way for the compiler to \"misinterpret\" the "
"result, or change the order of evaluation."
msgstr ""
"括弧が拡張に含まれていないことに注意してください。コンパイラは常に構文拡張の"
"展開を完全なASTノードとして扱います。別の言い方をすれば、たとえ複雑な式を明示"
"的に括弧でくくらなかったとしても、コンパイラが結果を「誤って解釈」したり、評"
"価の順序を変更したりすることはありません。"

#: src/syntax-extensions/expansion.md:79
#, fuzzy
msgid ""
"It is important to understand that syntax extension expansions are treated "
"as AST nodes, as this design has two further implications:"
msgstr "構文拡張の展開がASTノードとして扱われることを理解することは重要です："

#: src/syntax-extensions/expansion.md:81
#, fuzzy
msgid ""
"In addition to there being a limited number of invocation _positions_, "
"syntax extension can _only_ expand to the kind of AST node the parser "
"_expects_ at that position."
msgstr ""
"呼び出し_位置の数が限られていることに加えて、構文拡張はパーサーがその位置で_"
"期待する種類のASTノードに_しか展開できません。"

#: src/syntax-extensions/expansion.md:82
#, fuzzy
msgid ""
"As a consequence of the above, syntax extension  _absolutely cannot_ expand "
"to incomplete or syntactically invalid constructs."
msgstr ""
"上記の結果、構文拡張は不完全な構文や構文的に無効な構文に拡張することは絶対に"
"できません。"

#: src/syntax-extensions/expansion.md:84
#, fuzzy
msgid ""
"There is one further thing to note about expansion: what happens when a "
"syntax extension expands to something that contains _another_ syntax "
"extension invocation. For example, consider an alternative definition of "
"`four!`; what happens if it expands to `1 + three!()`?"
msgstr ""
"ある構文拡張が、別の構文拡張の呼び出しを含むものに拡張されるとどうなるかとい"
"うことです。例えば、`four!"

#: src/syntax-extensions/expansion.md:87
#, fuzzy
msgid ""
"```rust,ignore\n"
"let x = four!();\n"
"```"
msgstr ""
"錆、無視\n"
"let x = four!\n"
"```"

#: src/syntax-extensions/expansion.md:91
#, fuzzy
msgid "Expands to:"
msgstr "に拡大："

#: src/syntax-extensions/expansion.md:93
#, fuzzy
msgid ""
"```rust,ignore\n"
"let x = 1 + three!();\n"
"```"
msgstr ""
"錆、無視\n"
"x = 1 + three!\n"
"```"

#: src/syntax-extensions/expansion.md:97
#, fuzzy
msgid ""
"This is resolved by the compiler checking the result of expansions for "
"additional syntax extension invocations, and expanding them. Thus, a second "
"expansion step turns the above into:"
msgstr ""
"この問題は、コンパイラが展開の結果をチェックして構文拡張の追加呼び出しがない"
"かどうかを確認し、それを展開することで解決されます。したがって、2回目の展開ス"
"テップで上記のようになります："

#: src/syntax-extensions/expansion.md:100
#, fuzzy
msgid ""
"```rust,ignore\n"
"let x = 1 + 3;\n"
"```"
msgstr ""
"錆、無視\n"
"x = 1 + 3とします；\n"
"```"

#: src/syntax-extensions/expansion.md:104
#, fuzzy
msgid ""
"The takeaway here is that expansion happens in \"passes\"; as many as is "
"needed to completely expand all invocations."
msgstr ""
"ここでのポイントは、拡張は \"パス \"で行われるということです。すべての呼び出"
"しを完全に拡張するのに必要な数だけ、\"パス \"が必要なのです。"

#: src/syntax-extensions/expansion.md:107
#, fuzzy
msgid ""
"Well, not _quite_. In fact, the compiler imposes an upper limit on the "
"number of such recursive passes it is willing to run before giving up. This "
"is known as the syntax extension recursion limit and defaults to 128. If the "
"128th expansion contains a syntax extension invocation, the compiler will "
"abort with an error indicating that the recursion limit was exceeded."
msgstr ""
"そうではありません。実際、コンパイラはこのような再帰パスの回数に上限を設けて"
"います。これは構文拡張再帰制限と呼ばれ、デフォルトは128です。128回目の展開に"
"構文拡張の呼び出しが含まれていると、コンパイラーは再帰制限を超えたことを示す"
"エラーで中断します。"

#: src/syntax-extensions/expansion.md:112
#, fuzzy
msgid ""
"This limit can be raised using the `#![recursion_limit=\"…\"]` [attribute]"
"(https://doc.rust-lang.org/reference/attributes/limits.html#the-"
"recursion_limit-attribute), though it _must_ be done crate-wide. Generally, "
"it is recommended to try and keep syntax extension below this limit wherever "
"possible as it may impact compilation times."
msgstr ""
"この制限は `#![recursion_limit=\"...\"]` [属性](https://doc.rust-lang.org/"
"reference/attributes/limits.html#the-recursion_limit-attribute) を使って上げ"
"ることができますが、クレート全体で行わなければなりません。一般的に、コンパイ"
"ル時間に影響を与える可能性があるため、可能な限り構文の拡張をこの制限以下に抑"
"えることをお勧めします。"

#: src/syntax-extensions/hygiene.md:3
#, fuzzy
msgid ""
"Hygiene is an important concept for macros. It describes the ability for a "
"macro to work in its own syntax context, not affecting nor being affected by "
"its surroundings. In other words this means that a syntax extension should "
"be invocable anywhere without interfering with its surrounding context."
msgstr ""
"ハイジーンはマクロにとって重要な概念です。これは、マクロがそれ自身の構文コン"
"テキストで動作し、周囲に影響を与えたり、影響を受けたりしないことを表します。"
"言い換えれば、これは構文拡張が周囲のコンテキストに干渉することなく、どこでも"
"呼び出せることを意味します。"

#: src/syntax-extensions/hygiene.md:7
#, fuzzy
msgid ""
"In a perfect world all syntax extensions in Rust would be fully hygienic, "
"unfortunately this isn't the case, so care should be taken to avoid writing "
"syntax extensions that aren't fully hygienic. We will go into general "
"hygiene concepts here which will be touched upon in the corresponding "
"hygiene chapters for the different syntax extensions Rust has to offer."
msgstr ""
"完璧な世界であれば、Rustのすべての構文拡張が完全に衛生的であるべきですが、残"
"念ながらそうではありません。ここでは、Rustが提供するさまざまな構文拡張に対応"
"する衛生の章で触れる、一般的な衛生の概念について説明します。"

#: src/syntax-extensions/hygiene.md:10 src/decl-macros/macros-methodical.md:265
msgid " "
msgstr " "

#: src/syntax-extensions/hygiene.md:12
#, fuzzy
msgid ""
"Hygiene mainly affects identifiers and paths emitted by syntax extensions. "
"In short, if an identifier created by a syntax extension cannot be accessed "
"by the environment where the syntax extension has been invoked it is "
"hygienic in regards to that identifier. Likewise, if an identifier used in a "
"syntax extension cannot reference something defined outside of a syntax "
"extension it is considered hygienic."
msgstr ""
"ハイジーンは主に構文拡張が生成する識別子とパスに影響します。要するに、構文拡"
"張によって生成された識別子が、構文拡張が呼び出された環境からアクセスできない"
"場合、その識別子に関してはハイジェニックです。同様に、構文拡張で使用される識"
"別子が構文拡張の外部で定義されたものを参照できない場合、それは衛生的であると"
"みなされます。"

#: src/syntax-extensions/hygiene.md:16
#, fuzzy
msgid ""
"**Note**: The terms `create` and `use` refer to the position the identifier "
"is in. That is the `Foo` in `struct Foo {}` or the `foo` in `let foo = …;` "
"are created in the sense that they introduce something new under the name, "
"but the `Foo` in `fn foo(_: Foo) {}` or the `foo` in `foo + 3` are usages in "
"the sense that they are referring to something existing."
msgstr ""
"**注意**：create`と `use`という用語は、識別子がどの位置にあるかを表していま"
"す。つまり、`struct Foo {}` の `Foo` や `let foo = ...;` の `foo` は、その名"
"前の下に何か新しいものを導入するという意味で、create されたものですが、`fn "
"foo(_: Foo) {}` の `Foo` や `foo + 3` の `foo` は、既存のものを参照していると"
"いう意味で、usage されたものです。"

#: src/syntax-extensions/hygiene.md:20
#, fuzzy
msgid "This is best shown by example."
msgstr "これは例で示すのが一番です。"

#: src/syntax-extensions/hygiene.md:22
#, fuzzy
msgid ""
"Let's assume we have some syntax extension `make_local` that expands to `let "
"local = 0;`, that is it _creates_ the identifier `local`. Then given the "
"following snippet:"
msgstr ""
"例えば、`let local = 0;`に展開する構文拡張 `make_local` があるとします。次の"
"ようなスニペットがあるとします："

#: src/syntax-extensions/hygiene.md:24
#, fuzzy
msgid ""
"```rust,ignore\n"
"make_local!();\n"
"assert_eq!(local, 0);\n"
"```"
msgstr ""
"錆、無視\n"
"make_local!\n"
"assert_eq!(local, 0)；\n"
"```"

#: src/syntax-extensions/hygiene.md:29
#, fuzzy
msgid ""
"If the `local` in `assert_eq!(local, 0);` resolves to the local defined by "
"the syntax extension, the syntax extension is not hygienic (at least in "
"regards to local names/bindings)."
msgstr ""
"assert_eq!(local, 0);` の `local` が構文拡張で定義された local に解決される場"
"合、構文拡張は (少なくともローカル名/バインディングに関して) 衛生的ではありま"
"せん。"

#: src/syntax-extensions/hygiene.md:31
#, fuzzy
msgid ""
"Now let's assume we have some syntax extension `use_local` that expands to "
"`local = 42;`, that is it makes _use_ of the identifier `local`. Then given "
"the following snippet:"
msgstr ""
"ここで、`local = 42;`に展開される構文拡張 `use_local` があるとします。する"
"と、次のようなスニペットが与えられます："

#: src/syntax-extensions/hygiene.md:33
#, fuzzy
msgid ""
"```rust,ignore\n"
"let mut local = 0;\n"
"use_local!();\n"
"```"
msgstr ""
"錆、無視\n"
"mut local = 0；\n"
"use_local!\n"
"```"

#: src/syntax-extensions/hygiene.md:38
#, fuzzy
msgid ""
"If the `local` inside of the syntax extension for the given invocation "
"resolves to the local defined before its invocation, the syntax extension is "
"not hygienic either."
msgstr ""
"与えられた呼び出しの構文拡張の中の `local` が、その呼び出しの前に定義された "
"local に解決される場合、その構文拡張もハイジェニックではありません。"

#: src/syntax-extensions/hygiene.md:40
#, fuzzy
msgid ""
"This is a rather short introduction to the general concept of hygiene. It "
"will be explained in more depth in the corresponding [`macro_rules!` "
"`hygiene`](../decl-macros/minutiae/hygiene.md) and [proc-macro `hygiene`](../"
"proc-macros/hygiene.md) chapters, with their specific peculiarities."
msgstr ""
"これはハイジーンの一般的な概念についてのやや短い紹介です。これは、対応する"
"[`macro_rules!`hygiene`](../decl-macros/minutiae/hygiene.md)と[proc-macro "
"`hygiene`](../proc-macros/hygiene.md)の章において、その特有の特徴とともにより"
"深く説明されます。"

#: src/syntax-extensions/debugging.md:3
#, fuzzy
msgid ""
"`rustc` provides a number of tools to debug general syntax extensions, as "
"well as some more specific ones tailored towards declarative and procedural "
"macros respectively."
msgstr ""
"rustc`は、一般的な構文拡張をデバッグするためのツールや、宣言型マクロや手続き"
"型マクロに特化したツールを提供しています。"

#: src/syntax-extensions/debugging.md:6
#, fuzzy
msgid ""
"Sometimes, it is what the extension _expands to_ that proves problematic as "
"you do not usually see the expanded code. Fortunately `rustc` offers the "
"ability to look at the expanded code via the unstable `-Zunpretty=expanded` "
"argument. Given the following code:"
msgstr ""
"通常、拡張されたコードを見ることができないので、拡張が問題になることがありま"
"す。幸いなことに `rustc` は不安定な `-Zunpretty=expanded` 引数を使って展開さ"
"れたコードを見ることができます。次のようなコードがあるとします："

#: src/syntax-extensions/debugging.md:10
#, fuzzy
msgid ""
"```rust,ignore\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S {\n"
"    ($e:expr) => {String::from($e)};\n"
"}\n"
"\n"
"fn main() {\n"
"    let world = S!(\"World\");\n"
"    println!(\"Hello, {}!\", world);\n"
"}\n"
"```"
msgstr ""
"ラスト,無視\n"
"// 文字列を初期化するための省略記法。\n"
"macro_rules！S {\n"
"    ($e:expr) => {String::from($e)}；\n"
"}\n"
"\n"
"fn main() {\n"
"    let world = S!(\"World\")；\n"
"    println!(\"Hello, {}!\", world)；\n"
"}\n"
"```"

#: src/syntax-extensions/debugging.md:22
#, fuzzy
msgid "compiled with the following command:"
msgstr "以下のコマンドでコンパイルされます："

#: src/syntax-extensions/debugging.md:24
#, fuzzy
msgid ""
"```shell\n"
"rustc +nightly -Zunpretty=expanded hello.rs\n"
"```"
msgstr ""
"シェル\n"
"rustc +nightly -Zunpretty=expanded hello.rs\n"
"```"

#: src/syntax-extensions/debugging.md:28
#, fuzzy
msgid "produces the following output (modified for formatting):"
msgstr "は次のような出力を生成します（書式を変更）："

#: src/syntax-extensions/debugging.md:30
#, fuzzy
msgid ""
"```rust,ignore\n"
"#![feature(prelude_import)]\n"
"#[prelude_import]\n"
"use std::prelude::rust_2018::*;\n"
"#[macro_use]\n"
"extern crate std;\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S { ($e : expr) => { String :: from($e) } ; }\n"
"\n"
"fn main() {\n"
"    let world = String::from(\"World\");\n"
"    {\n"
"        ::std::io::_print(\n"
"            ::core::fmt::Arguments::new_v1(\n"
"                &[\"Hello, \", \"!\\n\"],\n"
"                &match (&world,) {\n"
"                    (arg0,) => [\n"
"                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::"
"Display::fmt)\n"
"                    ],\n"
"                }\n"
"            )\n"
"        );\n"
"    };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"#![feature(prelude_import)]\n"
"#[prelude_import]\n"
"use std::prelude::rust_2018::*；\n"
"マクロ使用] #[macro_use\n"
"extern crate std；\n"
"// 文字列 `String` を初期化するための省略記法。\n"
"macro_rules！S { ($e : expr) => { String :: from($e) } ; }.\n"
"\n"
"fn main() {\n"
"    let world = String::from(\"World\")；\n"
"    {\n"
"        ::std::io::_print(\n"
"            ::core::fmt::Arguments::new_v1(\n"
"                &[\"こんにちは、\", \"!］\n"
"                マッチ (&world,) { {.\n"
"                    (arg0,) => [\n"
"                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::"
"Display::fmt)\n"
"                    ],\n"
"                }\n"
"            )\n"
"        );\n"
"    };\n"
"}\n"
"```"

#: src/syntax-extensions/debugging.md:56
#, fuzzy
msgid ""
"But not just `rustc` exposes means to aid in debugging syntax extensions. "
"For the aforementioned `-Zunpretty=expanded` option, there exists a nice "
"`cargo` plugin called [`cargo-expand`](https://github.com/dtolnay/cargo-"
"expand) made by [`dtolnay`](https://github.com/dtolnay) which is basically "
"just a wrapper around it."
msgstr ""
"しかし、構文拡張のデバッグを支援する手段は `rustc` だけではありません。前述"
"の `-Zunpretty=expanded` オプションについては、[`dtolnay`](https://github."
"com/dtolnay) によって作られた [`cargo-expand`](https://github.com/dtolnay/"
"cargo-expand) という素晴らしい `cargo` プラグインがあります。"

#: src/syntax-extensions/debugging.md:59
#, fuzzy
msgid ""
"You can also use the [playground](https://play.rust-lang.org/), clicking on "
"its `TOOLS` button in the top right gives you the option to expand syntax "
"extensions as well!"
msgstr ""
"また、[playground](https://play.rust-lang.org/)を使うこともできます。右上の"
"`TOOLS`ボタンをクリックすると、構文拡張を展開するオプションが表示されます！"

#: src/decl-macros.md:3
#, fuzzy
msgid ""
"This chapter will introduce Rust's declarative macro system: [`macro_rules!`]"
"(https://doc.rust-lang.org/reference/macros-by-example.html)."
msgstr ""
"この章ではRustの宣言型マクロシステムを紹介します：[macro_rules!`](https://"
"doc.rust-lang.org/reference/macros-by-example.html)を紹介します。"

#: src/decl-macros.md:5
#, fuzzy
msgid ""
"There are two different introductions in this chapter, a [methodical](./decl-"
"macros/macros-methodical.md) and a [practical](./decl-macros/macros-"
"practical.md)."
msgstr ""
"この章では、[methodical](./decl-macros/macros-methodical.md)と[practical](./"
"decl-macros/macros-practical.md)の2種類の紹介があります。"

#: src/decl-macros.md:7
#, fuzzy
msgid ""
"The former will attempt to give you a complete and thorough explanation of "
"_how_ the system works, while the latter one will cover more practical "
"examples. As such, the [methodical introduction](./decl-macros/macros-"
"methodical.md) is intended for people who just want the system as a whole "
"explained, while the [practical introduction](./decl-macros/macros-practical."
"md) guides one through the implementation of a single macro."
msgstr ""
"前者は、このシステムがどのように動作するのかを完全かつ徹底的に説明しようとす"
"るもので、後者はより実践的な例を扱います。このように、[方法論的入門](./decl-"
"macros/macros-methodical.md)は、システム全体の説明が欲しい人向けで、[実践的入"
"門](./decl-macros/macros-practical.md)は、1つのマクロの実装をガイドします。"

#: src/decl-macros.md:10
#, fuzzy
msgid ""
"Following up the two introductions it offers some generally very useful "
"[patterns](./decl-macros/patterns.md) and [building blocks](./decl-macros/"
"building-blocks.md) for creating feature-rich macros."
msgstr ""
"2つのイントロダクションに続いて、機能豊富なマクロを作成するための、一般的に非"
"常に便利な[パターン](./decl-macros/patterns.md)と[ビルディングブロック](./"
"decl-macros/building-blocks.md)を提供しています。"

#: src/decl-macros.md:12
#, fuzzy
msgid ""
"Other resources about declarative macros include the [Macros chapter of the "
"Rust Book](https://doc.rust-lang.org/book/ch19-06-macros.html) which is a "
"more approachable, high-level explanation as well as the reference [chapter]"
"(https://doc.rust-lang.org/reference/macros-by-example.html) which goes more "
"into the precise details of things."
msgstr ""
"宣言型マクロに関する他のリソースとしては、[Rust Book](https://doc.rust-lang."
"org/book/ch19-06-macros.html)の[Macros chapter](マクロの章)があり、より親しみ"
"やすくハイレベルな説明になっています。また、[chapter](https://doc.rust-lang."
"org/reference/macros-by-example.html)では、より詳細な内容まで言及しています。"

#: src/decl-macros.md:14
#, fuzzy
msgid ""
"**Note**: This book will usually use the term _mbe_(**M**acro-**B**y-"
"**E**xample), _mbe macro_ or `macro_rules!` macro when talking about "
"`macro_rules!` macros."
msgstr ""
"**注**：本書では通常、_mbe_(**M**acro-**B**y-**E**example)、_mbe macro_、また"
"は `macro_rules!` マクロについて話すときには `macro_rules!` マクロという用語"
"を使用します。"

#: src/decl-macros/macros-methodical.md:1
#, fuzzy
msgid "Macros, A Methodical Introduction"
msgstr "マクロ入門"

#: src/decl-macros/macros-methodical.md:3
#, fuzzy
msgid ""
"This chapter will introduce Rust's declarative [Macro-By-Example](https://"
"doc.rust-lang.org/reference/macros-by-example.html) system by explaining the "
"system as a whole. It will do so by first going into the construct's syntax "
"and its key parts and then following it up with more general information "
"that one should at least be aware of."
msgstr ""
"この章では、Rust の宣言型 [Macro-By-Example](https://doc.rust-lang.org/"
"reference/macros-by-example.html) システムを紹介します。まず、マクロの構文と"
"主要な部分について説明し、その後に、少なくとも知っておくべき一般的な情報を説"
"明します。"

#: src/decl-macros/macros-methodical.md:9
#, fuzzy
msgid "`macro_rules!`"
msgstr ""
"次の例では、 `n` 次元ベクタの[ユークリッド距離](https://en.wikipedia.org/"
"wiki/Euclidean_distance) を計算する、単純な `macro_rules!` を作成します。\n"
"`norm!(x,1,2)` と記述するのは、 `x,1,2` を `Vec` に詰め込んで、距離を計算する"
"関数を呼び出すよりも表現が簡単で効率的です。"

#: src/decl-macros/macros-methodical.md:11
#, fuzzy
msgid ""
"With all that in mind, we can introduce `macro_rules!` itself. As noted "
"previously, `macro_rules!` is _itself_ a syntax extension, meaning it is "
"_technically_ not part of the Rust syntax. It uses the following forms:"
msgstr ""
"これを踏まえて、`macro_rules!`そのものを紹介します。前述したように、"
"`macro_rules!`は構文拡張であり、技術的にはRustの構文の一部ではありません。以"
"下の形式を使用します："

#: src/decl-macros/macros-methodical.md:15
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! $name {\n"
"    $rule0 ;\n"
"    $rule1 ;\n"
"    // …\n"
"    $ruleN ;\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"マクロルール名前 {\n"
"    $rule0 ；\n"
"    $rule1 ；\n"
"    // ...\n"
"    $ruleN ；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:24
#, fuzzy
msgid ""
"There must be _at least_ one rule, and you can omit the semicolon after the "
"last rule. You can use brackets(`[]`), parentheses(`()`) or braces(`{}`)."
msgstr ""
"ルールは最低1つ必要で、最後のルールの後のセミコロンは省略できます。括弧"
"(`[]`)、括弧(`()`)、または中括弧(`{}`)を使うことができます。"

#: src/decl-macros/macros-methodical.md:27
#, fuzzy
msgid "Each _\"rule\"_ looks like the following:"
msgstr "それぞれの_\"ルール\"_は以下のようなものです："

#: src/decl-macros/macros-methodical.md:29
#, fuzzy
msgid ""
"```ignore\n"
"    ($matcher) => {$expansion}\n"
"```"
msgstr ""
"無視\n"
"    ($matcher) => {$expansion} です。\n"
"```"

#: src/decl-macros/macros-methodical.md:33
#, fuzzy
msgid ""
"Like before, the types of parentheses used can be any kind, but parentheses "
"around the matcher and braces around the expansion are somewhat "
"conventional. The expansion part of a rule is also called its _transcriber_."
msgstr ""
"先ほどと同様、使用する括弧の種類は何でもかまいませんが、マッチャを括弧で囲"
"み、展開部を中括弧で囲むのが一般的です。ルールの展開部分は、_transcriber_ と"
"も呼ばれます。"

#: src/decl-macros/macros-methodical.md:36
#, fuzzy
msgid ""
"Note that the choice of the parentheses does not matter in regards to how "
"the mbe macro may be invoked. In fact, function-like macros can be invoked "
"with any kind of parentheses as well, but invocations with `{ .. }` and "
"`( ... );`, notice the trailing semicolon, are special in that their "
"expansion will _always_ be parsed as an _item_."
msgstr ""
"括弧の選択は mbe マクロの呼び出し方に関しては問題ではないことに注意してくださ"
"い。実際、関数のようなマクロはどのような括弧でも呼び出すことができますが、 "
"`{ ... }` と `( ... );` を使った呼び出しは特別です。}` と `( ... );` を使った"
"呼び出しは特別で、最後にセミコロンがあることに注意してください。"

#: src/decl-macros/macros-methodical.md:39
#, fuzzy
msgid ""
"If you are wondering, the `macro_rules!` invocation expands to... _nothing_. "
"At least, nothing that appears in the AST; rather, it manipulates compiler-"
"internal structures to register the mbe macro. As such, you can "
"_technically_ use `macro_rules!` in any position where an empty expansion is "
"valid."
msgstr ""
"不思議に思うかもしれませんが、`macro_rules!に展開されます。少なくとも、ASTに"
"は何も表示されません。むしろ、mbeマクロを登録するためにコンパイラ内部の構造を"
"操作します。そのため、`macro_rules!"

#: src/decl-macros/macros-methodical.md:43
#, fuzzy
msgid "Matching"
msgstr "Matching"

#: src/decl-macros/macros-methodical.md:45
#, fuzzy
msgid ""
"When a `macro_rules!` macro is invoked, the `macro_rules!` interpreter goes "
"through the rules one by one, in declaration order. For each rule, it tries "
"to match the contents of the input token tree against that rule's `matcher`. "
"A matcher must match the _entirety_ of the input to be considered a match."
msgstr ""
"macro_rules!`マクロが呼び出されると、 `macro_rules!各ルールに対して、入力され"
"たトークンツリーの内容とそのルールの `matcher` とのマッチを試みます。マッチャ"
"は入力の_entirety_にマッチしなければマッチしたとみなされません。"

#: src/decl-macros/macros-methodical.md:49
#, fuzzy
msgid ""
"If the input matches the matcher, the invocation is replaced by the "
"`expansion`; otherwise, the next rule is tried. If all rules fail to match, "
"the expansion fails with an error."
msgstr ""
"入力がマッチャにマッチした場合、その呼び出しは `expansion` に置き換えられま"
"す。すべてのルールがマッチしなかった場合、展開に失敗してエラーになります。"

#: src/decl-macros/macros-methodical.md:52
#, fuzzy
msgid "The simplest example is of an empty matcher:"
msgstr "最も単純な例は空のマッチャーです："

#: src/decl-macros/macros-methodical.md:54
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! four {\n"
"    () => { 1 + 3 };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    () => { 1 + 3 };\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:60
#, fuzzy
msgid ""
"This matches if and only if the input is also empty (_i.e._ `four!()`, `four!"
"[]` or `four!{}`)."
msgstr ""
"これは入力も空である場合(_i._ `four!()`、`four![]`、`four!{}`)にのみマッチし"
"ます。"

#: src/decl-macros/macros-methodical.md:62
#, fuzzy
msgid ""
"Note that the specific grouping tokens you use when you invoke the function-"
"like macro _are not_ matched, they are in fact not passed to the invocation "
"at all. That is, you can invoke the above macro as `four![]` and it will "
"still match. Only the _contents_ of the input token tree are considered."
msgstr ""
"関数ライクなマクロを呼び出すときに使用する特定のグループ化トークンはマッチし "
"ないことに注意してください。つまり、上記のマクロを `four![]` として呼び出して"
"もマッチします。入力トークン・ツリーの _contents_ だけが考慮されます。"

#: src/decl-macros/macros-methodical.md:66
#, fuzzy
msgid ""
"Matchers can also contain literal token trees, which must be matched "
"exactly. This is done by simply writing the token trees normally. For "
"example, to match the sequence `4 fn ['spang \"whammo\"] @_@`, you would "
"write:"
msgstr ""
"マッチャーにはリテラル・トークンツリーを含めることもできます。これは単純に"
"トークンツリーを普通に書くことで可能です。例えば、`4 fn ['spang \"whammo\"] "
"@_@` というシーケンスにマッチさせるには、次のように書きます："

#: src/decl-macros/macros-methodical.md:70
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! gibberish {\n"
"    (4 fn ['spang \"whammo\"] @_@) => {...};\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    (4 fn ['spang \"whammo\"] @_@) => {...}；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:76
#, fuzzy
msgid "You can use any token tree that you can write."
msgstr "あなたが書くことができる任意のトークンツリーを使用することができます。"

#: src/decl-macros/macros-methodical.md:78
#, fuzzy
msgid "Metavariables"
msgstr "メタ変数"

#: src/decl-macros/macros-methodical.md:80
#, fuzzy
msgid ""
"Matchers can also contain captures. These allow input to be matched based on "
"some general grammar category, with the result captured to a metavariable "
"which can then be substituted into the output."
msgstr ""
"マッチャーはキャプチャを含むこともできます。これにより、一般的な文法カテゴリ"
"に基づいて入力をマッチングし、その結果をメタ変数にキャプチャして出力に代入す"
"ることができます。"

#: src/decl-macros/macros-methodical.md:83
#, fuzzy
msgid ""
"Captures are written as a dollar (`$`) followed by an identifier, a colon (`:"
"`), and finally the kind of capture which is also called the fragment-"
"specifier, which must be one of the following:"
msgstr ""
"キャプチャはドル(`$`)の後に識別子、コロン(`:`)、最後にフラグメント指定子とも"
"呼ばれるキャプチャの種類を書きます："

#: src/decl-macros/macros-methodical.md:85
#, fuzzy
msgid ""
"[`block`](./minutiae/fragment-specifiers.md#block): a block (i.e. a block of "
"statements and/or an expression, surrounded by braces)"
msgstr ""
"[`block`](./minutiae/fragment-specifiers.md#block): ブロック (つまり、中括弧"
"で囲まれたステートメントや式のブロック)"

#: src/decl-macros/macros-methodical.md:86
#, fuzzy
msgid "[`expr`](./minutiae/fragment-specifiers.md#expr): an expression"
msgstr "[`expr`](./minutiae/fragment-specifiers.md#expr): 式"

#: src/decl-macros/macros-methodical.md:87
#, fuzzy
msgid ""
"[`ident`](./minutiae/fragment-specifiers.md#ident): an identifier (this "
"includes keywords)"
msgstr ""
"[`ident`](./minutiae/fragment-specifiers.md#ident): 識別子 (キーワードも含む)"

#: src/decl-macros/macros-methodical.md:88
#, fuzzy
msgid ""
"[`item`](./minutiae/fragment-specifiers.md#item): an item, like a function, "
"struct, module, impl, etc."
msgstr ""
"[item`](./minutiae/fragment-specifiers.md#item): 関数、構造体、モジュール、イ"
"ンプットのようなアイテム。"

#: src/decl-macros/macros-methodical.md:89
#, fuzzy
msgid ""
"[`lifetime`](./minutiae/fragment-specifiers.md#lifetime): a lifetime (e.g. "
"`'foo`, `'static`, ...)"
msgstr ""
"[`lifetime`](./minutiae/fragment-specifiers.md#lifetime): ライフタイム (例 "
"`'foo`、`'static`、...)"

#: src/decl-macros/macros-methodical.md:90
#, fuzzy
msgid ""
"[`literal`](./minutiae/fragment-specifiers.md#literal): a literal (e.g. "
"`\"Hello World!\"`, `3.14`, `'🦀'`, ...)"
msgstr ""
"[`literal`](./minutiae/fragment-specifiers.md#literal): リテラル (例 "
"`\"Hello World!\"`, `3.14`, `'↪So_180'`, ...)"

#: src/decl-macros/macros-methodical.md:91
#, fuzzy
msgid ""
"[`meta`](./minutiae/fragment-specifiers.md#meta): a meta item; the things "
"that go inside the `#[...]` and `#![...]` attributes"
msgstr ""
"[`meta`](./minutiae/fragment-specifiers.md#meta): メタアイテム; `#[...]` や "
"`#![...]` 属性の中に入るもの。"

#: src/decl-macros/macros-methodical.md:92
#, fuzzy
msgid "[`pat`](./minutiae/fragment-specifiers.md#pat): a pattern"
msgstr "[`pat`](./minutiae/fragment-specifiers.md#pat): パターン"

#: src/decl-macros/macros-methodical.md:93
#, fuzzy
msgid ""
"[`path`](./minutiae/fragment-specifiers.md#path): a path (e.g. `foo`, `::"
"std::mem::replace`, `transmute::<_, int>`, …)"
msgstr ""
"[`path`](./minutiae/fragment-specifiers.md#path): パス (例: `foo`, `::std::"
"mem::replace`, `transmute::<_, int>`, ...)"

#: src/decl-macros/macros-methodical.md:94
#, fuzzy
msgid "[`stmt`](./minutiae/fragment-specifiers.md#stmt): a statement"
msgstr "[`stmt`](./minutiae/fragment-specifiers.md#stmt): ステートメント"

#: src/decl-macros/macros-methodical.md:95
#, fuzzy
msgid "[`tt`](./minutiae/fragment-specifiers.md#tt): a single token tree"
msgstr "[`tt`](./minutiae/fragment-specifiers.md#tt): 単一のトークンツリー"

#: src/decl-macros/macros-methodical.md:96
#, fuzzy
msgid "[`ty`](./minutiae/fragment-specifiers.md#ty): a type"
msgstr "[ty`](./minutiae/fragment-specifiers.md#ty)：型"

#: src/decl-macros/macros-methodical.md:97
#, fuzzy
msgid ""
"[`vis`](./minutiae/fragment-specifiers.md#vis): a possible empty visibility "
"qualifier (e.g. `pub`, `pub(in crate)`, ...)"
msgstr ""
"[`vis`](./minutiae/fragment-specifiers.md#vis): 空の可視性修飾子 (例: `pub`, "
"`pub(in crate)`, ...)"

#: src/decl-macros/macros-methodical.md:99
#, fuzzy
msgid ""
"For more in-depth description of the fragment specifiers, check out the "
"[Fragment Specifiers](./minutiae/fragment-specifiers.md) chapter."
msgstr ""
"フラグメント指定子についての詳しい説明は、[フラグメント指定子](./minutiae/"
"fragment-specifiers.md)の章を参照してください。"

#: src/decl-macros/macros-methodical.md:101
#, fuzzy
msgid ""
"For example, here is a `macro_rules!` macro which captures its input as an "
"expression under the metavariable `$e`:"
msgstr ""
"例えば、`macro_rules!`マクロは入力をメタ変数 `$e` の下の式として取り込みま"
"す："

#: src/decl-macros/macros-methodical.md:103
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! one_expression {\n"
"    ($e:expr) => {...};\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    ($e:expr) => {...}；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:109
#, fuzzy
msgid ""
"These metavariables leverage the Rust compiler's parser, ensuring that they "
"are always \"correct\". An `expr` metavariables will _always_ capture a "
"complete, valid expression for the version of Rust being compiled."
msgstr ""
"これらのメタ変数は Rust コンパイラのパーサを活用し、常に「正しい」ことを保証"
"します。メタ変数 `expr` は、コンパイルされている Rust のバージョンに対して、"
"常に完全で有効な式をキャプチャします。"

#: src/decl-macros/macros-methodical.md:112
#, fuzzy
msgid ""
"You can mix literal token trees and metavariables, within limits (explained "
"in [Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md))."
msgstr ""
"リテラル・トークンツリーとメタ変数は、制限の範囲内で混在させることができます"
"（[Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md)で"
"説明しています）。"

#: src/decl-macros/macros-methodical.md:114
#, fuzzy
msgid ""
"To refer to a metavariable you simply write `$name`, as the type of the "
"variable is already specified in the matcher. For example:"
msgstr "メタ変数を参照するには、単に `$name` と書きます。例えば"

#: src/decl-macros/macros-methodical.md:116
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! times_five {\n"
"    ($e:expr) => { 5 * $e };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"マクロルール！ times_five {\n"
"    ($e:expr) => { 5 * $e }；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:122
#, fuzzy
msgid ""
"Much like macro expansion, metavariables are substituted as complete AST "
"nodes. This means that no matter what sequence of tokens is captured by "
"`$e`, it will be interpreted as a single, complete expression."
msgstr ""
"マクロ展開と同様に、メタ変数は完全な AST ノードとして置換されます。つまり、"
"`$e`がどのようなトークンの並びであっても、それは1つの完全な式として解釈されま"
"す。"

#: src/decl-macros/macros-methodical.md:125
#, fuzzy
msgid "You can also have multiple metavariables in a single matcher:"
msgstr "1つのマッチャーに複数のメタ変数を指定することもできます："

#: src/decl-macros/macros-methodical.md:127
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! multiply_add {\n"
"    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"マクロルール！ multiply_add {\n"
"    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) }；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:133
#, fuzzy
msgid "And use them as often as you like in the expansion:"
msgstr "そして、その拡張を好きなだけ使ってください："

#: src/decl-macros/macros-methodical.md:135
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! discard {\n"
"    ($e:expr) => {};\n"
"}\n"
"macro_rules! repeat {\n"
"    ($e:expr) => { $e; $e; $e; };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    ($e:expr) => {}；\n"
"}\n"
"macro_rules!\n"
"    ($e:expr) => { $e; $e; $e; }；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:144
#, fuzzy
msgid ""
"There is also a special metavariable called [`$crate`](./minutiae/hygiene."
"md#crate) which can be used to refer to the current crate."
msgstr ""
"また、[`$crate`](./minutiae/hygiene.md#crate)という特別なメタ変数があり、現在"
"のクレートを参照するために使用できます。"

#: src/decl-macros/macros-methodical.md:149
#, fuzzy
msgid "Repetitions"
msgstr "繰り返し"

#: src/decl-macros/macros-methodical.md:151
#, fuzzy
msgid ""
"Matchers can contain repetitions. These allow a sequence of tokens to be "
"matched. These have the general form `$ ( ... ) sep rep`."
msgstr ""
"マッチャーには繰り返しを含めることができます。これらは一連のトークンをマッチ"
"させることができます。一般的な形式は `$ ( ... ) sep rep` です。"

#: src/decl-macros/macros-methodical.md:154
#, fuzzy
msgid "`$` is a literal dollar token."
msgstr "はリテラルドルトークンです。"

#: src/decl-macros/macros-methodical.md:155
#, fuzzy
msgid "`( ... )` is the paren-grouped matcher being repeated."
msgstr "( ... )`が繰り返されるペアグループ化されたマッチャーです。"

#: src/decl-macros/macros-methodical.md:156
#, fuzzy
msgid ""
"`sep` is an _optional_ separator token. It may not be a delimiter or one of "
"the repetition operators. Common examples are `,` and `;`."
msgstr ""
"sep` は _optional_ separator トークンです。区切り文字や繰り返し演算子ではあり"
"ません。一般的な例は `,` と `;` です。"

#: src/decl-macros/macros-methodical.md:158
#, fuzzy
msgid "`rep` is the _required_ repeat operator. Currently, this can be:"
msgstr "rep` は必須リピート演算子です。現在、これは"

#: src/decl-macros/macros-methodical.md:159
#, fuzzy
msgid "`?`: indicating at most one repetition"
msgstr "?`:最大1回の繰り返しを示します。"

#: src/decl-macros/macros-methodical.md:160
#, fuzzy
msgid "`*`: indicating zero or more repetitions"
msgstr "は0回以上の繰り返しを示します。"

#: src/decl-macros/macros-methodical.md:161
#, fuzzy
msgid "`+`: indicating one or more repetitions"
msgstr "`+`: 1回以上の繰り返しを示します。"

#: src/decl-macros/macros-methodical.md:163
#, fuzzy
msgid ""
"Since `?` represents at most one occurrence, it cannot be used with a "
"separator."
msgstr "?`は出現回数を表すので、セパレータと一緒に使うことはできません。"

#: src/decl-macros/macros-methodical.md:165
#, fuzzy
msgid ""
"Repetitions can contain any other valid matcher, including literal token "
"trees, metavariables, and other repetitions allowing arbitrary nesting."
msgstr ""
"レペティションには、リテラル・トークン・ツリー、メタ変数、任意の入れ子を許す"
"他のレペティションなど、他の有効なマッチャーを含めることができます。"

#: src/decl-macros/macros-methodical.md:167
#, fuzzy
msgid ""
"Repetitions use the same syntax in the expansion and repeated metavariables "
"can only be accessed inside of repetitions in the expansion."
msgstr ""
"繰り返しは展開の中で同じ構文を使用し、繰り返されたメタ変数は展開の中の繰り返"
"しの中でしかアクセスできません。"

#: src/decl-macros/macros-methodical.md:169
#, fuzzy
msgid ""
"For example, below is a mbe macro which formats each element as a string. It "
"matches zero or more comma-separated expressions and expands to an "
"expression that constructs a vector."
msgstr ""
"例えば、以下は各要素を文字列としてフォーマットするmbeマクロです。カンマで区切"
"られたゼロ個以上の式にマッチし、ベクトルを構成する式に展開されます。"

#: src/decl-macros/macros-methodical.md:172
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! vec_strs {\n"
"    (\n"
"        // Start a repetition:\n"
"        $(\n"
"            // Each repeat must contain an expression...\n"
"            $element:expr\n"
"        )\n"
"        // ...separated by commas...\n"
"        ,\n"
"        // ...zero or more times.\n"
"        *\n"
"    ) => {\n"
"        // Enclose the expansion in a block so that we can use\n"
"        // multiple statements.\n"
"        {\n"
"            let mut v = Vec::new();\n"
"\n"
"            // Start a repetition:\n"
"            $(\n"
"                // Each repeat will contain the following statement, with\n"
"                // $element replaced with the corresponding expression.\n"
"                v.push(format!(\"{}\", $element));\n"
"            )*\n"
"\n"
"            v\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let s = vec_strs![1, \"a\", true, 3.14159f32];\n"
"    assert_eq!(s, &[\"1\", \"a\", \"true\", \"3.14159\"]);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ vec_strs {\n"
"    (\n"
"        // 繰り返しを開始します：\n"
"        $(\n"
"            // それぞれの繰り返しは式を含まなければなりません...\n"
"            $element:expr\n"
"        )\n"
"        // ...カンマで区切ります...\n"
"        ,\n"
"        // ...0回以上。\n"
"        *\n"
"    ) => {\n"
"        複数のステートメントを使用できるように、 // 展開をブロックで囲みま"
"す。\n"
"        // 複数のステートメントを使用できるようにします。\n"
"        {\n"
"            let mut v = Vec::new()；\n"
"\n"
"            // 繰り返しを開始します：\n"
"            $(\n"
"                // 各繰り返しは、以下のステートメントを含みます。\n"
"                // 要素を対応する式に置き換えます。\n"
"                v.push(format!(\"{}\", $element))；\n"
"            )*\n"
"\n"
"            v\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let s = vec_strs![1, \"a\", true, 3.14159f32]；\n"
"    assert_eq!(s, &[\"1\", \"a\", \"true\", \"3.14159\"])；\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:208
#, fuzzy
msgid ""
"You can repeat multiple metavariables in a single repetition as long as all "
"metavariables repeat equally often. So this invocation of the following "
"macro works:"
msgstr ""
"すべてのメタ変数が同じ頻度で繰り返される限り、1回の繰り返しで複数のメタ変数を"
"繰り返すことができます。ですから、次のマクロの呼び出しは機能します："

#: src/decl-macros/macros-methodical.md:211
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! repeat_two {\n"
"    ($($i:ident)*, $($i2:ident)*) => {\n"
"        $( let $i: (); let $i2: (); )*\n"
"    }\n"
"}\n"
"\n"
"repeat_two!( a b c d e f, u v w x y z );\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ repeat_two {\n"
"    ($($i:ident)*, $($i2:ident)*) => {\n"
"        $( let $i: (); let $i2: (); )*.\n"
"    }\n"
"}\n"
"\n"
"repeat_two!( a b c d e f, u v w x y z )；\n"
"```"

#: src/decl-macros/macros-methodical.md:221
#, fuzzy
msgid "But this does not:"
msgstr ""
"Rustには、言語の構成要素としてコンストラクタというものを持っていません。\n"
"代わりに [関連関数][associated function] の `new` を使ってオブジェクトを生成"
"するのが一般的です："

#: src/decl-macros/macros-methodical.md:223
#, fuzzy
msgid ""
"```rust\n"
"# macro_rules! repeat_two {\n"
"#     ($($i:ident)*, $($i2:ident)*) => {\n"
"#         $( let $i: (); let $i2: (); )*\n"
"#     }\n"
"# }\n"
"\n"
"repeat_two!( a b c d e f, x y z );\n"
"```"
msgstr ""
"ラスト\n"
"# マクロルール！ repeat_two {\n"
"# ($($i:ident)*, $($i2:ident)*) => {\n"
"# $( let $i: (); let $i2: (); )*.\n"
"# }\n"
"# }\n"
"\n"
"repeat_two!( a b c d e f, x y z )；\n"
"```"

#: src/decl-macros/macros-methodical.md:233
#, fuzzy
msgid "failing with the following error"
msgstr "以下のエラーで失敗します。"

#: src/decl-macros/macros-methodical.md:235
#, fuzzy
msgid ""
"```\n"
"error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times\n"
" --> src/main.rs:6:10\n"
"  |\n"
"6 |         $( let $i: (); let $i2: (); )*\n"
"  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"```"
msgstr ""
"```\n"
"error: メタ変数 `i` は6回繰り返すが `i2` は3回繰り返す\n"
" --> src/main.rs:6:10\n"
"  |\n"
"6 | $( let $i: (); let $i2: (); )*。\n"
"  \n"
"```"

#: src/decl-macros/macros-methodical.md:245
#: src/decl-macros/minutiae/metavar-expr.md:3
#, fuzzy
msgid ""
"_RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-"
"macro-metavar-expr.md)  \n"
"_Tracking Issue_: [rust#83527](https://github.com/rust-lang/rust/"
"issues/83527)  \n"
"_Feature_: `#![feature(macro_metavar_expr)]`"
msgstr ""
"RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-"
"macro-metavar-expr.md)\n"
"_Tracking Issue_: [rust#83527](https://github.com/rust-lang/rust/"
"issues/83527)\n"
"特徴_: `#![feature(macro_metavar_expr)]`。"

#: src/decl-macros/macros-methodical.md:249
#, fuzzy
msgid ""
"Transcriber can contain what is called metavariable expressions. "
"Metavariable expressions provide transcribers with information about "
"metavariables that are otherwise not easily obtainable. With the exception "
"of the `$$` expression, these have the general form `$ { op(...) }`. "
"Currently all metavariable expressions but `$$` deal with repetitions."
msgstr ""
"トランスクライバーには、メタ変数式と呼ばれるものを含めることができます。メタ"
"変数式は、他の方法では簡単には得られないメタ変数に関する情報をトラン スクライ"
"バーに提供します。$$` 式を除いて、これらは一般的な形式 `$ { op(...) }` を持っ"
"ています。現在、`$$`以外のすべてのメタ変数式は繰り返しを扱います。"

#: src/decl-macros/macros-methodical.md:254
#, fuzzy
msgid ""
"The following expressions are available with `ident` being the name of a "
"bound metavariable and `depth` being an integer literal:"
msgstr ""
"次の式は、`ident` を束縛されたメタ変数の名前、`depth` を整数リテラルとして使"
"用できます："

#: src/decl-macros/macros-methodical.md:256
#, fuzzy
msgid ""
"`${count(ident)}`: The number of times `$ident` repeats in the inner-most "
"repetition in total. This is equivalent to `${count(ident, 0)}`."
msgstr ""
"`${count(ident)}`:一番内側の繰り返しで `$ident` が繰り返される合計回数。これ"
"は `${count(ident, 0)}` と同じです。"

#: src/decl-macros/macros-methodical.md:257
#, fuzzy
msgid ""
"`${count(ident, depth)}`: The number of times `$ident` repeats in the "
"repetition at `depth`."
msgstr "`${count(ident, depth)}`：ident` が `depth` で繰り返される回数。"

#: src/decl-macros/macros-methodical.md:258
#, fuzzy
msgid ""
"`${index()}`: The current repetition index of the inner-most repetition. "
"This is equivalent to `${index(0)}`."
msgstr ""
"`${index()}`:最も内側の繰り返しの現在の繰り返しインデックス。これは "
"`${index(0)}` と同じです。"

#: src/decl-macros/macros-methodical.md:259
#, fuzzy
msgid ""
"`${index(depth)}`: The current index of the repetition at `depth`, counting "
"outwards."
msgstr ""
"`${index(depth)}`:外側から数えて `depth` にある繰り返しの現在のインデックス。"

#: src/decl-macros/macros-methodical.md:260
#, fuzzy
msgid ""
"`${length()}`: The number of times the inner-most repetition will repeat "
"for. This is equivalent to `${length(0)}`."
msgstr ""
"`${length()}`:一番内側の繰り返しの回数。これは `${length(0)}` と同じです。"

#: src/decl-macros/macros-methodical.md:261
#, fuzzy
msgid ""
"`${length(depth)}`: The number of times the repetition at `depth` will "
"repeat for, counting outwards."
msgstr "`${length(depth)}`:depth` での繰り返しの回数を指定します。"

#: src/decl-macros/macros-methodical.md:262
#, fuzzy
msgid ""
"`${ignore(ident)}`: Binds `$ident` for repetition, while expanding to "
"nothing."
msgstr "`${ignore(ident)}`:繰り返しのために `$ident` をバインドします。"

#: src/decl-macros/macros-methodical.md:263
#, fuzzy
msgid ""
"`$$`:\tExpands to a single `$`, effectively escaping the `$` token so it "
"won't be transcribed."
msgstr ""
"を一つの `$` に展開し、`$` トークンを効果的にエスケープして転写されないように"
"します。"

#: src/decl-macros/macros-methodical.md:267
#, fuzzy
msgid ""
"For the complete grammar definition you may want to consult the [Macros By "
"Example](https://doc.rust-lang.org/reference/macros-by-example.html#macros-"
"by-example) chapter of the Rust reference."
msgstr ""
"完全な文法定義については、Rustリファレンスの[Macros By Example](https://doc."
"rust-lang.org/reference/macros-by-example.html#macros-by-example)の章を参照し"
"てください。"

#: src/decl-macros/macros-practical.md:1
#, fuzzy
msgid "Macros, A Practical Introduction"
msgstr "マクロ実践入門"

#: src/decl-macros/macros-practical.md:3
#, fuzzy
msgid ""
"This chapter will introduce Rust's declarative [Macro-By-Example](https://"
"doc.rust-lang.org/reference/macros-by-example.html) system using a "
"relatively simple, practical example. It does _not_ attempt to explain all "
"of the intricacies of the system; its goal is to get you comfortable with "
"how and why macros are written."
msgstr ""
"この章では、Rust の宣言型 [Macro-By-Example](https://doc.rust-lang.org/"
"reference/macros-by-example.html) システムを、比較的シンプルで実用的な例を"
"使って紹介します。この章のゴールは、マクロがどのように書かれ、なぜ書かれるの"
"かを理解することです。"

#: src/decl-macros/macros-practical.md:6
#, fuzzy
msgid ""
"There is also the [Macros chapter of the Rust Book](https://doc.rust-lang."
"org/book/ch19-06-macros.html) which is another high-level explanation, and "
"the [methodical introduction](../decl-macros.md) chapter of this book, which "
"explains the macro system in detail."
msgstr ""
"また、[Rust Bookのマクロの章](https://doc.rust-lang.org/book/ch19-06-macros."
"html)もハイレベルな説明ですし、本書の[方法序説](../decl-macros.md)の章もマク"
"ロシステムを詳しく説明しています。"

#: src/decl-macros/macros-practical.md:8
#, fuzzy
msgid "A Little Context"
msgstr "ちょっとした背景"

#: src/decl-macros/macros-practical.md:10
#, fuzzy
msgid ""
"**Note**: don't panic! What follows is the only math that will be talked "
"about. You can quite safely skip this section if you just want to get to the "
"meat of the article."
msgstr ""
"**注**：パニックにならないでください！これから話すのは数学だけです。記事の本"
"題に入りたいだけなら、このセクションは読み飛ばしてかまいません。"

#: src/decl-macros/macros-practical.md:13
#, fuzzy
msgid ""
"If you aren't familiar, a recurrence relation is a sequence where each value "
"is defined in terms of one or more _previous_ values, with one or more "
"initial values to get the whole thing started. For example, the [Fibonacci "
"sequence](https://en.wikipedia.org/wiki/Fibonacci_number) can be defined by "
"the relation:"
msgstr ""
"ご存じないかもしれませんが、漸化式とは、各値が1つまたは複数の前の値で定義さ"
"れ、全体を開始するための1つまたは複数の初期値を持つ数列のことです。例えば、"
"[フィボナッチ数列](https://en.wikipedia.org/wiki/Fibonacci_number) は、この関"
"係で定義することができます："

#: src/decl-macros/macros-practical.md:16
#, fuzzy
msgid "\\\\\\[F\\_{n} = 0, 1, ..., F\\_{n-2} + F\\_{n-1}\\\\\\]"
msgstr "\\\\\\fia{n} = 0, 1, ..., f_{n-2} + f_{n-1}Ω"

#: src/decl-macros/macros-practical.md:18
#, fuzzy
msgid ""
"Thus, the first two numbers in the sequence are 0 and 1, with the third "
"being \\\\( F\\_{0} + F\\_{1} = 0 + 1 = 1\\\\), the fourth \\\\( F\\_{1} + "
"F\\_{2} = 1 + 1 = 2\\\\), and so on forever."
msgstr ""
"このように、数列の最初の2つは0と1で、3番目は㊟（ F_{0} + F_{1} = 0 + 1 = "
"1）、4番目は㊟（ F_{1} + F_{2} = 1 + 1 = 2）というように永遠に続きます。"

#: src/decl-macros/macros-practical.md:20
#, fuzzy
msgid ""
"Now, _because_ such a sequence can go on forever, that makes defining a "
"`fibonacci` function a little tricky, since you obviously don't want to try "
"returning a complete vector. What you _want_ is to return something which "
"will lazily compute elements of the sequence as needed."
msgstr ""
"このような数列は永遠に続く可能性があるため、フィボナッチ関数を定義するのは少"
"し厄介です。なぜなら、明らかに完全なベクトルを返したくないからです。"

#: src/decl-macros/macros-practical.md:23
#, fuzzy
msgid ""
"In Rust, that means producing an [`Iterator`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html). This is not especially _hard_, but there is a "
"fair amount of boilerplate involved: you need to define a custom type, work "
"out what state needs to be stored in it, then implement the [`Iterator`]"
"(https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait for it."
msgstr ""
"Rustでは、これは[`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html)を生成することを意味します。カスタム型を定義し、どのような状態"
"を格納する必要があるのかを調べ、[`Iterator`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html) を実装する必要があります。"

#: src/decl-macros/macros-practical.md:26
#, fuzzy
msgid ""
"However, recurrence relations are simple enough that almost all of these "
"details can be abstracted out with a little `macro_rules!` macro-based code "
"generation."
msgstr "しかし、再帰関係は単純なので、マクロベースのコード生成 `macro_rules!"

#: src/decl-macros/macros-practical.md:28
#, fuzzy
msgid "So, with all that having been said, let's get started."
msgstr "さて、それでは始めましょう。"

#: src/decl-macros/macros-practical.md:32
#, fuzzy
msgid "Construction"
msgstr "構築"

#: src/decl-macros/macros-practical.md:34
#, fuzzy
msgid ""
"Usually, when working on a new `macro_rules!` macro, the first thing I do is "
"decide what the invocation should look like. In this specific case, my first "
"attempt looked like this:"
msgstr ""
"通常、新しい`macro_rules!この具体的なケースでは、私の最初の試みは次のようなも"
"のでした："

#: src/decl-macros/macros-practical.md:37
#, fuzzy
msgid ""
"```rust,ignore\n"
"let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"ラスト,無視\n"
"let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]]；\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }.\n"
"```"

#: src/decl-macros/macros-practical.md:43
#, fuzzy
msgid ""
"From that, we can take a stab at how the `macro_rules!` macro should be "
"defined, even if we aren't sure of the actual expansion. This is useful "
"because if you can't figure out how to parse the input syntax, then _maybe_ "
"you need to change it."
msgstr ""
"これによって、実際の展開がよくわからなくても、`macro_rules!`マクロをどのよう"
"に定義すべきかがわかります。入力された構文を解析する方法がわからない場合は、"
"構文を変更する必要があるかもしれないので、これは便利です。"

#: src/decl-macros/macros-practical.md:46
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! recurrence {\n"
"    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ };\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆、無視\n"
"マクロ規則\n"
"    ( a[n] = $($inits:expr),+ , ..., $recur:expr ) => { /* ... */ };\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/macros-practical.md:53
#, fuzzy
msgid ""
"Assuming you aren't familiar with the syntax, allow me to elucidate. This is "
"defining a syntax extension, using the [`macro_rules!`](./macros-methodical."
"md) system, called `recurrence!`. This `macro_rules!` macro has a single "
"parsing rule. That rule says the input to the invocation must match:"
msgstr ""
"あなたが構文に詳しくないことを前提に、説明させてください。これは、"
"[`macro_rules!`](./macros-methodical.md)システムを使って、`recurrence!`という"
"構文拡張を定義しています。この `macro_rules!` マクロには構文解析ルールが 1 つ"
"あります。そのルールとは、呼び出しの入力が一致しなければならないというもので"
"す："

#: src/decl-macros/macros-practical.md:58
#, fuzzy
msgid "the literal token sequence `a` `[` `n` `]` `=`,"
msgstr "リテラルトークン列 `a` `[`n` `]`=`、"

#: src/decl-macros/macros-practical.md:59
#, fuzzy
msgid ""
"a [repeating](./macros-methodical.md#repetitions) (the `$( ... )`) sequence, "
"using `,` as a separator, and one or more (`+`) repeats of:"
msgstr ""
"a [repeating](./macros-methodical.md#repetitions) (`$( ... )`) シーケンスで、"
"区切り文字として `,` を使用し、1つ以上の (`+`) リピート："

#: src/decl-macros/macros-practical.md:60
#, fuzzy
msgid ""
"a valid _expression_ captured into the [metavariable](./macros-methodical."
"md#metavariables) `inits` (`$inits:expr`)"
msgstr ""
"メタ変数](./macros-methodical.md#metavariables) の `inits` (`$inits:expr`) に"
"取り込まれた有効な _expression_ 。"

#: src/decl-macros/macros-practical.md:61
#, fuzzy
msgid "the literal token sequence `,` `...` `,`,"
msgstr "リテラルトークン列 `,` `...` `,`、"

#: src/decl-macros/macros-practical.md:62
#, fuzzy
msgid ""
"a valid _expression_ captured into the [metavariable](./macros-methodical."
"md#metavariables) `recur` (`$recur:expr`)."
msgstr ""
"メタ変数](./macros-methodical.md#metavariables) の `recur` (`$recur:expr`) に"
"取り込まれた有効な _expression_ です。"

#: src/decl-macros/macros-practical.md:67
#, fuzzy
msgid ""
"Finally, the rule says that _if_ the input matches this rule, then the "
"invocation should be replaced by the token sequence `/* ... */`."
msgstr ""
"最後に、入力がこのルールにマッチする場合、その呼び出しはトークン列 `/* .... "
"*/`."

#: src/decl-macros/macros-practical.md:69
#, fuzzy
msgid ""
"It's worth noting that `inits`, as implied by the name, actually contains "
"_all_ the expressions that match in this position, not just the first or "
"last. What's more, it captures them _as a sequence_ as opposed to, say, "
"irreversibly pasting them all together. Also note that you can do \"zero or "
"more\" with a repetition by using `*` instead of `+` and even optional, "
"\"zero or one\" with `?`."
msgstr ""
"注目すべき点は、`inits`という名前から想像されるように、実際にはこの位置でマッ"
"チした式を最初や最後だけでなく、_すべて_含むということです。さらに、例えば不"
"可逆的にまとめて貼り付けるのとは対照的に、_シーケンスとしてキャプチャします。"
"また、`+`の代わりに`*`を使用することで、繰り返しを「0以上」にすることができま"
"す。"

#: src/decl-macros/macros-practical.md:73
#, fuzzy
msgid ""
"As an exercise, let's take the proposed input and feed it through the rule, "
"to see how it is processed. The \"Position\" column will show which part of "
"the syntax pattern needs to be matched against next, denoted by a \"⌂\". "
"Note that in some cases, there might be more than one possible \"next\" "
"element to match against. \"Input\" will contain all of the tokens that have "
"_not_ been consumed yet. `inits` and `recur` will contain the contents of "
"those bindings."
msgstr ""
"練習として、提案された入力をルールに通して、それがどのように処理されるかを見"
"てみましょう。位置」列は、構文パターンのどの部分と次にマッチする必要があるか"
"を示します。場合によっては、マッチする \"next \"要素が複数あるかもしれないこ"
"とに注意してください。「Input \"には、まだ_消費されていないすべてのトークンが"
"含まれます。inits`と `recur`にはそれらのバインディングの内容が格納されます。"

#: src/decl-macros/macros-practical.md:265
#, fuzzy
msgid ""
"The key take-away from this is that the macro system will _try_ to "
"incrementally match the tokens provided as input to the macro against the "
"provided rules. We'll come back to the \"try\" part."
msgstr ""
"ここから得られる重要な点は、マクロ システムが、マクロへの入力として提供された"
"トークンを、提供されたルールに対してインクリメンタルに照合しようと試みるとい"
"うことです。try」の部分については、また後で説明します。"

#: src/decl-macros/macros-practical.md:268
#, fuzzy
msgid ""
"Now, let's begin writing the final, fully expanded form. For this expansion, "
"I was looking for something like:"
msgstr ""
"では、最終的な完全な展開形を書き始めましょう。この展開のために、私は次のよう"
"なものを探していました："

#: src/decl-macros/macros-practical.md:271
#, fuzzy
msgid ""
"```rust,ignore\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem: [u64; 2],\n"
"        pos: usize,\n"
"    }\n"
"```"
msgstr ""
"錆,無視\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem：[u64; 2],\n"
"        pos: usize、\n"
"    }\n"
"```"

#: src/decl-macros/macros-practical.md:279
#, fuzzy
msgid ""
"This will be the actual iterator type. `mem` will be the memo buffer to hold "
"the last few values so the recurrence can be computed. `pos` is to keep "
"track of the value of `n`."
msgstr ""
"これが実際のイテレータ型になります。mem` はメモバッファで、再帰を計算できるよ"
"うに直近のいくつかの値を保持します。pos` は `n` の値を保持します。"

#: src/decl-macros/macros-practical.md:283
#, fuzzy
msgid ""
"**Aside**: I've chosen `u64` as a \"sufficiently large\" type for the "
"elements of this sequence. Don't worry about how this will work out for "
"_other_ sequences; we'll come to it."
msgstr ""
"**余談**：この配列の要素には「十分に大きい」型として `u64` を選びました。これ"
"が他の_配列でどうなるかについては心配しないでください。"

#: src/decl-macros/macros-practical.md:286
#, fuzzy
msgid ""
"```rust,ignore\n"
"    impl Iterator for Recurrence {\n"
"        type Item = u64;\n"
"\n"
"        fn next(&mut self) -> Option<Self::Item> {\n"
"            if self.pos < 2 {\n"
"                let next_val = self.mem[self.pos];\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"```"
msgstr ""
"錆、無視\n"
"    暗黙の反復子\n"
"        型 Item = u64；\n"
"\n"
"        fn next(&amp;mut self) -&gt; オプション<Self::Item> {。\n"
"            if self.pos &lt; 2 { if self.pos &lt; 2\n"
"                let next_val = self.mem[self.pos]；\n"
"                self.pos += 1；\n"
"                some(next_val)\n"
"```"

#: src/decl-macros/macros-practical.md:297
#, fuzzy
msgid ""
"We need a branch to yield the initial values of the sequence; nothing tricky."
msgstr "難しいことは何もありません。"

#: src/decl-macros/macros-practical.md:299
#, fuzzy
msgid ""
"```rust,ignore\n"
"            } else {\n"
"                let a = /* something */;\n"
"                let n = self.pos;\n"
"                let next_val = a[n-2] + a[n-1];\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val);\n"
"\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"錆、無視\n"
"            } else {\n"
"                let a = /* 何か */；\n"
"                let n = self.pos；\n"
"                let next_val = a[n-2] + a[n-1]；\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val)；\n"
"\n"
"                self.pos += 1；\n"
"                some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"```"

#: src/decl-macros/macros-practical.md:314
#, fuzzy
msgid ""
"This is a bit harder; we'll come back and look at _how_ exactly to define "
"`a`. Also, `TODO_shuffle_down_and_append` is another placeholder; I want "
"something that places `next_val` on the end of the array, shuffling the rest "
"down by one space, dropping the 0th element."
msgstr ""
"これは少し難しいので、`a`をどのように正確に定義するかについては、また後で説明"
"します。また、`TODO_shuffle_down_and_append`もプレースホルダです。`next_val`"
"を配列の末尾に配置し、残りの要素を1つ下にシャッフルして、0番目の要素を削除し"
"ます。"

#: src/decl-macros/macros-practical.md:318
#, fuzzy
msgid ""
"```rust,ignore\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"錆、無視\n"
"\n"
"    再帰{ mem：[0, 1], pos：0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }.\n"
"```"

#: src/decl-macros/macros-practical.md:326
#, fuzzy
msgid ""
"Lastly, return an instance of our new structure, which can then be iterated "
"over. To summarize, the complete expansion is:"
msgstr ""
"最後に、新しい構造体のインスタンスを返します。要約すると、完全な展開は次のよ"
"うになります："

#: src/decl-macros/macros-practical.md:329
#, fuzzy
msgid ""
"```rust,ignore\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem: [u64; 2],\n"
"        pos: usize,\n"
"    }\n"
"\n"
"    impl Iterator for Recurrence {\n"
"        type Item = u64;\n"
"\n"
"        fn next(&mut self) -> Option<u64> {\n"
"            if self.pos < 2 {\n"
"                let next_val = self.mem[self.pos];\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            } else {\n"
"                let a = /* something */;\n"
"                let n = self.pos;\n"
"                let next_val = (a[n-2] + a[n-1]);\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val.clone());\n"
"\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"錆,無視\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem：[u64; 2],\n"
"        pos: usize、\n"
"    }\n"
"\n"
"    impl Iterator for Recurrence { { {: アイテム\n"
"        型 Item = u64；\n"
"\n"
"        fn next(&amp;mut self) -&gt; オプション<u64> {。\n"
"            if self.pos &lt; 2 { if self.pos &lt; 2\n"
"                let next_val = self.mem[self.pos]；\n"
"                self.pos += 1；\n"
"                some(next_val)\n"
"            } else {\n"
"                let a = /* 何か */；\n"
"                let n = self.pos；\n"
"                let next_val = (a[n-2] + a[n-1])；\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val.clone())；\n"
"\n"
"                self.pos += 1；\n"
"                ある(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    再帰 { mem：[0, 1], pos：0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"```"

#: src/decl-macros/macros-practical.md:363
#, fuzzy
msgid ""
"**Aside**: Yes, this _does_ mean we're defining a different `Recurrence` "
"struct and its implementation for each invocation. Most of this will "
"optimise away in the final binary."
msgstr ""
"**余談ですが**：そうですね、これは呼び出しごとに異なる `Recurrence` 構造体と"
"その実装を定義していることを意味します。このほとんどは最終的なバイナリで最適"
"化されます。"

#: src/decl-macros/macros-practical.md:366
#, fuzzy
msgid ""
"It's also useful to check your expansion as you're writing it. If you see "
"anything in the expansion that needs to vary with the invocation, but "
"_isn't_ in the actual accepted syntax of our macro, you should work out "
"where to introduce it. In this case, we've added `u64`, but that's not "
"necessarily what the user wants, nor is it in the macro syntax. So let's fix "
"that."
msgstr ""
"書きながら展開をチェックするのも便利です。展開の中に、マクロの呼び出しによっ"
"て変化する必要があるが、マクロの実際の構文にはないものがあれば、それをどこに"
"導入すればよいかを検討する必要があります。この場合、`u64`を追加しましたが、こ"
"れは必ずしもユーザーが望むものではありませんし、マクロ構文にもありません。で"
"すから、それを修正しましょう。"

#: src/decl-macros/macros-practical.md:370
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"/*\n"
"let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"*/\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ..., $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"/*\n"
"let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]]；\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) } /* let fib = recurrence!\n"
"*/\n"
"# fn main() {}.\n"
"```"

#: src/decl-macros/macros-practical.md:383
#, fuzzy
msgid "Here, I've added a new metavariable: `sty` which should be a type."
msgstr "ここでは、新しいメタ変数を追加しました：これは型であるべきです。"

#: src/decl-macros/macros-practical.md:385
#, fuzzy
msgid ""
"**Aside**: if you're wondering, the bit after the colon in a metavariable "
"can be one of several kinds of syntax matchers. The most common ones are "
"`item`, `expr`, and `ty`. A complete explanation can be found in [Macros, A "
"Methodical Introduction; `macro_rules!` (Matchers)](./macros-methodical."
"md#metavariables)."
msgstr ""
"**余談**: もし気になるようでしたら、メタ変数のコロンの後のビットはいくつかの"
"種類の構文マッチャのうちの1つになります。最も一般的なものは `item`、`expr`、"
"`ty` です。完全な説明は [Macros, A Methodical Introduction; `macro_rules!` "
"(Matchers)](./macros-methodical.md#metavariables) にあります。"

#: src/decl-macros/macros-practical.md:389
#, fuzzy
msgid ""
"There's one other thing to be aware of: in the interests of future-proofing "
"the language, the compiler restricts what tokens you're allowed to put "
"_after_ a matcher, depending on what kind it is. Typically, this comes up "
"when trying to match expressions or statements; those can _only_ be followed "
"by one of `=>`, `,`, and `;`."
msgstr ""
"もう1つ注意しなければならないことがあります。コンパイラは将来的な言語の安全性"
"を確保するために、マッチャーの種類に応じて、マッチャーの後にどのようなトーク"
"ンを置くことができるかを制限しています。一般的には、式や文にマッチさせようと"
"するときにこのようなことが起こります。"

#: src/decl-macros/macros-practical.md:393
#, fuzzy
msgid ""
"A complete list can be found in [Macros, A Methodical Introduction; "
"Minutiae; Metavariables and Expansion Redux](./minutiae/metavar-and-"
"expansion.md)."
msgstr ""
"完全なリストは[Macros, A Methodical Introduction; Minutiae; Metavariables "
"and Expansion Redux](./minutiae/metavar-and-expansion.md)にあります。"

#: src/decl-macros/macros-practical.md:395
#, fuzzy
msgid "Indexing and Shuffling"
msgstr "インデックスとシャッフル"

#: src/decl-macros/macros-practical.md:397
#, fuzzy
msgid ""
"I will skim a bit over this part, since it's effectively tangential to the "
"macro-related stuff. We want to make it so that the user can access previous "
"values in the sequence by indexing `a`; we want it to act as a sliding "
"window keeping the last few (in this case, 2) elements of the sequence."
msgstr ""
"この部分はマクロに関係することなので、少し読み飛ばします。ユーザが `a` をイン"
"デックスすることで、シーケンスの前の値にアクセスできるようにしたいのです。"
"シーケンスの最後の数個（この場合は2個）の要素を保持するスライディングウィンド"
"ウとして動作させたいのです。"

#: src/decl-macros/macros-practical.md:401
#, fuzzy
msgid "We can do this pretty easily with a wrapper type:"
msgstr "これはラッパー型を使えば簡単にできます："

#: src/decl-macros/macros-practical.md:403
#, fuzzy
msgid ""
"```rust,ignore\n"
"struct IndexOffset<'a> {\n"
"    slice: &'a [u64; 2],\n"
"    offset: usize,\n"
"}\n"
"\n"
"impl<'a> Index<usize> for IndexOffset<'a> {\n"
"    type Output = u64;\n"
"\n"
"    fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"        use std::num::Wrapping;\n"
"\n"
"        let index = Wrapping(index);\n"
"        let offset = Wrapping(self.offset);\n"
"        let window = Wrapping(2);\n"
"\n"
"        let real_index = index - offset + window;\n"
"        &self.slice[real_index.0]\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [u64; 2\n"
"    slice: &amp;'a [u64; 2]、\n"
"    オフセット: usize、\n"
"}\n"
"\n"
"impl<'a> Index<usize> for IndexOffset<'a> {\n"
"    型 Output = u64；\n"
"\n"
"    fn index<'b>(&'b self, index: usize) -> &amp;'b u64 {.\n"
"        use std::num::Wrapping；\n"
"\n"
"        let index = Wrapping(index)；\n"
"        let offset = Wrapping(self.offset)；\n"
"        let window = Wrapping(2)；\n"
"\n"
"        let real_index = index - offset + window；\n"
"        &amp;self.slice[real_index.0].\n"
"    }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:425
#, fuzzy
msgid ""
"**Aside**: since lifetimes come up _a lot_ with people new to Rust, a quick "
"explanation: `'a` and `'b` are lifetime parameters that are used to track "
"where a reference (_i.e._ a borrowed pointer to some data) is valid. In this "
"case, `IndexOffset` borrows a reference to our iterator's data, so it needs "
"to keep track of how long it's allowed to hold that reference for, using "
"`'a`."
msgstr ""
"**余談**: Rust を初めて使う人にはライフタイムがよく出てくるので、簡単に説明し"
"ます: `'a` と `'b` はライフタイムパラメータで、参照 (つまり、あるデータへのポ"
"インタを借用したもの) の有効期限を追跡するために使用します。この場合、 "
"`IndexOffset` はイテレータのデータへの参照を借用しているので、 `'a` を使用し"
"て、その参照をいつまで保持できるかを追跡する必要があります。"

#: src/decl-macros/macros-practical.md:428
#, fuzzy
msgid ""
"`'b` is used because the `Index::index` function (which is how subscript "
"syntax is actually implemented) is _also_ parameterized on a lifetime, on "
"account of returning a borrowed reference. `'a` and `'b` are not necessarily "
"the same thing in all cases. The borrow checker will make sure that even "
"though we don't explicitly relate `'a` and `'b` to one another, we don't "
"accidentally violate memory safety."
msgstr ""
"b` が使用されるのは、`Index::index` 関数（添え字構文が実際に実装されている方"
"法です）が、借用された参照を返すという理由で、ライフタイムにパラメータ化され"
"ているからです。a` と `'b` は必ずしも同じものではありません。借用チェッカー"
"は、明示的に `'a` と `'b` を互いに関連付けなくとも、誤ってメモリ安全に違反し"
"ないことを確認します。"

#: src/decl-macros/macros-practical.md:432
#, fuzzy
msgid "This changes the definition of `a` to:"
msgstr "これは `a` の定義を次のように変更します："

#: src/decl-macros/macros-practical.md:434
#, fuzzy
msgid ""
"```rust,ignore\n"
"let a = IndexOffset { slice: &self.mem, offset: n };\n"
"```"
msgstr ""
"ラスト,無視\n"
"let a = IndexOffset { slice: &self.mem, offset: n }；\n"
"```"

#: src/decl-macros/macros-practical.md:438
#, fuzzy
msgid ""
"The only remaining question is what to do about "
"`TODO_shuffle_down_and_append`. I wasn't able to find a method in the "
"standard library with exactly the semantics I wanted, but it isn't hard to "
"do by hand."
msgstr ""
"唯一残っている問題は、`TODO_shuffle_down_and_append`をどうするかということで"
"す。標準ライブラリには、私が望んでいるセマンティクスを正確に備えたメソッドを"
"見つけることはできませんでしたが、手作業で行うのは難しくありません。"

#: src/decl-macros/macros-practical.md:441
#, fuzzy
msgid ""
"```rust,ignore\n"
"{\n"
"    use std::mem::swap;\n"
"\n"
"    let mut swap_tmp = next_val;\n"
"    for i in (0..2).rev() {\n"
"        swap(&mut swap_tmp, &mut self.mem[i]);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"{\n"
"    std::mem::swapを使用します；\n"
"\n"
"    mut swap_tmp = next_val；\n"
"    for i in (0..2).rev() { { swap(&mut swap_tmp, &mut self.mem[i]).\n"
"        swap(&mut swap_tmp, &mut self.mem[i])；\n"
"    }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:452
#, fuzzy
msgid ""
"This swaps the new value into the end of the array, swapping the other "
"elements down one space."
msgstr ""
"これは、新しい値を配列の末尾に入れ替え、他の要素を1つ下のスペースに入れ替えま"
"す。"

#: src/decl-macros/macros-practical.md:454
#, fuzzy
msgid ""
"**Aside**: doing it this way means that this code will work for non-copyable "
"types, as well."
msgstr ""
"**余談**：このようにすることで、このコードはコピー不可能な型でも動作すること"
"になります。"

#: src/decl-macros/macros-practical.md:456
#, fuzzy
msgid "The working code thus far now looks like this:"
msgstr "これまでのコードは以下のようなものです："

#: src/decl-macros/macros-practical.md:458
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"fn main() {\n"
"    /*\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"    */\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"\n"
"        struct Recurrence {\n"
"            mem: [u64; 2],\n"
"            pos: usize,\n"
"        }\n"
"\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; 2],\n"
"            offset: usize,\n"
"        }\n"
"\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(2);\n"
"\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < 2 {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                        a[n-2] + a[n-1]\n"
"                    };\n"
"\n"
"                    {\n"
"                        use std::mem::swap;\n"
"\n"
"                        let mut swap_tmp = next_val;\n"
"                        for i in [1,0] {\n"
"                            swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                        }\n"
"                    }\n"
"\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Recurrence { mem: [0, 1], pos: 0 }\n"
"    };\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ..., $recur:expr ) =&gt; { /* ... "
"*/ };\n"
"}\n"
"\n"
"fn main() {\n"
"    /*\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]]；\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }.\n"
"    */\n"
"    let fib = {\n"
"        use std::ops::Index；\n"
"\n"
"        struct Recurrence {\n"
"            mem：[u64; 2],\n"
"            pos: usize、\n"
"        }\n"
"\n"
"        struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [u64; 2\n"
"            slice: &amp;'a [u64; 2]、\n"
"            offset: usize、\n"
"        }\n"
"\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            型 Output = u64；\n"
"\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &amp;'b u64 {.\n"
"                use std::num::Wrapping；\n"
"\n"
"                let index = Wrapping(index)；\n"
"                let offset = Wrapping(self.offset)；\n"
"                let window = Wrapping(2)；\n"
"\n"
"                let real_index = index - offset + window；\n"
"                &amp;self.slice[real_index.0].\n"
"            }\n"
"        }\n"
"\n"
"        impl Iterator for Recurrence { (再帰のイテレータ)\n"
"            型 Item = u64；\n"
"\n"
"            #インライン\n"
"            fn next(&amp;mut self) -&gt; オプション<u64> {。\n"
"                if self.pos &lt; 2 { if self.pos &lt; 2\n"
"                    let next_val = self.mem[self.pos]；\n"
"                    self.pos += 1；\n"
"                    some(next_val)\n"
"                } else {\n"
"                    let next_val = { {.\n"
"                        let n = self.pos；\n"
"                        let a = IndexOffset { slice: &amp;self.mem, offset: "
"n }；\n"
"                        a[n-2] + a[n-1].\n"
"                    };\n"
"\n"
"                    {\n"
"                        use std::mem::swap；\n"
"\n"
"                        mut swap_tmp = next_val；\n"
"                        for i in [1,0] { { { swap(&amp;mut swap_tmp, &amp;"
"mut self.mem[i])\n"
"                            swap(&amp;mut swap_tmp, &amp;mut self.mem[i])；\n"
"                        }\n"
"                    }\n"
"\n"
"                    self.pos += 1；\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        再帰 { mem：[0, 1], pos：0 }\n"
"    };\n"
"\n"
"    for e in fib.take(10) { println!(\"&lt;1/&gt;\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:536
#, fuzzy
msgid ""
"Note that I've changed the order of the declarations of `n` and `a`, as well "
"as wrapped them(along with the recurrence expression) in a block. The reason "
"for the first should be obvious(`n` needs to be defined first so I can use "
"it for `a`). The reason for the second is that the borrowed reference `&self."
"mem` will prevent the swaps later on from happening (you cannot mutate "
"something that is aliased elsewhere). The block ensures that the `&self.mem` "
"borrow expires before then."
msgstr ""
"n` と `a` の宣言の順番を変更し、(再帰式と一緒に) ブロックでラップしていること"
"に注意してください。最初の理由は明らかでしょう（`a`で使用するために`n`を最初"
"に定義する必要がある）。2つ目の理由は、参照 `&self.mem` を借用することで、後"
"でスワップが発生しないようにするためです（別の場所でエイリアスされたものを変"
"異させることはできません）。このブロックは、`&self.mem`の借用がそれまでに期限"
"切れになるようにします。"

#: src/decl-macros/macros-practical.md:540
#, fuzzy
msgid ""
"Incidentally, the only reason the code that does the `mem` swaps is in a "
"block is to narrow the scope in which `std::mem::swap` is available, for the "
"sake of being tidy."
msgstr ""
"ちなみに、`mem`スワップを行うコードがブロック内にあるのは、整頓のために`std::"
"mem::swap`が利用できる範囲を狭めるためです。"

#: src/decl-macros/macros-practical.md:542
#, fuzzy
msgid "If we take this code and run it, we get:"
msgstr "このコードを実行すると、次のようになります："

#: src/decl-macros/macros-practical.md:544
#, fuzzy
msgid ""
"```text\n"
"0\n"
"1\n"
"1\n"
"2\n"
"3\n"
"5\n"
"8\n"
"13\n"
"21\n"
"34\n"
"```"
msgstr ""
"テキスト\n"
"0\n"
"1\n"
"1\n"
"2\n"
"3\n"
"5\n"
"8\n"
"13\n"
"21\n"
"34\n"
"```"

#: src/decl-macros/macros-practical.md:557
#, fuzzy
msgid ""
"Success! Now, let's copy & paste this into the macro expansion, and replace "
"the expanded code with an invocation. This gives us:"
msgstr ""
"成功です！では、これをマクロ展開にコピー＆ペーストして、展開されたコードを呼"
"び出しに置き換えてみましょう。これで"

#: src/decl-macros/macros-practical.md:561
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => {\n"
"        {\n"
"            /*\n"
"                What follows here is *literally* the code from before,\n"
"                cut and pasted into a new position. No other changes\n"
"                have been made.\n"
"            */\n"
"\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [u64; 2],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [u64; 2],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = u64;\n"
"\n"
"                fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = u64;\n"
"\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < 2 {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..2).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ...( a[n]: $sty:ty = $($inits:expr),"
"+ , ... , $recur:expr ) =&gt; {\n"
"        {\n"
"            /*\n"
"                ここに続くのは、文字通り*前のコードです、\n"
"                を切り貼りしたものです。それ以外の変更は\n"
"                他の変更はありません。\n"
"            */\n"
"\n"
"            std::ops::Indexを使用してください；\n"
"\n"
"            struct Recurrence {\n"
"                mem：[u64; 2],\n"
"                pos: usize、\n"
"            }\n"
"\n"
"            struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [u64; 2\n"
"                slice: &amp;'a [u64; 2]、\n"
"                offset: usize、\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                型 Output = u64；\n"
"\n"
"                fn index<'b>(&'b self, index: usize) -> &amp;'b u64 {.\n"
"                    use std::num::Wrapping；\n"
"\n"
"                    let index = Wrapping(index)；\n"
"                    let offset = Wrapping(self.offset)；\n"
"                    let window = Wrapping(2)；\n"
"\n"
"                    let real_index = index - offset + window；\n"
"                    &amp;self.slice[real_index.0].\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence { (再帰のイテレータ)\n"
"                型 Item = u64；\n"
"\n"
"                fn next(&amp;mut self) -&gt; オプション<u64> {。\n"
"                    if self.pos &lt; 2 { if self.pos &lt; 2\n"
"                        let next_val = self.mem[self.pos]；\n"
"                        self.pos += 1；\n"
"                        some(next_val)\n"
"                    } else {\n"
"                        let next_val = { {.\n"
"                            let n = self.pos；\n"
"                            let a = IndexOffset { slice: &amp;self.mem, "
"offset: n }；\n"
"                            (a[n-2] + a[n-1]).\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap；\n"
"\n"
"                            mut swap_tmp = next_val；\n"
"                            for i in (0..2).rev() { { {.\n"
"                                swap(&amp;mut swap_tmp, &amp;mut self."
"mem[i])；\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1；\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            再帰 { mem：[0, 1], pos：0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]]；\n"
"\n"
"    for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:640
#, fuzzy
msgid ""
"Obviously, we aren't _using_ the metavariables yet, but we can change that "
"fairly easily. However, if we try to compile this, `rustc` aborts, telling "
"us:"
msgstr ""
"明らかに、まだメタ変数を使っていません。しかし、これをコンパイルしようとする"
"と、`rustc`は中断してしまいます："

#: src/decl-macros/macros-practical.md:643
#, fuzzy
msgid ""
"```text\n"
"error: local ambiguity: multiple parsing options: built-in NTs expr "
"('inits') or 1 other option.\n"
"  --> src/main.rs:75:45\n"
"   |\n"
"75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"   |\n"
"```"
msgstr ""
"テキスト\n"
"error: local ambiguity: multiple parsing options: built-in NTs expr "
"('inits') or 1 other options.\n"
"  --> src/main.rs:75:45\n"
"   |\n"
"75 | let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]]；\n"
"   |\n"
"```"

#: src/decl-macros/macros-practical.md:651
#, fuzzy
msgid ""
"Here, we've run into a limitation of the `macro_rules` system. The problem "
"is that second comma. When it sees it during expansion, `macro_rules` can't "
"decide if it's supposed to parse _another_ expression for `inits`, or `...`. "
"Sadly, it isn't quite clever enough to realise that `...` isn't a valid "
"expression, so it gives up. Theoretically, this _should_ work as desired, "
"but currently doesn't."
msgstr ""
"ここで、`macro_rules`システムの制限に遭遇しました。問題は2つ目のコンマです。"
"これを見たとき、 `macro_rules` は `inits` の式を解析するのか、それとも `...` "
"を解析するのか判断できません。悲しいことに、`...`は有効な式ではないことに気づ"
"くほど賢くないので、諦めてしまいます。理論的には、これは望んだとおりに動作す"
"るはずなのですが、現状ではそうなっていません。"

#: src/decl-macros/macros-practical.md:657
#, fuzzy
msgid ""
"**Aside**: I _did_ fib a little about how our rule would be interpreted by "
"the macro system. In general, it _should_ work as described, but doesn't in "
"this case. The `macro_rules` machinery, as it stands, has its foibles, and "
"its worthwhile remembering that on occasion, you'll need to contort a little "
"to get it to work."
msgstr ""
"**余談**：私は、私たちのルールがマクロシステムによってどのように解釈されるか"
"について、少し嘘をつきました。一般的には、説明したように動作するはずですが、"
"今回はそうではありません。macro_rules`の機械は、現状では欠点があり、時にはそ"
"れを機能させるために少し歪める必要があることを覚えておく価値があります。"

#: src/decl-macros/macros-practical.md:661
#, fuzzy
msgid ""
"In this _particular_ case, there are two issues. First, the macro system "
"doesn't know what does and does not constitute the various grammar elements "
"(_e.g._ an expression); that's the parser's job. As such, it doesn't know "
"that `...` isn't an expression. Secondly, it has no way of trying to capture "
"a compound grammar element (like an expression) without 100% committing to "
"that capture."
msgstr ""
"この特定のケースでは、2 つの問題があります。第一に、マクロシステムは何がさま"
"ざまな文法要素（式など）を構成し、構成しないかを知りません。それはパーサーの"
"仕事です。そのため、`...`が式でないことを知りません。次に、(式のような)複合文"
"法要素を100% c省略することなくキャプチャしようとする方法がありません。"

#: src/decl-macros/macros-practical.md:666
#, fuzzy
msgid ""
"In other words, it can ask the parser to try and parse some input as an "
"expression, but the parser will respond to any problems by aborting. The "
"only way the macro system can currently deal with this is to just try to "
"forbid situations where this could be a problem."
msgstr ""
"つまり、ある入力を式として解析するようにパーサーに要求できますが、パーサーは"
"問題があれば中止して対応します。現在のところ、マクロ システムがこれに対処する"
"唯一の方法は、このような問題が発生する可能性のある状況を禁止することです。"

#: src/decl-macros/macros-practical.md:669
#, fuzzy
msgid ""
"On the bright side, this is a state of affairs that exactly _no one_ is "
"enthusiastic about. The `macro` keyword has already been reserved for a more "
"rigorously-defined future [macro system](https://github.com/rust-lang/rust/"
"issues/39412). Until then, needs must."
msgstr ""
"良い面もありますが、これはまさに_誰も_熱狂していない状態です。macro`キーワー"
"ドは、より厳密に定義された将来の[マクロシステム](https://github.com/rust-"
"lang/rust/issues/39412)のためにすでに予約されています。それまでは、ニーズがな"
"ければなりません。"

#: src/decl-macros/macros-practical.md:673
#, fuzzy
msgid ""
"Thankfully, the fix is relatively simple: we remove the comma from the "
"syntax. To keep things balanced, we'll remove _both_ commas around `...`:"
msgstr ""
"ありがたいことに、修正は比較的簡単です：構文からカンマを取り除くのです。物事"
"のバランスを保つために、`...`を囲むカンマの両方を削除します："

#: src/decl-macros/macros-practical.md:676
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) => {\n"
"//                                     ^~~ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];\n"
"//                                         ^~~ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) => {\n"
"// ^~~変更\n"
"        /* ... */\n"
"# // チート :D\n"
"# (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter().\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]]；\n"
"// ^~~変更\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:694
#, fuzzy
msgid ""
"Success! ... or so we thought. Turns out this is being rejected by the "
"compiler nowadays, while it was fine back when this was written. The reason "
"for this is that the compiler now recognizes the `...` as a token, and as we "
"know we may only use `=>`, `,` or `;` after an expression fragment. So "
"unfortunately we are now out of luck as our dreamed up syntax will not work "
"out this way, so let us just choose one that looks the most befitting that "
"we are allowed to use instead, I'd say replacing `,` with `;` works."
msgstr ""
"成功！...かと思いきや。これが書かれた当時は問題なかったのですが、最近はコンパ"
"イラに拒否されていることがわかりました。その理由は、コンパイラが `...` をトー"
"クンとして認識するようになったからで、ご存知のように、式の断片の後には `=>`, "
"`,` または `;` しか使えません。ですから、私たちが使うことが許されている構文の"
"中で、最も適切と思われるものを選びましょう。"

#: src/decl-macros/macros-practical.md:699
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"//                                     ^~~~~~^ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"//                                        ^~~~~^ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"// ^~~~~^変更\n"
"        /* ... */\n"
"# // チート :D\n"
"# (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]]；\n"
"// ^~~~^変更\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:717
#, fuzzy
msgid "Success! But for real this time."
msgstr "成功！でも、今回は本当に。"

#: src/decl-macros/macros-practical.md:720
#, fuzzy
msgid "Substitution"
msgstr "代替"

#: src/decl-macros/macros-practical.md:722
#, fuzzy
msgid ""
"Substituting something you've captured in a macro is quite simple; you can "
"insert the contents of a metavariable `$sty:ty` by using `$sty`. So, let's "
"go through and fix the `u64`s:"
msgstr ""
"マクロに取り込んだものを代入するのはとても簡単で、`$sty`を使ってメタ変数 "
"`$sty:ty`の内容を挿入することができます。では、`u64`を修正しましょう："

#: src/decl-macros/macros-practical.md:725
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; 2],\n"
"//                    ^~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; 2],\n"
"//                          ^~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"//                            ^~~~ changed\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"//                                                          ^~~~ changed\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"//                          ^~~~ changed\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"//                                           ^~~~ changed\n"
"                    /* ... */\n"
"#                     if self.pos < 2 {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let n = self.pos;\n"
"#                             let a = IndexOffset { slice: &self.mem, "
"offset: n };\n"
"#                             (a[n-2] + a[n-1])\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..2).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; { .\n"
"        {\n"
"            use std::ops::Index；\n"
"\n"
"            struct Recurrence {\n"
"                mem：[$sty; 2]、\n"
"// ^~~~変更\n"
"                pos: usize、\n"
"            }\n"
"\n"
"            struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [$sty; 2\n"
"                slice: &amp;'a [$sty; 2]、\n"
"// ^~~~変更\n"
"                オフセット: usize、\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                タイプ Output = $sty；\n"
"// ^~~~変更\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &amp;'b $sty {.\n"
"// ^~~~変更\n"
"                    std::num::Wrappingを使用します；\n"
"\n"
"                    let index = Wrapping(index)；\n"
"                    let offset = Wrapping(self.offset)；\n"
"                    let window = Wrapping(2)；\n"
"\n"
"                    let real_index = index - offset + window；\n"
"                    &amp;self.slice[real_index.0].\n"
"                }\n"
"            }\n"
"\n"
"            暗黙のイテレータ for Recurrence {\n"
"                型 Item = $sty；\n"
"// ^~~~変更\n"
"\n"
"                #[inline]\n"
"                fn next(&amp;mut self) -&gt; Option<$sty> {.\n"
"// ^~~~変更\n"
"                    /* ... */\n"
"# if self.pos &lt; 2 {.\n"
"# let next_val = self.mem[self.pos]；\n"
"# self.pos += 1；\n"
"# Some(next_val)\n"
"# } else {\n"
"# let next_val = {\n"
"# let n = self.pos；\n"
"# let a = IndexOffset { slice: &amp;self.mem, offset: n }；\n"
"# (a[n-2] + a[n-1])\n"
"# };\n"
"#\n"
"# {\n"
"# use std::mem::swap；\n"
"#\n"
"# let mut swap_tmp = next_val；\n"
"# for i in (0..2).rev() { # swap(&amp;mut swap_tmp).\n"
"# swap(&amp;mut swap_tmp, &amp;mut self.mem[i])；\n"
"# }\n"
"# }\n"
"#\n"
"# self.pos += 1；\n"
"# Some(next_val)\n"
"# }\n"
"                }\n"
"            }\n"
"\n"
"            再帰 { mem：[0, 1], pos：0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]]；\n"
"\n"
"    for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:807
#, fuzzy
msgid ""
"Let's tackle a harder one: how to turn `inits` into both the array literal "
"`[0, 1]` _and_ the array type, `[$sty; 2]`. The first one we can do like so:"
msgstr ""
"より難しいものに挑戦してみましょう： `inits` を配列リテラル `[0, 1]` と配列"
"型 `[$sty; 2]` の両方に変換する方法です。最初のものは次のようにします："

#: src/decl-macros/macros-practical.md:810
#, fuzzy
msgid ""
"```rust,ignore\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"//                             ^~~~~~~~~~~ changed\n"
"```"
msgstr ""
"錆,無視\n"
"            再帰{ mem：[$($inits),+], pos：0 }\n"
"// ^~~~~~~~~変更されました。\n"
"```"

#: src/decl-macros/macros-practical.md:815
#, fuzzy
msgid ""
"This effectively does the opposite of the capture: repeat `inits` one or "
"more times, separating each with a comma. This expands to the expected "
"sequence of tokens: `0, 1`."
msgstr ""
"これはキャプチャの逆で、カンマで区切って `inits` を1回以上繰り返します。これ"
"は期待されるトークンの並びである `0, 1` に展開されます。"

#: src/decl-macros/macros-practical.md:818
#, fuzzy
msgid ""
"Somehow turning `inits` into a literal `2` is a little trickier. It turns "
"out that there's no direct way to do this, but we _can_ do it by using a "
"second `macro_rules!` macro. Let's take this one step at a time."
msgstr ""
"どうにかして `inits` をリテラルで `2` にするのは少し厄介です。これを行う直接"
"的な方法はありませんが、2つ目の `macro_rules!` マクロを使用することで行うこと"
"ができます。一歩ずつやってみましょう。"

#: src/decl-macros/macros-practical.md:822
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    /* ??? */\n"
"#     () => {}\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール!\n"
"    /* ??? */\n"
"# () => {}\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/macros-practical.md:830
#, fuzzy
msgid ""
"The obvious case is: given zero expressions, you would expect `count_exprs` "
"to expand to a literal `0`."
msgstr ""
"明らかなケースは、ゼロの式が与えられた場合、 `count_exprs` がリテラル `0` に"
"展開されることを期待する場合です。"

#: src/decl-macros/macros-practical.md:833
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"//  ^~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     assert_eq!(_0, 0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"// ^~~~~~~~~追加\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!\n"
"# assert_eq!(_0, 0)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:844
#, fuzzy
msgid ""
"**Aside**: You may have noticed I used parentheses here instead of curly "
"braces for the expansion. `macro_rules` really doesn't care _what_ you use, "
"so long as it's one of the \"matcher\" pairs: `( )`, `{ }` or `[ ]`. In "
"fact, you can switch out the matchers on the macro itself(_i.e._ the "
"matchers right after the macro name), the matchers around the syntax rule, "
"and the matchers around the corresponding expansion."
msgstr ""
"**余談**：中括弧の代わりに括弧を使っていることにお気づきでしょうか。"
"macro_rules` は、`( )`, `{ }`, `[ ]` というマッチャーのペアのどれかであれば、"
"何を使ってもかまいません。実際、マクロ自体のマッチャー(マクロ名の直後のマッ"
"チャー)、構文規則の周りのマッチャー、対応する展開の周りのマッチャーを入れ替え"
"ることができます。"

#: src/decl-macros/macros-practical.md:848
#, fuzzy
msgid ""
"You can also switch out the matchers used when you _invoke_ a macro, but in "
"a more limited fashion: a macro invoked as `{ ... }` or `( ... );` will "
"_always_ be parsed as an _item_ (_i.e._ like a `struct` or `fn` "
"declaration). This is important when using macros in a function body; it "
"helps disambiguate between \"parse like an expression\" and \"parse like a "
"statement\"."
msgstr ""
"マクロを呼び出すときに使用するマッチャを切り替えることもできますが、より限定"
"的です。}` または `( ... );` として呼び出されたマクロは、常に_アイテムとして"
"解析されます（つまり、 `struct` や `fn` 宣言のように）。これは、関数本体でマ"
"クロを使用する場合に重要です。「式のようにパースする」と「文のようにパースす"
"る」を区別するのに役立ちます。"

#: src/decl-macros/macros-practical.md:851
#, fuzzy
msgid "What if you have _one_ expression? That should be a literal `1`."
msgstr "もし_one_式があったら？それはリテラル `1` であるべきです。"

#: src/decl-macros/macros-practical.md:854
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"//  ^~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1)；\n"
"// ^~~~~~~~~~追加\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!()；\n"
"# const _1: usize = count_exprs!(x)；\n"
"# assert_eq!(_0, 0)；\n"
"# assert_eq!(_1, 1)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:868
#, fuzzy
msgid "Two?"
msgstr "このAPIは2つの型を定義しています： `DBM` と `datum` です。"

#: src/decl-macros/macros-practical.md:870
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (2);\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1)；\n"
"    ($e0:expr, $e1:expr) => (2)；\n"
"// ^~~~~~~~~~~~~~~~~~~追加\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!()；\n"
"# const _1: usize = count_exprs!(x)；\n"
"# const _2: usize = count_exprs!(x, y)；\n"
"# assert_eq!(_0, 0)；\n"
"# assert_eq!(_1, 1)；\n"
"# assert_eq!(_2, 2)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:887
#, fuzzy
msgid ""
"We can \"simplify\" this a little by re-expressing the case of two "
"expressions recursively."
msgstr ""
"2つの式の場合を再帰的に再表現することで、これを少し「単純化」することができま"
"す。"

#: src/decl-macros/macros-practical.md:889
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"//                           ^~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1)；\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1))；\n"
"// ^~~~~~~~~~~~~変更\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!\n"
"# const _1: usize = count_exprs!(x)；\n"
"# const _2: usize = count_exprs!(x, y)；\n"
"# assert_eq!(_0, 0)；\n"
"# assert_eq!(_1, 1)；\n"
"# assert_eq!(_2, 2)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:906
#, fuzzy
msgid ""
"This is fine since Rust can fold `1 + 1` into a constant value. What if we "
"have three expressions?"
msgstr ""
"Rust は `1 + 1` を定数値に折りたたむことができるので、これは問題ありません。3"
"つの式がある場合はどうでしょうか？"

#: src/decl-macros/macros-practical.md:909
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"    ($e0:expr, $e1:expr, $e2:expr) => (1 + count_exprs!($e1, $e2));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1)；\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1))；\n"
"    ($e0:expr, $e1:expr, $e2:expr) => (1 + count_exprs!($e1, $e2))；\n"
"\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!()；\n"
"# const _1: usize = count_exprs!(x)；\n"
"# const _2: usize = count_exprs!(x, y)；\n"
"# const _3: usize = count_exprs!(x, y, z)；\n"
"# assert_eq!(_0, 0)；\n"
"# assert_eq!(_1, 1)；\n"
"# assert_eq!(_2, 2)；\n"
"# assert_eq!(_3, 3)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:929
#, fuzzy
msgid ""
"**Aside**: You might be wondering if we could reverse the order of these "
"rules. In this particular case, _yes_, but the macro system can sometimes be "
"picky about what it is and is not willing to recover from. If you ever find "
"yourself with a multi-rule macro that you _swear_ should work, but gives you "
"errors about unexpected tokens, try changing the order of the rules."
msgstr ""
"**余談**：これらのルールの順番を逆にできないかと思うかもしれません。しかし、"
"マクロのシステムは時々、回復するものと回復しないものにうるさいことがありま"
"す。もし、複数のルールがあるマクロが動作するはずなのに、予期しないトークンに"
"関するエラーが発生する場合は、ルールの順序を変更してみてください。"

#: src/decl-macros/macros-practical.md:933
#, fuzzy
msgid ""
"Hopefully, you can see the pattern here. We can always reduce the list of "
"expressions by matching one expression, followed by zero or more "
"expressions, expanding that into 1 + a count."
msgstr ""
"うまくいけば、ここでパターンを見ることができます。つの式にマッチし、その後に0"
"個以上の式が続き、それを1＋カウントに展開することで、いつでも式のリストを減ら"
"すことができます。"

#: src/decl-macros/macros-practical.md:936
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ "
"changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1)；\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*))；\n"
"// ^～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～"
"～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～"
"～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～変更\n"
"}\n"
"# fn main() {\n"
"# const _0: usize = count_exprs!()；\n"
"# const _1: usize = count_exprs!(x)；\n"
"# const _2: usize = count_exprs!(x, y)；\n"
"# const _3: usize = count_exprs!(x, y, z)；\n"
"# assert_eq!(_0, 0)；\n"
"# assert_eq!(_1, 1)；\n"
"# assert_eq!(_2, 2)；\n"
"# assert_eq!(_3, 3)；\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid "**"
msgstr "**"

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
#, fuzzy
msgid "JFTE"
msgstr "日本貿易会"

#: src/decl-macros/macros-practical.md:955
#, fuzzy
msgid ""
"**: this is not the _only_, or even the _best_ way of counting things. You "
"may wish to peruse the [Counting](./building-blocks/counting.md) section "
"later for a more efficient way."
msgstr ""
"**: これが唯一の、あるいは最良の数え方というわけではありません。より効率的な"
"方法については、後で[Counting](./building-blocks/counting.md)のセクションを熟"
"読してください。"

#: src/decl-macros/macros-practical.md:958
#, fuzzy
msgid ""
"With this, we can now modify `recurrence` to determine the necessary size of "
"`mem`."
msgstr ""
"これで、必要な `mem` のサイズを決定するために `recurrence` を修正することがで"
"きます。"

#: src/decl-macros/macros-practical.md:960
#, fuzzy
msgid ""
"```rust\n"
"// added:\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"//                          ^~~~~~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"//                                ^~~~~~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"//                                        ^~~~~~~~ changed\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"//                                ^~~~~~~~ changed\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"//                                       ^~~~~~~~ changed\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"/* ... */\n"
"#\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"#\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"// を追加しました：\n"
"macro_rules!\n"
"    () =&gt; (0);\n"
"    ($head:expr) =&gt; (1)；\n"
"    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*))；\n"
"}\n"
"\n"
"macro_rules!\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {\n"
"        {\n"
"            use std::ops::Index；\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+)；\n"
"// 追加\n"
"\n"
"            構造体 Recurrence {\n"
"                mem：[$sty; MEM_SIZE]を追加しました、\n"
"// ^~~~~~~~変更\n"
"                pos: usize、\n"
"            }\n"
"\n"
"            struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [$sty; "
"MEM_SIZE\n"
"                slice: &amp;'a [$sty; MEM_SIZE]、\n"
"// 変更されました。\n"
"                オフセット: usize、\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                タイプ Output = $sty；\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &amp;'b $sty {.\n"
"                    std::num::Wrappingを使用します；\n"
"\n"
"                    let index = Wrapping(index)；\n"
"                    let offset = Wrapping(self.offset)；\n"
"                    let window = Wrapping(MEM_SIZE)；\n"
"// ^~~~~~~変更\n"
"\n"
"                    let real_index = index - offset + window；\n"
"                    &amp;self.slice[real_index.0].\n"
"                }\n"
"            }\n"
"\n"
"            暗黙のイテレータ for Recurrence {\n"
"                型 Item = $sty；\n"
"\n"
"                #[inline］\n"
"                fn next(&amp;mut self) -&gt; オプション<$sty> {。\n"
"                    if self.pos &lt; MEM_SIZE { {.\n"
"// ^~~~~~変更\n"
"                        let next_val = self.mem[self.pos]；\n"
"                        self.pos += 1；\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = { 次の値\n"
"                            let n = self.pos；\n"
"                            let a = IndexOffset { slice: &amp;self.mem, "
"offset: n }；\n"
"                            (a[n-2] + a[n-1]).\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap；\n"
"\n"
"                            mut swap_tmp = next_val；\n"
"                            for i in (0..MEM_SIZE).rev() { // ^~~~~~~変更され"
"ました。\n"
"// ^~~~~~~変更\n"
"                                swap(&amp;mut swap_tmp, &amp;mut self."
"mem[i])；\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1；\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            再帰 { mem：[$($inits),+], pos：0 }\n"
"        }\n"
"    };\n"
"}\n"
"/* ... */\n"
"#\n"
"# fn main() {\n"
"# let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]]；\n"
"#\n"
"# for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1051
#, fuzzy
msgid ""
"With that done, we can now substitute the last thing: the `recur` expression."
msgstr "これで最後に、`recur`式を代入することができます。"

#: src/decl-macros/macros-practical.md:1053
#, fuzzy
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr $(, $tail:expr)*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"# macro_rules! recurrence {\n"
"#     ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#             impl Iterator for Recurrence {\n"
"#               type Item = $sty;\n"
"/* ... */\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            $recur\n"
"//                          ^~~~~~ changed\n"
"                        };\n"
"                        {\n"
"                            use std::mem::swap;\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"/* ... */\n"
"#             }\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ # count_exprs {\n"
"# () =&gt; (0);\n"
"# ($head:expr $(, $tail:expr)*) =&gt; (1 + count_exprs!($($tail),*))；\n"
"# }\n"
"# マクロルール！再帰 {\n"
"# ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {.\n"
"# {\n"
"# std::ops::Index を使用します；\n"
"#\n"
"# const MEM_SIZE: usize = count_exprs!($($inits),+)；\n"
"# struct Recurrence {\n"
"# mem：[$sty; MEM_SIZE]、\n"
"# pos: usize、\n"
"# }\n"
"構造体IndexOffset&lt;'a&gt; { # スライス: &amp;'a [$sty; MEM_SIZE\n"
"# slice: &amp;'a [$sty; MEM_SIZE]、\n"
"# offset: usize、\n"
"# }\n"
"# impl<'a> Index<usize> for IndexOffset<'a> {\n"
"# 型 Output = $sty；\n"
"#\n"
"#[inline(always)]\n"
"# fn インデックス<'b>(&'b self, index: usize) -> &amp;'b $sty {\n"
"# use std::num::Wrapping；\n"
"#\n"
"# let index = Wrapping(index)；\n"
"# let offset = Wrapping(self.offset)；\n"
"# let window = Wrapping(MEM_SIZE)；\n"
"#\n"
"# let real_index = index - offset + window；\n"
"# &amp;self.slice[real_index.0].\n"
"# }\n"
"# }\n"
"# impl イテレータ for Recurrence {\n"
"# 型 Item = $sty；\n"
"/* ... */\n"
"                #[inline］\n"
"                fn next(&amp;mut self) -&gt; Option<u64> {.\n"
"                    if self.pos &lt; MEM_SIZE { 次の値を返します。\n"
"                        let next_val = self.mem[self.pos]；\n"
"                        self.pos += 1；\n"
"                        some(next_val)\n"
"                    } else {\n"
"                        let next_val = { 次の値\n"
"                            let n = self.pos；\n"
"                            let a = IndexOffset { slice: &amp;self.mem, "
"offset: n }；\n"
"                            $recur\n"
"// ^~~~~変更\n"
"                        };\n"
"                        {\n"
"                            std::mem::swapを使います；\n"
"                            mut swap_tmp = next_val；\n"
"                            for i in (0..MEM_SIZE).rev() { { { swap(&amp;mut "
"swap_tmp).\n"
"                                swap(&amp;mut swap_tmp, &amp;mut self."
"mem[i])；\n"
"                            }\n"
"                        }\n"
"                        self.pos += 1；\n"
"                        some(next_val)\n"
"                    }\n"
"                }\n"
"/* ... */\n"
"# }\n"
"# 再帰 { mem：[$($inits),+], pos：0 }\n"
"# }\n"
"# };\n"
"# }\n"
"# fn main() {\n"
"# let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]]；\n"
"# for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1126
#, fuzzy
msgid "And, when we compile our finished `macro_rules!` macro..."
msgstr "そして、完成した `macro_rules!` マクロをコンパイルすると...。"

#: src/decl-macros/macros-practical.md:1128
#, fuzzy
msgid ""
"```text\n"
"error[E0425]: cannot find value `a` in this scope\n"
"  --> src/main.rs:68:50\n"
"   |\n"
"68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"   |                                                  ^ not found in this "
"scope\n"
"\n"
"error[E0425]: cannot find value `n` in this scope\n"
"  --> src/main.rs:68:52\n"
"   |\n"
"68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"   |                                                    ^ not found in this "
"scope\n"
"\n"
"error[E0425]: cannot find value `a` in this scope\n"
"  --> src/main.rs:68:59\n"
"   |\n"
"68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"   |                                                           ^ not found "
"in this scope\n"
"\n"
"error[E0425]: cannot find value `n` in this scope\n"
"  --> src/main.rs:68:61\n"
"   |\n"
"68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"   |                                                             ^ not found "
"in this scope\n"
"```"
msgstr ""
"テキスト\n"
"error[E0425]: このスコープで値 `a` が見つかりません。\n"
"  --> src/main.rs:68:50\n"
"   |\n"
"68 | let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]]；\n"
"   | このスコープでは見つかりません。\n"
"\n"
"error[E0425]: このスコープで値 `n` が見つかりません。\n"
"  --> src/main.rs:68:52\n"
"   |\n"
"68 | let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]]；\n"
"   | このスコープでは見つかりません。\n"
"\n"
"error[E0425]: このスコープで値 `a` が見つかりません。\n"
"  --> src/main.rs:68:59\n"
"   |\n"
"68 | let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]]；\n"
"   | このスコープでは見つかりません。\n"
"\n"
"error[E0425]: このスコープで値 `n` が見つかりません。\n"
"  --> src/main.rs:68:61\n"
"   |\n"
"68 | let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]]；\n"
"   | このスコープでは見つかりません。\n"
"```"

#: src/decl-macros/macros-practical.md:1154
#, fuzzy
msgid ""
"... wait, what? That can't be right... let's check what the macro is "
"expanding to."
msgstr "...待って、何？マクロの展開先を確認してみましょう。"

#: src/decl-macros/macros-practical.md:1157
#, fuzzy
msgid ""
"```shell\n"
"$ rustc +nightly -Zunpretty=expanded recurrence.rs\n"
"```"
msgstr ""
"シェル\n"
"$ rustc +nightly -Zunpretty=expanded recurrence.rs\n"
"```"

#: src/decl-macros/macros-practical.md:1161
#, fuzzy
msgid ""
"The `-Zunpretty=expanded` argument tells `rustc` to perform macro expansion, "
"then turn the resulting AST back into source code. The output (after "
"cleaning up some formatting) is shown below; in particular, note the place "
"in the code where `$recur` was substituted:"
msgstr ""
"引数の `-Zunpretty=expanded` は `rustc` にマクロ展開を実行させ、その結果の "
"AST をソースコードに戻します。特に、`$recur`が代入されている箇所に注意してく"
"ださい："

#: src/decl-macros/macros-practical.md:1165
#, fuzzy
msgid ""
"```rust,ignore\n"
"#![feature(no_std)]\n"
"#![no_std]\n"
"#[prelude_import]\n"
"use std::prelude::v1::*;\n"
"#[macro_use]\n"
"extern crate std as std;\n"
"fn main() {\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"        const MEM_SIZE: usize = 1 + 1;\n"
"        struct Recurrence {\n"
"            mem: [u64; MEM_SIZE],\n"
"            pos: usize,\n"
"        }\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; MEM_SIZE],\n"
"            offset: usize,\n"
"        }\n"
"        impl <'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(MEM_SIZE);\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < MEM_SIZE {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset{slice: &self.mem, offset: n,};\n"
"                        a[n - 1] + a[n - 2]\n"
"                    };\n"
"                    {\n"
"                        use std::mem::swap;\n"
"                        let mut swap_tmp = next_val;\n"
"                        {\n"
"                            let result =\n"
"                                match ::std::iter::IntoIterator::"
"into_iter((0..MEM_SIZE).rev()) {\n"
"                                    mut iter => loop {\n"
"                                        match ::std::iter::Iterator::"
"next(&mut iter) {\n"
"                                            ::std::option::Option::Some(i) "
"=> {\n"
"                                                swap(&mut swap_tmp, &mut "
"self.mem[i]);\n"
"                                            }\n"
"                                            ::std::option::Option::None => "
"break,\n"
"                                        }\n"
"                                    },\n"
"                                };\n"
"                            result\n"
"                        }\n"
"                    }\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"        Recurrence{mem: [0, 1], pos: 0,}\n"
"    };\n"
"    {\n"
"        let result =\n"
"            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {\n"
"                mut iter => loop {\n"
"                    match ::std::iter::Iterator::next(&mut iter) {\n"
"                        ::std::option::Option::Some(e) => {\n"
"                            ::std::io::_print(::std::fmt::Arguments::"
"new_v1(\n"
"                                {\n"
"                                    static __STATIC_FMTSTR: &'static "
"[&'static str] = &[\"\", \"\\n\"];\n"
"                                    __STATIC_FMTSTR\n"
"                                },\n"
"                                &match (&e,) {\n"
"                                    (__arg0,) => [::std::fmt::ArgumentV1::"
"new(__arg0, ::std::fmt::Display::fmt)],\n"
"                                }\n"
"                            ))\n"
"                        }\n"
"                        ::std::option::Option::None => break,\n"
"                    }\n"
"                },\n"
"            };\n"
"        result\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"#![feature(no_std)]\n"
"#![no_std]\n"
"#[prelude_import]\n"
"use std::prelude::v1::*；\n"
"マクロ使用] #[macro_use\n"
"extern crate std as std；\n"
"fn main() {\n"
"    let fib = {\n"
"        use std::ops::Index；\n"
"        const MEM_SIZE: usize = 1 + 1；\n"
"        構造体リカレンス {\n"
"            mem：[u64; MEM_SIZE]、\n"
"            pos: usize、\n"
"        }\n"
"        struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [u64; MEM_SIZE\n"
"            slice: &amp;'a [u64; MEM_SIZE]、\n"
"            offset: usize、\n"
"        }\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            型 Output = u64；\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &amp;'b u64 {.\n"
"                use std::num::Wrapping；\n"
"                let index = Wrapping(index)；\n"
"                let offset = Wrapping(self.offset)；\n"
"                let window = Wrapping(MEM_SIZE)；\n"
"                let real_index = index - offset + window；\n"
"                &amp;self.slice[real_index.0].\n"
"            }\n"
"        }\n"
"        impl Iterator for Recurrence { (再帰のイテレータ)\n"
"            型 Item = u64；\n"
"            #[inline］\n"
"            fn next(&amp;mut self) -&gt; Option<u64> {.\n"
"                if self.pos< MEM_SIZE {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset{slice: &self.mem, offset: n,};\n"
"                        a[n - 1] + a[n - 2]\n"
"                    };\n"
"                    {\n"
"                        use std::mem::swap;\n"
"                        let mut swap_tmp = next_val;\n"
"                        {\n"
"                            let result =\n"
"                                match ::std::iter::IntoIterator::"
"into_iter((0..MEM_SIZE).rev()) {\n"
"                                    mut iter => ループ {.\n"
"                                        match ::std::iter::Iterator::"
"next(&amp;mut iter) {\n"
"                                            ::std::option::Option::Some(i) "
"=&gt; { { { swap(&amp;mut swap)\n"
"                                                swap(&amp;mut swap_tmp, &amp;"
"mut self.mem[i])；\n"
"                                            }\n"
"                                            ::std::option::Option::None "
"=&gt; break、\n"
"                                        }\n"
"                                    },\n"
"                                };\n"
"                            結果\n"
"                        }\n"
"                    }\n"
"                    self.pos += 1；\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"        再帰{mem：[0, 1], pos：0,}\n"
"    };\n"
"    {\n"
"        let result =\n"
"            match ::std::iter::IntoIterator::into_iter(fib.take(10)) { { }.\n"
"                mut iter =&gt; loop { {.\n"
"                    match ::std::iter::Iterator::next(&amp;mut iter) { }.\n"
"                        ::std::option::Option::Some(e) =&gt; { { { { {\n"
"                            ::std::io::_print(::std::fmt::Arguments::"
"new_v1()\n"
"                                {\n"
"                                    static __STATIC_FMTSTR: &amp;'static "
"[&amp;'static str] = &amp;[\"\", \"∕n\"]；\n"
"                                    static_fmtstr\n"
"                                },\n"
"                                マッチ\n"
"                                    (__arg0,) =&gt; [::std::fmt::ArgumentV1::"
"new(__arg0, ::std::fmt::Display::fmt)]、\n"
"                                }\n"
"                            ))\n"
"                        }\n"
"                        ::std::option::Option::None =&gt; break、\n"
"                    }\n"
"                },\n"
"            };\n"
"        結果\n"
"    }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:1260
#, fuzzy
msgid ""
"But that looks fine! If we add a few missing `#![feature(...)]` attributes "
"and feed it to a nightly build of `rustc`, it even compiles!  ... _what?!_"
msgstr ""
"しかし、これは問題なさそうです！いくつか欠けている `#![feature(...)]` 属性を"
"追加して `rustc` のナイトリービルドに渡すと、コンパイルもできます！  ...何だ"
"と？"

#: src/decl-macros/macros-practical.md:1263
#, fuzzy
msgid ""
"**Aside**: You can't compile the above with a non-nightly build of `rustc`. "
"This is because the expansion of the `println!` macro depends on internal "
"compiler details which are _not_ publicly stabilized."
msgstr ""
"**余談**：rustc`のnightlyでないビルドでは上記をコンパイルできません。これは "
"`println!` マクロの展開がコンパイラ内部の詳細に依存しているためです。"

#: src/decl-macros/macros-practical.md:1266
#, fuzzy
msgid "Being Hygienic"
msgstr "衛生的であること"

#: src/decl-macros/macros-practical.md:1268
#, fuzzy
msgid ""
"The issue here is that identifiers in Rust syntax extensions are _hygienic_. "
"That is, identifiers from two different contexts _cannot_ collide. To show "
"the difference, let's take a simpler example."
msgstr ""
"ここで問題になるのは、Rustの構文拡張の識別子は「衛生的」であるということで"
"す。つまり、2つの異なるコンテキストの識別子が衝突することはありません。この違"
"いを示すために、もっと簡単な例を見てみましょう。"

#: src/decl-macros/macros-practical.md:1272
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! using_a {\n"
"    ($e:expr) => {\n"
"        {\n"
"            let a = 42;\n"
"            $e\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"let four = using_a!(a / 10);\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    ($e:expr) => { です。\n"
"        {\n"
"            let a = 42；\n"
"            $e\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"let four = using_a!(a / 10)；\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/macros-practical.md:1286
#, fuzzy
msgid ""
"This macro simply takes an expression, then wraps it in a block with a "
"variable `a` defined. We then use this as a round-about way of computing "
"`4`. There are actually _two_ syntax contexts involved in this example, but "
"they're invisible. So, to help with this, let's give each context a "
"different colour. Let's start with the unexpanded code, where there is only "
"a single context:"
msgstr ""
"このマクロは単純に式を受け取り、変数 `a` を定義したブロックで囲みます。そして"
"これを `4` を計算する遠回りの方法として使います。この例には実際には2つの構文"
"コンテキストがありますが、それらは見えません。そこで、それぞれのコンテキスト"
"に違う色をつけてみましょう。まず、コンテキストが1つしかない、展開されていない"
"コードから始めましょう："

#: src/decl-macros/macros-practical.md:1294
#, fuzzy
msgid "Now, let's expand the invocation."
msgstr "では、呼び出しを拡大してみましょう。"

#: src/decl-macros/macros-practical.md:1298
#, fuzzy
msgid "As you can see, the "
msgstr "ご覧のように"

#: src/decl-macros/macros-practical.md:1298
#: src/decl-macros/minutiae/hygiene.md:33
msgid "a"
msgstr "a"

#: src/decl-macros/macros-practical.md:1298
#, fuzzy
msgid ""
" that's defined by the macro invocation is in a different context to the "
msgstr "マクロの呼び出しによって定義されたコンテキストは"

#: src/decl-macros/macros-practical.md:1298
#, fuzzy
msgid ""
" we provided in our invocation. As such, the compiler treats them as "
"completely different identifiers, _even though they have the same lexical "
"appearance_."
msgstr ""
"を呼び出します。そのため、コンパイラはこれらをまったく別の識別子として扱いま"
"す。"

#: src/decl-macros/macros-practical.md:1301
#, fuzzy
msgid ""
"This is something to be _really_ careful of when working on `macro_rules!` "
"macros, syntax extensions in general even: they can produce ASTs which will "
"not compile, but which _will_ compile if written out by hand, or dumped "
"using `-Zunpretty=expanded`."
msgstr ""
"これは、`macro_rules!`マクロや構文拡張全般を扱うときに_本当に_注意しなければ"
"ならないことです：これらはコンパイルできないASTを生成することができますが、手"
"で書き出したり、`-Zunpretty=expanded`を使ってダンプすれば_コンパイルできま"
"す。"

#: src/decl-macros/macros-practical.md:1304
#, fuzzy
msgid ""
"The solution to this is to capture the identifier _with the appropriate "
"syntax context_. To do that, we need to again adjust our macro syntax. To "
"continue with our simpler example:"
msgstr ""
"これを解決するには、識別子を適切な構文コンテキストでキャプチャします。そのた"
"めには、マクロ構文を調整する必要があります。もっと簡単な例を続けます："

#: src/decl-macros/macros-practical.md:1310
#, fuzzy
msgid "This now expands to:"
msgstr "これは現在、次のように拡大しています："

#: src/decl-macros/macros-practical.md:1314
#, fuzzy
msgid ""
"Now, the contexts match, and the code will compile. We can make this "
"adjustment to our `recurrence!` macro by explicitly capturing `a` and `n`. "
"After making the necessary changes, we have:"
msgstr ""
"これでコンテキストが一致し、コードがコンパイルされます。a` と `n` を明示的に"
"キャプチャすることで、`recurrence!必要な変更を行うと、次のようになります："

#: src/decl-macros/macros-practical.md:1318
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"//    ^~~~~~~~~~   ^~~~~~~~~~ changed\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let $ind = self.pos;\n"
"//                              ^~~~ changed\n"
"                            let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"//                              ^~~~ changed\n"
"                            $recur\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_exprs {\n"
"    () =&gt; (0);\n"
"    ($head:expr) =&gt; (1)；\n"
"    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*))；\n"
"}\n"
"\n"
"macro_rules!\n"
"    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) =&gt; { .\n"
"// ^~~~~~ ^~~~~ ~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 変更\n"
"        {\n"
"            std::ops::Indexを使用します；\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+)；\n"
"\n"
"            struct Recurrence {\n"
"                mem：[$sty; MEM_SIZE]、\n"
"                pos: usize、\n"
"            }\n"
"\n"
"            struct IndexOffset&lt;'a&gt; { スライス: &amp;'a [$sty; "
"MEM_SIZE\n"
"                slice: &amp;'a [$sty; MEM_SIZE]、\n"
"                オフセット: usize、\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                型 Output = $sty；\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &amp;'b $sty {.\n"
"                    std::num::Wrappingを使用します；\n"
"\n"
"                    let index = Wrapping(index)；\n"
"                    let offset = Wrapping(self.offset)；\n"
"                    let window = Wrapping(MEM_SIZE)；\n"
"\n"
"                    let real_index = index - offset + window；\n"
"                    &amp;self.slice[real_index.0].\n"
"                }\n"
"            }\n"
"\n"
"            暗黙のイテレータ for Recurrence {\n"
"                型 Item = $sty；\n"
"\n"
"                #[inline］\n"
"                fn next(&amp;mut self) -&gt; オプション<$sty> {。\n"
"                    if self.pos &lt; MEM_SIZE { if self.pos &lt; MEM_SIZE "
"{ if self.pos &lt; MEM_SIZE\n"
"                        let next_val = self.mem[self.pos]；\n"
"                        self.pos += 1；\n"
"                        some(next_val)\n"
"                    } else {\n"
"                        let next_val = { { $ind = self.pos; let $ind = self."
"pos; let $ind = self.pos\n"
"                            let $ind = self.pos；\n"
"// ^~~~変更\n"
"                            let $seq = IndexOffset { slice: &amp;self.mem, "
"offset: $ind }；\n"
"// ^~~~変更\n"
"                            $recur\n"
"                        };\n"
"\n"
"                        {\n"
"                            std::mem::swapを使用します；\n"
"\n"
"                            mut swap_tmp = next_val；\n"
"                            for i in (0..MEM_SIZE).rev() { { swap(&amp;mut "
"swap_tmp).\n"
"                                swap(&amp;mut swap_tmp, &amp;mut self."
"mem[i])；\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1；\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            再帰 { mem：[$($inits),+], pos：0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]]；\n"
"\n"
"    for e in fib.take(10) { println!(\"&lt;0/&gt;\", e) }.\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:1404
#, fuzzy
msgid "And it compiles! Now, let's try with a different sequence."
msgstr "そしてコンパイルされます！では、別のシーケンスで試してみましょう。"

#: src/decl-macros/macros-practical.md:1407
#, fuzzy
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr) => (1);\n"
"#     ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"#\n"
"# macro_rules! recurrence {\n"
"#     ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             impl Iterator for Recurrence {\n"
"#                 type Item = $sty;\n"
"#\n"
"#                 #[inline]\n"
"#                 fn next(&mut self) -> Option<$sty> {\n"
"#                     if self.pos < MEM_SIZE {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let $ind = self.pos;\n"
"#                             let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"#                             $recur\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..MEM_SIZE).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"#\n"
"# fn main() {\n"
"for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {\n"
"    println!(\"{}\", e)\n"
"}\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ # count_exprs {\n"
"# () =&gt; (0);\n"
"# ($head:expr) =&gt; (1)；\n"
"# ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*))；\n"
"# }\n"
"#\n"
"マクロ規則！再帰 { # ( $seq:ident [($tail:expr)])\n"
"# ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) =&gt; { .\n"
"# {\n"
"# use std::ops::Index；\n"
"#\n"
"# const MEM_SIZE: usize = count_exprs!($($inits),+)；\n"
"#\n"
"# struct Recurrence {\n"
"# mem：[$sty; MEM_SIZE]、\n"
"# pos: usize、\n"
"# }\n"
"#\n"
"# struct IndexOffset&lt;'a&gt; {\n"
"# スライス: &amp;'a [$sty; MEM_SIZE]、\n"
"# offset: usize、\n"
"# }\n"
"#\n"
"# impl<'a> Index<usize> for IndexOffset<'a> {\n"
"# タイプ Output = $sty；\n"
"#\n"
"# #[inline(always)]\n"
"# fn index<'b>(&'b self, index: usize) -> &amp;'b $sty {\n"
"# use std::num::Wrapping；\n"
"#\n"
"# let index = Wrapping(index)；\n"
"# let offset = Wrapping(self.offset)；\n"
"# let window = Wrapping(MEM_SIZE)；\n"
"#\n"
"# let real_index = index - offset + window；\n"
"# &amp;self.slice[real_index.0].\n"
"# }\n"
"# }\n"
"#\n"
"# impl Iterator for Recurrence {\n"
"# 型 Item = $sty；\n"
"#\n"
"# #[inline]\n"
"# fn next(&amp;mut self) -&gt; Option<$sty> {.\n"
"# もしself.pos &lt; MEM_SIZE {なら\n"
"# let next_val = self.mem[self.pos]；\n"
"# self.pos += 1；\n"
"# Some(next_val)\n"
"# } else {\n"
"# let next_val = {\n"
"# let $ind = self.pos；\n"
"# let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind }；\n"
"# $recur\n"
"# };\n"
"#\n"
"# {\n"
"# use std::mem::swap；\n"
"#\n"
"# let mut swap_tmp = next_val；\n"
"# for i in (0..MEM_SIZE).rev() { # swap(&amp;mut swap_tmp).\n"
"# swap(&amp;mut swap_tmp, &amp;mut self.mem[i])；\n"
"# }\n"
"# }\n"
"#\n"
"# self.pos += 1；\n"
"# Some(next_val)\n"
"# }\n"
"# }\n"
"# }\n"
"#\n"
"# 再帰 { mem：[$($inits),+], pos：0 }\n"
"# }\n"
"# };\n"
"# }\n"
"#\n"
"# fn main() {\n"
"for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {.\n"
"    println!(\"&lt;0/&gt;\", e)\n"
"}\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1490
#, fuzzy
msgid "Which gives us:"
msgstr "ということです："

#: src/decl-macros/macros-practical.md:1492
#, fuzzy
msgid ""
"```text\n"
"1\n"
"1\n"
"2\n"
"6\n"
"24\n"
"120\n"
"720\n"
"5040\n"
"40320\n"
"362880\n"
"```"
msgstr ""
"テキスト\n"
"1\n"
"1\n"
"2\n"
"6\n"
"24\n"
"120\n"
"720\n"
"5040\n"
"40320\n"
"362880\n"
"```"

#: src/decl-macros/macros-practical.md:1505
#, fuzzy
msgid "Success!"
msgstr "成功！"

#: src/decl-macros/minutiae.md:3
#, fuzzy
msgid ""
"This section goes through some of the finer details of the `macro_rules!` "
"system. At a minimum, you should try to be at least _aware_ of these details "
"and issues."
msgstr ""
"このセクションでは`macro_rules!最低限、これらの詳細や問題点については知ってお"
"くようにしてください。"

#: src/decl-macros/minutiae/fragment-specifiers.md:3
#, fuzzy
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md) "
"chapter, Rust, as of 1.60, has 14 fragment specifiers. This section will go "
"a bit more into detail for some of them and shows a few example inputs of "
"what each matcher matches."
msgstr ""
"メソッド紹介`](../macros-methodical.md)の章で述べたように、Rust 1.60では14個"
"のフラグメント指定子があります。このセクションでは、そのうちのいくつかについ"
"てもう少し詳しく説明し、各マッチャーがマッチする入力例をいくつか示します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:6
#, fuzzy
msgid ""
"**Note**: Capturing with anything but the `ident`, `lifetime` and `tt` "
"fragments will render the captured AST opaque, making it impossible to "
"further match it with other fragment specifiers in future macro invocations."
msgstr ""
"**注意**：ident`、`lifetime`、`tt`以外のフラグメントでキャプチャすると、キャ"
"プチャした AST が不透明になり、今後マクロを呼び出す際に他のフラグメント指定子"
"とマッチさせることができなくなります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:8
#, fuzzy
msgid "[`block`](#block)"
msgstr "[ブロック`](#ブロック)"

#: src/decl-macros/minutiae/fragment-specifiers.md:9
#, fuzzy
msgid "[`expr`](#expr)"
msgstr "[`expr`](#expr)"

#: src/decl-macros/minutiae/fragment-specifiers.md:10
#, fuzzy
msgid "[`ident`](#ident)"
msgstr "[ident`](#ident)"

#: src/decl-macros/minutiae/fragment-specifiers.md:11
#, fuzzy
msgid "[`item`](#item)"
msgstr "[アイテム`](#item)"

#: src/decl-macros/minutiae/fragment-specifiers.md:12
#, fuzzy
msgid "[`lifetime`](#lifetime)"
msgstr "[ライフタイム`](#lifetime)"

#: src/decl-macros/minutiae/fragment-specifiers.md:13
#, fuzzy
msgid "[`literal`](#literal)"
msgstr "[リテラル`](#literal)"

#: src/decl-macros/minutiae/fragment-specifiers.md:14
#, fuzzy
msgid "[`meta`](#meta)"
msgstr "[meta`](#meta)"

#: src/decl-macros/minutiae/fragment-specifiers.md:15
#, fuzzy
msgid "[`pat`](#pat)"
msgstr "[pat`](#pat)"

#: src/decl-macros/minutiae/fragment-specifiers.md:16
#, fuzzy
msgid "[`pat_param`](#pat_param)"
msgstr "[pat_param`](#pat_param)"

#: src/decl-macros/minutiae/fragment-specifiers.md:17
#, fuzzy
msgid "[`path`](#path)"
msgstr "[パス`](#path)"

#: src/decl-macros/minutiae/fragment-specifiers.md:18
#, fuzzy
msgid "[`stmt`](#stmt)"
msgstr "[stmt`](#stmt)。"

#: src/decl-macros/minutiae/fragment-specifiers.md:19
#, fuzzy
msgid "[`tt`](#tt)"
msgstr "[tt`](#tt)"

#: src/decl-macros/minutiae/fragment-specifiers.md:20
#, fuzzy
msgid "[`ty`](#ty)"
msgstr "(#ty)"

#: src/decl-macros/minutiae/fragment-specifiers.md:21
#, fuzzy
msgid "[`vis`](#vis)"
msgstr "[ヴィス`](#ヴィス)"

#: src/decl-macros/minutiae/fragment-specifiers.md:23
#, fuzzy
msgid "`block`"
msgstr ""
"ネストされたブロックは、ブロックの本体に追加のインデントが必要になります。\n"
"ブロックからデータを返したり、変数を再定義するに、追加の1行が必要です。"

#: src/decl-macros/minutiae/fragment-specifiers.md:25
#, fuzzy
msgid ""
"The `block` fragment solely matches a [block expression](https://doc.rust-"
"lang.org/reference/expressions/block-expr.html), which consists of an "
"opening `{` brace, followed by any number of statements and finally followed "
"by a closing `}` brace."
msgstr ""
"ブロック`フラグメントは[ブロック式](https://doc.rust-lang.org/reference/"
"expressions/block-expr.html)にのみマッチします。ブロック式は中括弧`{`で始ま"
"り、任意の数のステートメントが続き、最後に中括弧`}`で終わります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:27
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! blocks {\n"
"    ($($block:block)*) => ();\n"
"}\n"
"\n"
"blocks! {\n"
"    {}\n"
"    {\n"
"        let zig;\n"
"    }\n"
"    { 2 }\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ブロック {\n"
"    ($($block:block)*) => ()；\n"
"}\n"
"\n"
"ブロックを作成します！{\n"
"    {}\n"
"    {\n"
"        zig；\n"
"    }\n"
"    { 2 }\n"
"}\n"
"# fn main() [1］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:42
#, fuzzy
msgid "`expr`"
msgstr "`expr`"

#: src/decl-macros/minutiae/fragment-specifiers.md:44
#, fuzzy
msgid ""
"The `expr` fragment matches any kind of [expression](https://doc.rust-lang."
"org/reference/expressions.html) (Rust has a lot of them, given it _is_ an "
"expression orientated language)."
msgstr ""
"expr`フラグメントはあらゆる種類の[式](https://doc.rust-lang.org/reference/"
"expressions.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:46
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! expressions {\n"
"    ($($expr:expr)*) => ();\n"
"}\n"
"\n"
"expressions! {\n"
"    \"literal\"\n"
"    funcall()\n"
"    future.await\n"
"    break 'foo bar\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！式 {\n"
"    ($($expr:expr)*) => ()；\n"
"}\n"
"\n"
"式{\n"
"    「リテラル\n"
"    ファンコール()\n"
"    未来.await\n"
"    break 'フーバー\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:60
#, fuzzy
msgid "`ident`"
msgstr "ident`"

#: src/decl-macros/minutiae/fragment-specifiers.md:62
#, fuzzy
msgid ""
"The `ident` fragment matches an [identifier](https://doc.rust-lang.org/"
"reference/identifiers.html) or _keyword_."
msgstr ""
"ident` フラグメントは [identifier](https://doc.rust-lang.org/reference/"
"identifiers.html) または _keyword_ にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:64
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! idents {\n"
"    ($($ident:ident)*) => ();\n"
"}\n"
"\n"
"idents! {\n"
"    // _ <- This is not an ident, it is a pattern\n"
"    foo\n"
"    async\n"
"    O_________O\n"
"    _____O_____\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($ident:ident)*) => ()；\n"
"}\n"
"\n"
"idents！{\n"
"    // _ <- これは ident ではなく、パターンです。\n"
"    フー\n"
"    非同期\n"
"    O_____________O\n"
"    _____O_____\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:79
#, fuzzy
msgid "`item`"
msgstr "アイテム"

#: src/decl-macros/minutiae/fragment-specifiers.md:81
#, fuzzy
msgid ""
"The `item` fragment simply matches any of Rust's [item](https://doc.rust-"
"lang.org/reference/items.html) _definitions_, not identifiers that refer to "
"items. This includes visibility modifiers."
msgstr ""
"item`フラグメントはRustの[item](https://doc.rust-lang.org/reference/items."
"html) _definition_にマッチするだけで、アイテムを参照する識別子にはマッチしま"
"せん。これには可視性修飾子も含まれます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:84
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! items {\n"
"    ($($item:item)*) => ();\n"
"}\n"
"\n"
"items! {\n"
"    struct Foo;\n"
"    enum Bar {\n"
"        Baz\n"
"    }\n"
"    impl Foo {}\n"
"    pub use crate::foo;\n"
"    /*...*/\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($item:item)*) => ()；\n"
"}\n"
"\n"
"items！{\n"
"    struct Foo；\n"
"    enum バー\n"
"        バズ\n"
"    }\n"
"    impl Foo [0］\n"
"    pub use crate::foo；\n"
"    /*...*/\n"
"}\n"
"# fn main() [1］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:101
#, fuzzy
msgid "`lifetime`"
msgstr "ライフタイム"

#: src/decl-macros/minutiae/fragment-specifiers.md:103
#, fuzzy
msgid ""
"The `lifetime` fragment matches a [lifetime or label](https://doc.rust-lang."
"org/reference/tokens.html#lifetimes-and-loop-labels). It's quite similar to "
"[`ident`](#ident) but with a prepended `'`."
msgstr ""
"lifetime`フラグメントは[lifetime or label](https://doc.rust-lang.org/"
"reference/tokens.html#lifetimes-and-loop-labels)にマッチします。これは"
"[`ident`](#ident)とよく似ていますが、先頭に`'`が付きます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:106
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! lifetimes {\n"
"    ($($lifetime:lifetime)*) => ();\n"
"}\n"
"\n"
"lifetimes! {\n"
"    'static\n"
"    'shiv\n"
"    '_\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($lifetime:lifetime)*) => ()；\n"
"}\n"
"\n"
"lifetimes！{\n"
"    静的\n"
"    'shiv\n"
"    '_\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:119
#, fuzzy
msgid "`literal`"
msgstr "リテラル"

#: src/decl-macros/minutiae/fragment-specifiers.md:121
#, fuzzy
msgid ""
"The `literal` fragment matches any [literal expression](https://doc.rust-"
"lang.org/reference/expressions/literal-expr.html)."
msgstr ""
"literal`フラグメントは任意の[リテラル表現](https://doc.rust-lang.org/"
"reference/expressions/literal-expr.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:123
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! literals {\n"
"    ($($literal:literal)*) => ();\n"
"}\n"
"\n"
"literals! {\n"
"    -1\n"
"    \"hello world\"\n"
"    2.3\n"
"    b'b'\n"
"    true\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！リテラル {\n"
"    ($($literal:literal)*) => ()；\n"
"}\n"
"\n"
"リテラル{\n"
"    -1\n"
"    \"hello world\"\n"
"    2.3\n"
"    b'b'\n"
"    真\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:138
#, fuzzy
msgid "`meta`"
msgstr "メタ"

#: src/decl-macros/minutiae/fragment-specifiers.md:140
#, fuzzy
msgid ""
"The `meta` fragment matches the contents of an [attribute](https://doc.rust-"
"lang.org/reference/attributes.html). That is, it will match a simple path, "
"one without generic arguments followed by a delimited token tree or an `=` "
"followed by a literal expression."
msgstr ""
"meta` フラグメントは [attribute](https://doc.rust-lang.org/reference/"
"attributes.html) の内容にマッチします。つまり、単純なパス、区切られたトークン"
"ツリーまたは `=` の後にリテラル式が続く一般的な引数のないパスにマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:143
#, fuzzy
msgid ""
"**Note**: You will usually see this fragment being used in a matcher like "
"`#[$meta:meta]` or `#![$meta:meta]` to actually capture an attribute."
msgstr ""
"**注意**：このフラグメントは通常、`#[$meta:meta]` や `#![$meta:meta]` のよう"
"なマッチャーで使用され、実際に属性をキャプチャします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:145
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! metas {\n"
"    ($($meta:meta)*) => ();\n"
"}\n"
"\n"
"metas! {\n"
"    ASimplePath\n"
"    super::man\n"
"    path = \"home\"\n"
"    foo(bar)\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($meta:meta)*) => ()；\n"
"}\n"
"\n"
"meta:meta:meta:meta:meta:meta！{\n"
"    ASimplePath\n"
"    super::man\n"
"    パス = \"home\"\n"
"    foo(bar)\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:159
#, fuzzy
msgid ""
"**Doc-Comment Fact**: Doc-Comments like `/// ...` and `//! ...` are actually "
"syntax sugar for attributes! They desugar to `#[doc=\"...\"]` and `#!"
"[doc=\"...\"]` respectively, meaning you can match on them like with "
"attributes!"
msgstr ""
"**Doc-Comment Fact**：Doc-Comment の `/// ...` や `//! ...` は実は属性のため"
"の構文解析です！これらはそれぞれ `#[doc=\"...\"]` と `#![doc=\"...\"]` にデ"
"シュガーされます！"

#: src/decl-macros/minutiae/fragment-specifiers.md:161
#, fuzzy
msgid "`pat`"
msgstr "pat`"

#: src/decl-macros/minutiae/fragment-specifiers.md:163
#, fuzzy
msgid ""
"The `pat` fragment matches any kind of [pattern](https://doc.rust-lang.org/"
"reference/patterns.html), including or-patterns starting with the 2021 "
"edition."
msgstr ""
"pat`フラグメントは、2021年版から始まるor-patternを含む、あらゆる種類の"
"[pattern](https://doc.rust-lang.org/reference/patterns.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:165
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($($pat:pat)*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($pat:pat)*) => ()；\n"
"}\n"
"\n"
"パターン{\n"
"    \"リテラル\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:180
#, fuzzy
msgid "`pat_param`"
msgstr "pat_param`"

#: src/decl-macros/minutiae/fragment-specifiers.md:182
#, fuzzy
msgid ""
"In the 2021 edition, the behavior for the `pat` fragment type has been "
"changed to allow or-patterns to be parsed. This changes the follow list of "
"the fragment, preventing such fragment from being followed by a `|` token. "
"To avoid this problem or to get the old fragment behavior back one can use "
"the `pat_param` fragment which allows `|` to follow it, as it disallows top "
"level or-patterns."
msgstr ""
"2021年版では、`pat` フラグメントタイプの動作が変更され、or-パターンをパースで"
"きるようになりました。これにより、フラグメントのフォローリストが変更され、そ"
"のようなフラグメントの後に `|` トークンが続くことができなくなりました。この問"
"題を回避したり、以前のフラグメントの挙動に戻したりするには、 `pat_param` フラ"
"グメントを使用します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:186
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($( $( $pat:pat_param )|+ )*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！パターン {\n"
"    ($( $pat:pat_param )|+ )*) => ()；\n"
"}\n"
"\n"
"パターン{\n"
"    \"リテラル\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:201
#, fuzzy
msgid "`path`"
msgstr ""
"```rust\n"
"use std::path::{Path, PathBuf};\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFSセッション管理は省略\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // bootpでは認証なし\n"
"}\n"
"\n"
"// 外部のユーザが独自のプロトコルを作れないようにするため、 private なモ"
"ジュールです！\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf};\n"
"    use super::{bootp, nfs};\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        type AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo;\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo,\n"
"        mount_point: PathBuf,\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&self) -> &Path {\n"
"            &self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs {\n"
"        type AuthInfo = nfs::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // 追加のメタデータなし\n"
"\n"
"    impl ProtoKind for Bootp {\n"
"        type AuthInfo = bootp::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // impl を防ぐため、非publicを維持\n"
"pub use proto_trait::{Nfs, Bootp}; // 呼び出し元に見えるよう再エクスポート\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> {\n"
"    file_name: PathBuf,\n"
"    protocol: P,\n"
"}\n"
"\n"
"// すべての共通のAPIは、ジェネリックの impl ブロックに入れます\n"
"impl<P: ProtoKind> FileDownloadRequest<P> {\n"
"    fn file_path(&self) -> &Path {\n"
"        &self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&self) -> P::AuthInfo {\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// すべてのプロトコル固有の実装は、それぞれのブロックに入れます\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&self) -> &Path {\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // ここにあなたのコード\n"
"}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:203
#, fuzzy
msgid ""
"The `path` fragment matches a so called [TypePath](https://doc.rust-lang.org/"
"reference/paths.html#paths-in-types) style path. This includes the function "
"style trait forms, `Fn() -> ()`."
msgstr ""
"path`フラグメントはいわゆる[TypePath](https://doc.rust-lang.org/reference/"
"paths.html#paths-in-types)スタイルのパスにマッチします。これには関数スタイル"
"の trait フォームである `Fn() -> ()` が含まれます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:206
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! paths {\n"
"    ($($path:path)*) => ();\n"
"}\n"
"\n"
"paths! {\n"
"    ASimplePath\n"
"    ::A::B::C::D\n"
"    G::<eneri>::C\n"
"    FnMut(u32) -> ()\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($path:path)*) =&gt; ()；\n"
"}\n"
"\n"
"パスを指定します！{\n"
"    ASimplePath\n"
"    ::A::B::C::D\n"
"    G::<eneri>::C\n"
"    FnMut(u32) -&gt; ()\n"
"}\n"
"# fn main(){}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:220
#, fuzzy
msgid "`stmt`"
msgstr ""
"```rust,ignore\n"
"// foldされるデータ。単純なAST。\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>),\n"
"        Let(Box<Name>, Box<Expr>),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// folderの抽象\n"
"mod fold {\n"
"    use ast::*;\n"
"\n"
"    pub trait Folder {\n"
"        // リーフノードは単にノード自身を返します。多くの状況では、内部ノード"
"についても同様にすることが可能です。\n"
"        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
"        // 子ノードを fold し新たな内部ノードを作成します。\n"
"        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
"            match *s {\n"
"                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),\n"
"                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e))),\n"
"            }\n"
"        }\n"
"        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
"    }\n"
"}\n"
"\n"
"use fold::*;\n"
"use ast::*;\n"
"\n"
"// 具体的な実装例 - すべての名前を 'foo' にリネームします。\n"
"struct Renamer;\n"
"impl Folder for Renamer {\n"
"    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
"        Box::new(Name { value: \"foo\".to_owned() })\n"
"    }\n"
"    // 他のノードに対してはデフォルト実装を使用します。\n"
"}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:222
#, fuzzy
msgid ""
"The `statement` fragment solely matches a [statement](https://doc.rust-lang."
"org/reference/statements.html) without its trailing semicolon, unless it is "
"an item statement that requires one (such as a Unit-Struct)."
msgstr ""
"ステートメント`フラグメントは、[ステートメント](https://doc.rust-lang.org/"
"reference/statements.html)の最後のセミコロンを除いたものにのみマッチします。"
"ただし、セミコロンを必要とするアイテムステートメント(Unit-Structなど)は除きま"
"す。"

#: src/decl-macros/minutiae/fragment-specifiers.md:224
#, fuzzy
msgid ""
"Let's use a simple example to show exactly what is meant with this. We use a "
"macro that merely emits what it captures:"
msgstr ""
"これが何を意味するのか、簡単な例で説明しましょう。単にキャプチャしたものを出"
"力するだけのマクロを使います："

#: src/decl-macros/minutiae/fragment-specifiers.md:227
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! statements {\n"
"    ($($stmt:stmt)*) => ($($stmt)*);\n"
"}\n"
"\n"
"fn main() {\n"
"    statements! {\n"
"        struct Foo;\n"
"        fn foo() {}\n"
"        let zig = 3\n"
"        let zig = 3;\n"
"        3\n"
"        3;\n"
"        if true {} else {}\n"
"        {}\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"錆、無視\n"
"マクロルール！文 {\n"
"    ($($stmt:stmt)*) => ($($stmt)*)；\n"
"}\n"
"\n"
"fn main() {\n"
"    ステートメント{\n"
"        struct Foo；\n"
"        fn foo() [0］\n"
"        zig = 3\n"
"        let zig = 3；\n"
"        3\n"
"        3;\n"
"        if true {} else [2］\n"
"        {}\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:247
#, fuzzy
msgid ""
"Expanding this, via the [playground](https://play.rust-lang.org/) for "
"example[^debugging], gives us roughly the following:"
msgstr ""
"これを、例えば[^debugging]のように[playground](https://play.rust-lang.org/)を"
"使って展開すると、おおよそ次のようになります："

#: src/decl-macros/minutiae/fragment-specifiers.md:249
#, fuzzy
msgid ""
"```rust,ignore\n"
"/* snip */\n"
"\n"
"fn main() {\n"
"    struct Foo;\n"
"    fn foo() { }\n"
"    let zig = 3;\n"
"    let zig = 3;\n"
"    ;\n"
"    3;\n"
"    3;\n"
"    ;\n"
"    if true { } else { }\n"
"    { }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"/* snap */\n"
"\n"
"fn main() {\n"
"    struct Foo；\n"
"    fn foo() { }.\n"
"    let zig = 3；\n"
"    let zig = 3；\n"
"    ;\n"
"    3;\n"
"    3;\n"
"    ;\n"
"    if true { } else { }.\n"
"    \n"
"\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:266
#, fuzzy
msgid "From this we can tell a few things."
msgstr "ここからいくつかのことがわかります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:268
#, fuzzy
msgid ""
"The first you should be able to see immediately is that while the `stmt` "
"fragment doesn't capture trailing semicolons, it still emits them when "
"required, even if the statement is already followed by one. The simple "
"reason for that is that semicolons on their own are already valid statements "
"which the fragment captures eagerly. So our macro isn't capturing 8 times, "
"but 10! This can be important when doing multiples repetitions and expanding "
"these in one repetition expansion, as the repetition numbers have to match "
"in those cases."
msgstr ""
"最初にすぐにわかることは、`stmt` フラグメントは末尾のセミコロンを捕捉しません"
"が、ステートメントにすでにセミコロンが続いていたとしても、必要なときにセミコ"
"ロンを出力します。その単純な理由は、セミコロンはそれ自体がすでに有効なステー"
"トメントであり、フラグメントはそれを捕捉するからです。つまり、マクロは8回キャ"
"プチャするのではなく、10回キャプチャします！これは、複数の繰り返しを行い、そ"
"れらを1つの繰り返し展開で展開する場合に重要です。"

#: src/decl-macros/minutiae/fragment-specifiers.md:273
#, fuzzy
msgid ""
"Another thing you should be able to notice here is that the trailing "
"semicolon of the `struct Foo;` item statement is being matched, otherwise we "
"would've seen an extra one like in the other cases. This makes sense as we "
"already said, that for item statements that require one, the trailing "
"semicolon will be matched with."
msgstr ""
"ここでもうひとつ注目してほしいのは、`struct Foo;` という項目文の末尾のセミコ"
"ロンがマッチしていることです。すでに述べたように、セミコロンが必要な項目文で"
"は、末尾のセミコロンがマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:276
#, fuzzy
msgid ""
"A last observation is that expressions get emitted back with a trailing "
"semicolon, unless the expression solely consists of only a block expression "
"or control flow expression."
msgstr ""
"最後の観察は、式がブロック式や制御フロー式だけで構成されていない限り、式はセ"
"ミコロンを末尾に付けて返されるということです。"

#: src/decl-macros/minutiae/fragment-specifiers.md:278
#, fuzzy
msgid ""
"The fine details of what was just mentioned here can be looked up in the "
"[reference](https://doc.rust-lang.org/reference/statements.html)."
msgstr ""
"ここで述べたことの細かいことは、[参考文献](https://doc.rust-lang.org/"
"reference/statements.html)で調べることができます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:280
#, fuzzy
msgid ""
"Fortunately, these fine details here are usually not of importance "
"whatsoever, with the small exception that was mentioned earlier in regards "
"to repetitions which by itself shouldn't be a common problem to run into."
msgstr ""
"幸いなことに、このような細かな点は通常全く重要ではありません。繰り返しに関し"
"ては、先に述べた小さな例外がありますが、それ自体はよくある問題ではありませ"
"ん。"

#: src/decl-macros/minutiae/fragment-specifiers.md:282
#, fuzzy
msgid "See the [debugging chapter](./debugging.md) for tips on how to do this."
msgstr "その方法については、[デバッグの章](./debugging.md)を参照してください。"

#: src/decl-macros/minutiae/fragment-specifiers.md:284
#, fuzzy
msgid "`tt`"
msgstr "tt`"

#: src/decl-macros/minutiae/fragment-specifiers.md:286
#, fuzzy
msgid ""
"The `tt` fragment matches a TokenTree. If you need a refresher on what "
"exactly a TokenTree was you may want to revisit the [TokenTree chapter]"
"(../../syntax-extensions/source-analysis.md#token-trees) of this book. The "
"`tt` fragment is one of the most powerful fragments, as it can match nearly "
"anything while still allowing you to inspect the contents of it at a later "
"state in the macro."
msgstr ""
"tt` フラグメントは TokenTree にマッチします。もしTokenTreeが何なのか再確認し"
"たい場合は、この本の[TokenTreeの章](../../syntax-extensions/source-analysis."
"md#token-trees)をもう一度読んでみてください。tt` フラグメントは最も強力なフラ"
"グメントの1つで、ほぼすべてのものにマッチすることができ、マクロの後の段階でそ"
"の内容を検査することができます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:290
#, fuzzy
msgid ""
"This allows one to make use of very powerful patterns like the [tt-muncher]"
"(../patterns/tt-muncher.md) or the [push-down-accumulator](../patterns/push-"
"down-acc.md)."
msgstr ""
"これにより、[tt-muncher](../patterns/tt-muncher.md)や[push-down-accumulator]"
"(../patterns/push-down-acc.md)のような非常に強力なパターンを利用することがで"
"きます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:292
#, fuzzy
msgid "`ty`"
msgstr "ty`。"

#: src/decl-macros/minutiae/fragment-specifiers.md:294
#, fuzzy
msgid ""
"The `ty` fragment matches any kind of [type expression](https://doc.rust-"
"lang.org/reference/types.html#type-expressions)."
msgstr ""
"ty`フラグメントはあらゆる種類の[型表現](https://doc.rust-lang.org/reference/"
"types.html#type-expressions)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:296
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! types {\n"
"    ($($type:ty)*) => ();\n"
"}\n"
"\n"
"types! {\n"
"    foo::bar\n"
"    bool\n"
"    [u8]\n"
"    impl IntoIterator<Item = u32>\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($type:ty)*) => ()；\n"
"}\n"
"\n"
"型！{\n"
"    foo::bar\n"
"    ブール\n"
"    [u8]\n"
"    impl IntoIterator<Item = u32>.\n"
"}\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:310
#, fuzzy
msgid "`vis`"
msgstr "vis`。"

#: src/decl-macros/minutiae/fragment-specifiers.md:312
#, fuzzy
msgid ""
"The `vis` fragment matches a _possibly empty_ [Visibility qualifier](https://"
"doc.rust-lang.org/reference/visibility-and-privacy.html)."
msgstr ""
"vis`フラグメントは_possibly empty_ [Visibility qualifier](https://doc.rust-"
"lang.org/reference/visibility-and-privacy.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:314
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! visibilities {\n"
"    //         ∨~~Note this comma, since we cannot repeat a `vis` fragment "
"on its own\n"
"    ($($vis:vis,)*) => ();\n"
"}\n"
"\n"
"visibilities! {\n"
"    , // no vis is fine, due to the implicit `?`\n"
"    pub,\n"
"    pub(crate),\n"
"    pub(in super),\n"
"    pub(in some_path),\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    // vis` フラグメントを単独で繰り返すことはできないので、このコンマに注意"
"してください。\n"
"    ($($vis:vis,)*) => ()；\n"
"}\n"
"\n"
"visibilities！{\n"
"    // 暗黙の `?\n"
"    pub、\n"
"    pub(crate)、\n"
"    pub(in super)、\n"
"    pub(in some_path)、\n"
"}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:329
#, fuzzy
msgid ""
"While able to match empty sequences of tokens, the fragment specifier still "
"acts quite different from [optional repetitions](../macros-methodical."
"md#repetitions) which is described in the following:"
msgstr ""
"このフラグメント指定子は、空のトークンのシーケンスにマッチさせることができま"
"すが、以下で説明する[optional repetitions](../macros-methodical."
"md#repetitions)とは全く異なる動作をします："

#: src/decl-macros/minutiae/fragment-specifiers.md:331
#, fuzzy
msgid ""
"If it is being matched against no left over tokens the entire macro matching "
"fails."
msgstr "残っているトークンがない場合、マクロ・マッチング全体が失敗します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:332
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! non_optional_vis {\n"
"    ($vis:vis) => ();\n"
"}\n"
"non_optional_vis!();\n"
"// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ non_optional_vis { ($vis:vis) => (;;)\n"
"    ($vis:vis) => ()；\n"
"}\n"
"non_optional_vis!\n"
"// エラー: マクロ引数にトークンがありません。\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:340
#, fuzzy
msgid ""
"`$vis:vis $ident:ident` matches fine, unlike `$(pub)? $ident:ident` which is "
"ambiguous, as `pub` denotes a valid identifier."
msgstr "vis:vis $ident:ident` は、`$(pub)?ident:ident`とは異なり、`$(pub)?"

#: src/decl-macros/minutiae/fragment-specifiers.md:341
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! vis_ident {\n"
"    ($vis:vis $ident:ident) => ();\n"
"}\n"
"vis_ident!(pub foo); // this works fine\n"
"\n"
"macro_rules! pub_ident {\n"
"    ($(pub)? $ident:ident) => ();\n"
"}\n"
"pub_ident!(pub foo);\n"
"        // ^^^ error: local ambiguity when calling macro `pub_ident`: "
"multiple parsing options: built-in NTs ident ('ident') or 1 other option.\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ vis_ident {\n"
"    ($vis:vis $ident:ident) => ()；\n"
"}\n"
"vis_ident!(pub foo); // これは問題なく動作します。\n"
"\n"
"macro_rules!\n"
"    ($(pub)?ident:ident) => ()；\n"
"}\n"
"pub_ident!(pub foo)；\n"
"        // ^^^ error: local ambiguity when calling macro `pub_ident`: "
"multiple parsing options: 組み込み NT の ident ('ident') または他の 1 つのオ"
"プション。\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:354
#, fuzzy
msgid ""
"Being a fragment that matches the empty token sequence also gives it a very "
"interesting quirk in combination with `tt` fragments and recursive "
"expansions."
msgstr ""
"空のトークン列にマッチするフラグメントであることは、`tt`フラグメントや再帰的"
"展開と組み合わせて、非常に興味深い癖を与えます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:356
#, fuzzy
msgid ""
"When matching the empty token sequence, the metavariable will still count as "
"a capture and since it is not a `tt`, `ident` or `lifetime` fragment it will "
"become opaque to further expansions. This means if this capture is passed "
"onto another macro invocation that captures it as a `tt` you effectively end "
"up with token tree that contains nothing!"
msgstr ""
"空のトークンシーケンスにマッチする場合、メタ変数はキャプチャとしてカウントさ"
"れ、 `tt`、`ident`、`lifetime` フラグメントではないため、それ以降の展開には不"
"透明になります。つまり、このキャプチャを `tt` としてキャプチャする別のマクロ"
"に渡すと、何も含まないトークンツリーになってしまいます！"

#: src/decl-macros/minutiae/fragment-specifiers.md:359
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! it_is_opaque {\n"
"    (()) => { \"()\" };\n"
"    (($tt:tt)) => { concat!(\"$tt is \", stringify!($tt)) };\n"
"    ($vis:vis ,) => { it_is_opaque!( ($vis) ); }\n"
"}\n"
"fn main() {\n"
"    // this prints \"$tt is \", as the recursive calls hits the second "
"branch with\n"
"    // an empty tt, opposed to matching with the first branch!\n"
"    println!(\"{}\", it_is_opaque!(,));\n"
"}\n"
"```"
msgstr ""
"錆\n"
"マクロルール！ it_is_opaque {\n"
"    (()) => { \"()\" };\n"
"    (($tt:tt)) => { concat!(\"$tt is \", stringify!($tt))};\n"
"    ($vis:vis ,) => { it_is_opaque!( ($vis) ); }.\n"
"}\n"
"fn main() {\n"
"    再帰呼び出しでは 2 番目の分岐で空の tt が返されるため、 // \"$tt is \" と"
"表示されます。\n"
"    // と表示されます！\n"
"    println!(\"{}\", it_is_opaque!(,))；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:3
#, fuzzy
msgid ""
"Once the parser begins consuming tokens for a metavariable, _it cannot stop "
"or backtrack_. This means that the second rule of the following macro "
"_cannot ever match_, no matter what input is provided:"
msgstr ""
"いったんパーサーがメタ変数のトークンを消費し始めると、_停止したりバックトラッ"
"クすることはできません。つまり、次のマクロの2番目のルールは、どのような入力が"
"提供されたとしても、決してマッチしません："

#: src/decl-macros/minutiae/metavar-and-expansion.md:6
#, fuzzy
msgid ""
"```ignore\n"
"macro_rules! dead_rule {\n"
"    ($e:expr) => { ... };\n"
"    ($i:ident +) => { ... };\n"
"}\n"
"```"
msgstr ""
"無視\n"
"マクロルール！ dead_rule { ($e:expr) => { ...\n"
"    ($e:expr) => { ...};\n"
"    ($i:ident +) => { ...};\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:13
#, fuzzy
msgid ""
"Consider what happens if this macro is invoked as `dead_rule!(x+)`. The "
"interpreter will start at the first rule, and attempt to parse the input as "
"an expression. The first token `x` is valid as an expression. The second "
"token is _also_ valid in an expression, forming a binary addition node."
msgstr ""
"このマクロを `dead_rule!(x+)` として呼び出したらどうなるか考えてみましょう。"
"インタープリタは最初のルールから開始し、入力を式として解析しようとします。最"
"初のトークン `x` は式として有効です。2番目のトークンも式として有効であり、2進"
"数の加算ノードを形成します。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:18
#, fuzzy
msgid ""
"At this point, given that there is no right-hand side of the addition, you "
"might expect the parser to give up and try the next rule. Instead, the "
"parser will panic and abort the entire compilation, citing a syntax error."
msgstr ""
"この時点で、加算の右辺がないことを考えると、パーサーはあきらめて次のルールを"
"試すと思うかもしれません。しかしパーサーはパニックを起こし、構文エラーを理由"
"にコンパイル全体を中断します。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:21
#, fuzzy
msgid ""
"As such, it is important in general that you write macro rules from most-"
"specific to least-specific."
msgstr ""
"そのため、一般的には、最も特殊なものから最も特殊でないものへとマクロルールを"
"記述することが重要です。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:23
#, fuzzy
msgid ""
"To defend against future syntax changes altering the interpretation of macro "
"input, `macro_rules!` restricts what can follow various metavariables. The "
"complete list, showing what may follow what fragment specifier, as of Rust "
"1.46 is as follows:"
msgstr ""
"将来的な構文の変更によってマクロ入力の解釈が変わってしまうのを防ぐために、 "
"`macro_rules!` は様々なメタ変数の後に続くものを制限しています。Rust 1.46時点"
"での、どのフラグメント指定子に何が続くかを示す完全なリストは以下の通りです："

#: src/decl-macros/minutiae/metavar-and-expansion.md:27
#, fuzzy
msgid ""
"[`stmt`](./fragment-specifiers.md#stmt) and [`expr`](./fragment-specifiers."
"md#expr): `=>`, `,`, or `;`"
msgstr ""
"[`stmt`](./fragment-specifiers.md#stmt)および[`expr`](./fragment-specifiers."
"md#expr)：には、`=>`、`,`、`;`のいずれかを指定します。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:28
#, fuzzy
msgid ""
"[`pat`](./fragment-specifiers.md#pat): `=>`, `,`, `=`, `if`, `in`[^pat-"
"edition]"
msgstr ""
"[`pat`](./fragment-specifiers.md#pat)：`=>`, `,`, `=`, `if`, `in`[^pat-"
"edition]."

#: src/decl-macros/minutiae/metavar-and-expansion.md:29
#, fuzzy
msgid ""
"[`pat_param`](./fragment-specifiers.md#pat_param): `=>`, `,`, `=`, `|`, "
"`if`, `in`"
msgstr ""
"[pat_param`](./fragment-specifiers.md#pat_param)：`=>`, `,`, `=`, `|`, `if`, "
"`in`."

#: src/decl-macros/minutiae/metavar-and-expansion.md:30
#, fuzzy
msgid ""
"[`path`](./fragment-specifiers.md#path) and [`ty`](./fragment-specifiers."
"md#ty):`=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where`, or "
"a macro variable of the [`block`](./fragment-specifiers.md#block) fragment "
"specifier."
msgstr ""
"[`path`](./fragment-specifiers.md#path) と [`ty`](./fragment-specifiers."
"md#ty):`=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where`, ま"
"たは [`block`](./fragment-specifiers.md#block) フラグメント指定子のマクロ変"
"数。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:32
#, fuzzy
msgid ""
"[`vis`](./fragment-specifiers.md#vis): `,`, an identifier other than a non-"
"raw `priv`, any token that can begin a type or a metavariable with an "
"[`ident`](./fragment-specifiers.md#ident), [`ty`](./fragment-specifiers."
"md#ty), or [`path`](./fragment-specifiers.md#path) fragment specifier."
msgstr ""
"[`vis`](./fragment-specifiers.md#vis)：`,`, `priv` 以外の識別子、[`ident`](./"
"fragment-specifiers.md#ident)、[`ty`](./fragment-specifiers.md#ty)、または "
"[`path`](./fragment-specifiers.md#path) フラグメント指定子で型またはメタ変数"
"を開始できるトークン。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:34
#, fuzzy
msgid "All other fragment specifiers have no restrictions."
msgstr "その他のフラグメント指定子には制限がありません。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:36
#, fuzzy
msgid ""
"**Edition Differences**: Before the 2021 edition, `pat` may also be followed "
"by `|`."
msgstr ""
"**エディションの違い**：2021年版以前では、`pat` の後に `|` が続くこともありま"
"す。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:38
#, fuzzy
msgid ""
"Repetitions also adhere to these restrictions, meaning if a repetition can "
"repeat multiple times(`*` or `+`), then the contents must be able to follow "
"themselves. If a repetition can repeat zero times (`?` or `*`) then what "
"comes after the repetition must be able to follow what comes before."
msgstr ""
"つまり、もし繰り返しが複数回(`*`または `+`)繰り返せるのであれば、その内容はそ"
"れ自体に従うことができなければなりません。繰り返しが0回(`?`または`*`)繰り返せ"
"る場合、繰り返しの後に来るものは前に来るものに従うことができなければなりませ"
"ん。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:41
#, fuzzy
msgid ""
"The parser also does not perform any kind of lookahead. That means if the "
"compiler cannot unambiguously determine how to parse the macro invocation "
"one token at a time, it will abort with an ambiguity error. A simple example "
"that triggers this:"
msgstr ""
"また、パーサーは先読みを行いません。つまり、コンパイラがマクロ呼び出しを 1 "
"トークンずつ解析する方法を明確に決定できない場合、あいまい性エラーで中断しま"
"す。これを引き起こす簡単な例を示します："

#: src/decl-macros/minutiae/metavar-and-expansion.md:45
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! ambiguity {\n"
"    ($($i:ident)* $i2:ident) => { };\n"
"}\n"
"\n"
"// error:\n"
"//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or "
"ident ('i2').\n"
"ambiguity!(an_identifier);\n"
"```"
msgstr ""
"錆\n"
"macro_rules!\n"
"    ($($i:ident)* $i2:ident) => { }；\n"
"}\n"
"\n"
"// エラー：\n"
"// 組み込み NT の ident ('i') または ident ('i2') です。\n"
"ambiguity!(an_identifier)；\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:55
#, fuzzy
msgid ""
"The parser does not look ahead past the identifier to see if the following "
"token is a `)`, which would allow it to parse properly."
msgstr ""
"パーサーは識別子を越えて、次のトークンが `)` であるかどうかを調べません。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:57
#, fuzzy
msgid ""
"One aspect of substitution that often surprises people is that substitution "
"is _not_ token-based, despite very much _looking_ like it."
msgstr ""
"しばしば人々を驚かせる代入の1つの側面は、代入が非常にトークン・ベースであるよ"
"うに見えるにもかかわらず、トークン・ベースではないということです。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:59
#, fuzzy
msgid "Consider the following:"
msgstr "次のことを考えてみてください："

#: src/decl-macros/minutiae/metavar-and-expansion.md:61
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! capture_then_match_tokens {\n"
"    ($e:expr) => {match_tokens!($e)};\n"
"}\n"
"\n"
"macro_rules! match_tokens {\n"
"    ($a:tt + $b:tt) => {\"got an addition\"};\n"
"    (($i:ident)) => {\"got an identifier\"};\n"
"    ($($other:tt)*) => {\"got something else\"};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\\n{}\\n{}\\n\",\n"
"        match_tokens!((caravan)),\n"
"        match_tokens!(3 + 6),\n"
"        match_tokens!(5));\n"
"    println!(\"{}\\n{}\\n{}\",\n"
"        capture_then_match_tokens!((caravan)),\n"
"        capture_then_match_tokens!(3 + 6),\n"
"        capture_then_match_tokens!(5));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ capture_then_match_tokens { ($e:expr => [0;])\n"
"    ($e:expr) => {match_tokens!($e)}；\n"
"}\n"
"\n"
"macro_rules!\n"
"    ($a:tt + $b:tt) => {\"追加\"}；\n"
"    (($i:ident)) => {\"識別子を取得\"}；\n"
"    ($($other:tt)*) => {\"他のものを取得\"}；\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\\n{}\\n{}\\n\",\n"
"        match_tokens!((caravan))、\n"
"        match_tokens!(3 + 6)、\n"
"        match_tokens!(5))；\n"
"    println!(\"{}\\n{}\\n{}\",\n"
"        capture_then_match_tokens!((キャラバン))、\n"
"        capture_then_match_tokens!(3 + 6)、\n"
"        capture_then_match_tokens!(5))；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:84
#: src/decl-macros/minutiae/metavar-and-expansion.md:123
#: src/decl-macros/minutiae/debugging.md:26
#, fuzzy
msgid "The output is:"
msgstr "出力は"

#: src/decl-macros/minutiae/metavar-and-expansion.md:86
#, fuzzy
msgid ""
"```text\n"
"got an identifier\n"
"got an addition\n"
"got something else\n"
"\n"
"got something else\n"
"got something else\n"
"got something else\n"
"```"
msgstr ""
"テキスト\n"
"識別子を取得\n"
"追加を取得\n"
"他の何かを取得\n"
"\n"
"他の何かを取得\n"
"got something else\n"
"got something else\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:96
#, fuzzy
msgid ""
"By parsing the input into an AST node, the substituted result becomes _un-"
"destructible_; _i.e._ you cannot examine the contents or match against it "
"ever again."
msgstr ""
"入力をASTノードにパースすることによって、置換された結果は_破壊不可能_になりま"
"す。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:99
#, fuzzy
msgid "Here is _another_ example which can be particularly confusing:"
msgstr "特に混乱しやすい例を挙げましょう："

#: src/decl-macros/minutiae/metavar-and-expansion.md:101
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! capture_then_what_is {\n"
"    (#[$m:meta]) => {what_is!(#[$m])};\n"
"}\n"
"\n"
"macro_rules! what_is {\n"
"    (#[no_mangle]) => {\"no_mangle attribute\"};\n"
"    (#[inline]) => {\"inline attribute\"};\n"
"    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), "
"\")\")};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\n"
"        \"{}\\n{}\\n{}\\n{}\",\n"
"        what_is!(#[no_mangle]),\n"
"        what_is!(#[inline]),\n"
"        capture_then_what_is!(#[no_mangle]),\n"
"        capture_then_what_is!(#[inline]),\n"
"    );\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ capture_then_what_is { (#[$m:meta] => [0;])\n"
"    (#[$m:meta]) => {what_is!(#[$m])}；\n"
"}\n"
"\n"
"macro_rules!\n"
"    (#[no_mangle]) => {\"no_mangle属性\"}；\n"
"    (#[inline]) => {\"インライン属性\"}；\n"
"    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), "
"\")\")}；\n"
"}\n"
"\n"
"fn main() {\n"
"    println!\n"
"        \"{}\\n{}\\n{}\\n{}\",\n"
"        what_is!(#[no_mangle])、\n"
"        what_is!(#[inline])、\n"
"        capture_then_what_is!(#[no_mangle])、\n"
"        capture_then_what_is!(#[inline])、\n"
"    );\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:125
#, fuzzy
msgid ""
"```text\n"
"no_mangle attribute\n"
"inline attribute\n"
"something else (#[no_mangle])\n"
"something else (#[inline])\n"
"```"
msgstr ""
"テキスト\n"
"no_mangle属性\n"
"インライン属性\n"
"他の何か (#[no_mangle])\n"
"他の何か (#[inline])\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:132
#, fuzzy
msgid ""
"The only way to avoid this is to capture using the [`tt`](./fragment-"
"specifiers.md#tt), [`ident`](./fragment-specifiers.md#ident) or [`lifetime`]"
"(./fragment-specifiers.md#lifetime) kinds. Once you capture with anything "
"else, the only thing you can do with the result from then on is substitute "
"it directly into the output."
msgstr ""
"これを避ける唯一の方法は、[`tt`](./fragment-specifiers.md#tt)、[`ident`](./"
"fragment-specifiers.md#ident)、[`lifetime`](./fragment-specifiers."
"md#lifetime)のいずれかの種類を使ってキャプチャすることです。それ以外でキャプ"
"チャした場合、それ以降その結果を直接出力に代入することしかできません。"

#: src/decl-macros/minutiae/metavar-expr.md:7
#, fuzzy
msgid ""
"Note: The example code snippets are very bare bones, trying to show off how "
"they work. If you think you got small snippets with proper isolated usage of "
"these expression please submit them!"
msgstr ""
"注意: サンプル・コード・スニペットは、どのように動作するかを示すための、非常"
"に素朴なものです。これらの式の適切な分離された使用法を持つ小さなスニペットが"
"ある場合は、それを提出してください！"

#: src/decl-macros/minutiae/metavar-expr.md:9
#, fuzzy
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md), "
"Rust has special expressions that can be used by macro transcribers to "
"obtain information about metavariables that are otherwise difficult or even "
"impossible to get. This chapter will introduce them more in-depth together "
"with usage examples."
msgstr ""
"メソッド紹介](../macros-methodical.md) で述べたように、Rust には特別な表現が"
"あり、マクロの書き起こし担当者が、他の方法では取得が難しい、あるいは不可能な"
"メタ変数に関する情報を取得するために使用することができます。この章では、使用"
"例とともに、それらをより詳しく紹介します。"

#: src/decl-macros/minutiae/metavar-expr.md:12
#, fuzzy
msgid "[`$$`](#dollar-dollar-)"
msgstr "[ドル・ドル・ドル"

#: src/decl-macros/minutiae/metavar-expr.md:13
#, fuzzy
msgid "[`${count(ident, depth)}`](#countident-depth)"
msgstr "[`${count(ident, depth)}`](#countident-depth)"

#: src/decl-macros/minutiae/metavar-expr.md:14
#, fuzzy
msgid "[`${index(depth)}`](#indexdepth)"
msgstr "[${index(depth)}`](#indexdepth)"

#: src/decl-macros/minutiae/metavar-expr.md:15
#, fuzzy
msgid "[`${length(depth)}`](#lengthdepth)"
msgstr "[${length(depth)}`](#lengthdepth)"

#: src/decl-macros/minutiae/metavar-expr.md:16
#, fuzzy
msgid "[`${ignore(ident)}`](#ignoreident)"
msgstr "[${ignore(ident)}`](#ignoreident)"

#: src/decl-macros/minutiae/metavar-expr.md:18
#, fuzzy
msgid "Dollar Dollar (`$$`)"
msgstr "ドル ドル (`$$`)"

#: src/decl-macros/minutiae/metavar-expr.md:20
#, fuzzy
msgid ""
"The `$$` expression expands to a single `$`, making it effectively an "
"escaped `$`. This enables the ability in writing macros emitting new macros "
"as the former macro won't transcribe metavariables, repetitions and "
"metavariable expressions that have an escaped `$`."
msgstr ""
"式は1つの `$` に展開され、実質的にエスケープされた `$` になります。これによ"
"り、新しいマクロを生成するマクロを書く際に、以前のマクロはエスケープされた "
"`$`` を持つメタ変数、繰り返し、メタ変数式を転写しないので、この機能を使用する"
"ことができます。"

#: src/decl-macros/minutiae/metavar-expr.md:23
#, fuzzy
msgid "We can see the problem without using `$$` in the following snippet:"
msgstr "以下のスニペットでは、`$$`を使用せずに問題を見ることができます："

#: src/decl-macros/minutiae/metavar-expr.md:24
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro_rules! bar {\n"
"            ( $( $any:tt )* ) => { $( $any )* };\n"
"            // ^^^^^^^^^^^ error: attempted to repeat an expression "
"containing no syntax variables matched as repeating at this depth\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!();\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    () => {\n"
"        マクロルール!\n"
"            ( $( $any:tt )* ) => { $( $any )* }；\n"
"            // ^^^^^^^^ エラー: この深さで繰り返しとしてマッチする構文変数を"
"含まない式を繰り返そうとしました。\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:38
#, fuzzy
msgid ""
"The problem is obvious, the transcriber of foo sees a repetition and tries "
"to repeat it when transcribing, but there is no `$any` metavariable in its "
"scope causing it to fail. With `$$` we can get around this as the "
"transcriber of `foo` will no longer try to do the repetition.[^tt-$]"
msgstr ""
"この問題は明らかで、fooのトランスクライバーは繰り返しを認識し、それをトランス"
"クリプ ションするときに繰り返そうとしますが、そのスコープに`$any`メタ変数がな"
"いた め、失敗します。しかし、そのスコープには `$any` メタ変数がないので、失敗"
"します。"

#: src/decl-macros/minutiae/metavar-expr.md:41
#, fuzzy
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro_rules! bar {\n"
"            ( $$( $$any:tt )* ) => { $$( $$any )* };\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!();\n"
"bar!();\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(macro_metavar_expr)].\n"
"\n"
"macro_rules!\n"
"    () => {\n"
"        マクロルール\n"
"            ( $$( $$any:tt )* ) => { $$( $$any )* }；\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!\n"
"bar!\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:57
#, fuzzy
msgid ""
"Before `$$` occurs, users must resort to a tricky and not so well-known hack "
"to declare nested macros with repetitions [via using `$tt` like this]"
"(https://play.rust-lang.org/?"
"version=nightly&mode=debug&edition=2021&gist=9ce18fc79ce17c77d20e74f3c46ee13c)."
msgstr ""
"が発生する前に、繰り返しでネストされたマクロを宣言する[このように `$tt` を使"
"用する](https://play.rust-lang.org/?"
"version=nightly&mode=debug&edition=2021&gist=9ce18fc79ce17c77d20e74f3c46ee13c) "
"という、あまり知られていないトリッキーなハックに頼らなければなりません。"

#: src/decl-macros/minutiae/metavar-expr.md:60
#, fuzzy
msgid "`count(ident, depth)`"
msgstr "count(ident, depth)`"

#: src/decl-macros/minutiae/metavar-expr.md:62
#, fuzzy
msgid ""
"The `count` metavariable expression expands to the repetition count of the "
"metavariable `$ident` up to the given repetition depth."
msgstr ""
"メタ変数 `count` 式は、与えられた繰り返しの深さまでのメタ変数 `$ident` の繰り"
"返し回数に展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:64
#: src/decl-macros/minutiae/metavar-expr.md:167
#, fuzzy
msgid ""
"The `ident` argument must be a declared metavariable in the scope of the "
"rule."
msgstr ""
"引数 `ident` はルールのスコープ内で宣言されたメタ変数でなければなりません。"

#: src/decl-macros/minutiae/metavar-expr.md:65
#, fuzzy
msgid ""
"The `depth` argument must be an integer literal of value less or equal to "
"the maximum repetition depth that the `$ident` metavariable appears in."
msgstr ""
"引数 `depth` は `$ident` メタ変数が現れる最大の繰り返しの深さ以下の整数リテラ"
"ルでなければなりません。"

#: src/decl-macros/minutiae/metavar-expr.md:66
#: src/decl-macros/minutiae/metavar-expr.md:96
#: src/decl-macros/minutiae/metavar-expr.md:132
#, fuzzy
msgid "The expression expands to an unsuffixed integer literal token."
msgstr "式は固定されていない整数リテラル・トークンに展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:68
#, fuzzy
msgid ""
"The `count(ident)` expression defaults `depth` to the maximum valid depth, "
"making it count the total repetitions for the given metavariable."
msgstr ""
"count(ident)`式のデフォルトは `depth` で、指定されたメタ変数の繰り返し回数を"
"カウントします。"

#: src/decl-macros/minutiae/metavar-expr.md:70
#, fuzzy
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! foo {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        println!(\"count(outer, 0): $outer repeats {} times\", "
"${count(outer)});\n"
"        println!(\"count(inner, 0): The $inner repetition repeats {} times "
"in the outer repetition\", ${count(inner, 0)});\n"
"        println!(\"count(inner, 1): $inner repeats {} times in the inner "
"repetitions\", ${count(inner, 1)});\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    foo! {\n"
"        outer () ;\n"
"        outer ( inner , inner ) ;\n"
"        outer () ;\n"
"        outer ( inner ) ;\n"
"    };\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(macro_metavar_expr)].\n"
"\n"
"マクロルール！ foo {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ;* ) ) => {\n"
"        println!(\"count(outer, 0)：outerは{}回繰り返します\", "
"${count(outer)})；\n"
"        println!(\"count(inner, 0)：innerの繰り返しはouterの繰り返しで{}回繰"
"り返す\", ${count(inner, 0)})；\n"
"        println!(\"count(inner, 1)：内側の繰り返しで$innerは{}回繰り返す\", "
"${count(inner, 1)})；\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    foo！{\n"
"        outer () ；\n"
"        外側 ( 内側 , 内側 ) ；\n"
"        外側 () ；\n"
"        outer ( inner ) ；\n"
"    };\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:91
#, fuzzy
msgid "`index(depth)`"
msgstr "インデックス(深さ)"

#: src/decl-macros/minutiae/metavar-expr.md:93
#, fuzzy
msgid ""
"The `index(depth)` metavariable expression expands to the current iteration "
"index of the repetition at the given depth."
msgstr ""
"メタ変数 `index(depth)` 式は、与えられた深さの反復の現在の反復インデックスに"
"展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:95
#: src/decl-macros/minutiae/metavar-expr.md:131
#, fuzzy
msgid ""
"The `depth` argument targets the repetition at `depth` counting outwards "
"from the inner-most repetition where the expression is invoked."
msgstr ""
"depth` 引数は、その式が呼び出される一番内側の繰り返しから数えて `depth` 番目"
"の繰り返しを対象とします。"

#: src/decl-macros/minutiae/metavar-expr.md:98
#, fuzzy
msgid ""
"The `index()` expression defaults `depth` to `0`, making it a shorthand for "
"`index(0)`."
msgstr ""
"index()` 式は `depth` のデフォルトを `0` とし、`index(0)` の省略形となりま"
"す。"

#: src/decl-macros/minutiae/metavar-expr.md:100
#, fuzzy
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! attach_iteration_counts {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ( $(\n"
"            $((\n"
"                stringify!($inner),\n"
"                ${index(1)}, // this targets the outer repetition\n"
"                ${index()}  // and this, being an alias for `index(0)` "
"targets the inner repetition\n"
"            ),)*\n"
"        )* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let v = attach_iteration_counts! {\n"
"        ( hello ) ;\n"
"        ( indices , of ) ;\n"
"        () ;\n"
"        ( these, repetitions ) ;\n"
"    };\n"
"    println!(\"{v:?}\");\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(macro_metavar_expr)].\n"
"\n"
"マクロルール！ attach_iteration_counts {\n"
"    ( $( $( $inner:ident ),* ) ; )* ) => { ( $( $inner:ident ),* ) ; )* ) => "
"{ )\n"
"        ( $(\n"
"            $((\n"
"                stringify!\n"
"                ${index(1)}, // これは外側の繰り返しを対象とします。\n"
"                ${index()} // そして、これは `index(0)` のエイリアスであり、"
"内側の繰り返しを対象とします。\n"
"            ),)*\n"
"        )* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let v = attach_iteration_counts！{\n"
"        ( hello ) ；\n"
"        ( index , of ) ；\n"
"        () ;\n"
"        ( these, repetitions ) ；\n"
"    };\n"
"    println!(\"{v:?}\")；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:127
#, fuzzy
msgid "`length(depth)`"
msgstr "長さ(深さ)"

#: src/decl-macros/minutiae/metavar-expr.md:129
#, fuzzy
msgid ""
"The `length(depth)` metavariable expression expands to the iteration count "
"of the repetition at the given depth."
msgstr ""
"length(depth)`メタ変数式は、与えられた深さでの繰り返しの反復回数に展開されま"
"す。"

#: src/decl-macros/minutiae/metavar-expr.md:134
#, fuzzy
msgid ""
"The `length()` expression defaults `depth` to `0`, making it a shorthand for "
"`length(0)`."
msgstr "length()`式のデフォルトは `depth` で、`length(0)` の省略形です。"

#: src/decl-macros/minutiae/metavar-expr.md:137
#, fuzzy
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! lets_count {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        $(\n"
"            $(\n"
"                println!(\n"
"                    \"'{}' in inner iteration {}/{} with '{}' in outer "
"iteration {}/{} \",\n"
"                    stringify!($inner), ${index()}, ${length()},\n"
"                    stringify!($outer), ${index(1)}, ${length(1)},\n"
"                );\n"
"            )*\n"
"        )*\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    lets_count!(\n"
"        many (small , things) ;\n"
"        none () ;\n"
"        exactly ( one ) ;\n"
"    );\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(macro_metavar_expr)].\n"
"\n"
"マクロルール!\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => { $( $outer:ident "
"( $( $inner:ident ),* ) ; ) * ) => {\n"
"        $(\n"
"            $(\n"
"                println!\n"
"                    \"{}/{}の内部反復で'{}'、 {}/{}の外部反復で'{}'を \"、\n"
"                    stringify!($inner), ${index()}, ${length()}、\n"
"                    stringify!($outer), ${index(1)}, ${length(1)}、\n"
"                );\n"
"            )*\n"
"        )*\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    lets_count!\n"
"        many (small , things) ；\n"
"        none () ；\n"
"        exactly ( one ) ；\n"
"    );\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:163
#, fuzzy
msgid "`ignore(ident)`"
msgstr "ignore(ident)`。"

#: src/decl-macros/minutiae/metavar-expr.md:165
#, fuzzy
msgid ""
"The `ignore(ident)` metavariable expression expands to nothing, making it "
"possible to expand something as often as a metavariable repeats without "
"expanding the metavariable."
msgstr ""
"ignore(ident)`メタ変数式は何も展開しないので、メタ変数を展開することなく、メ"
"タ変数を繰り返すたびに何かを展開することができます。"

#: src/decl-macros/minutiae/metavar-expr.md:169
#, fuzzy
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! repetition_tuples {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ($(\n"
"            $(\n"
"                (\n"
"                    ${index()},\n"
"                    ${index(1)}\n"
"                    ${ignore(inner)} // without this metavariable "
"expression, compilation would fail\n"
"                ),\n"
"            )*\n"
"        )*)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let tuple = repetition_tuples!(\n"
"        ( one, two ) ;\n"
"        () ;\n"
"        ( one ) ;\n"
"        ( one, two, three ) ;\n"
"    );\n"
"    println!(\"{tuple:?}\");\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(macro_metavar_expr)].\n"
"\n"
"マクロルール!\n"
"    ( $( ( $inner:ident ),* ) ; )* ) => { ( $( $inner:ident ),* ) ) => {\n"
"        ($(\n"
"            $(\n"
"                (\n"
"                    ${index()},\n"
"                    ${index(1)}\n"
"                    ${ignore(inner)} // このメタ変数式がないとコンパイルに失"
"敗します。\n"
"                ),\n"
"            )*\n"
"        )*)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let tuple = repetition_tuples! (\n"
"        ( one, two ) ；\n"
"        () ;\n"
"        ( one ) ；\n"
"        ( one, two, three ) ；\n"
"    );\n"
"    println！(\"{tuple:?}\")；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/hygiene.md:3
#, fuzzy
msgid ""
"`macro_rules!` macros in Rust are _partially_ hygienic, also called mixed "
"hygiene. Specifically, they are hygienic when it comes to _local variables_, "
"_labels_ and `$crate`, but nothing else."
msgstr ""
"Rust の `macro_rules!` マクロは部分的にハイジェニックです。具体的には、"
"_local variables_, _labels_, `$crate` に関しては衛生的ですが、それ以外は衛生"
"的ではありません。"

#: src/decl-macros/minutiae/hygiene.md:6
#, fuzzy
msgid ""
"Hygiene works by attaching an invisible \"syntax context\" value to all "
"identifiers. When two identifiers are compared, _both_ the identifiers' "
"textual names _and_ syntax contexts must be identical for the two to be "
"considered equal."
msgstr ""
"Hygieneはすべての識別子に目に見えない \"シンタックスコンテキスト \"の値を付け"
"ることで機能します。2つの識別子が比較されるとき、2つが等しいとみなされるため"
"には、識別子のテキスト名と構文コンテキストの両方が同じでなければなりません。"

#: src/decl-macros/minutiae/hygiene.md:9
#, fuzzy
msgid "To illustrate this, consider the following code:"
msgstr "これを説明するために、次のコードを考えてみましょう："

#: src/decl-macros/minutiae/hygiene.md:13
#, fuzzy
msgid ""
"We will use the background colour to denote the syntax context. Now, let's "
"expand the macro invocation:"
msgstr ""
"背景色は構文コンテキストを表すために使用します。では、マクロを展開してみま"
"しょう："

#: src/decl-macros/minutiae/hygiene.md:18
#, fuzzy
msgid ""
"First, recall that `macro_rules!` invocations effectively _disappear_ during "
"expansion."
msgstr "まず、`macro_rules!"

#: src/decl-macros/minutiae/hygiene.md:20
#, fuzzy
msgid ""
"Second, if you attempt to compile this code, the compiler will respond with "
"something along the following lines:"
msgstr ""
"次に、このコードをコンパイルしようとすると、コンパイラーは次のような返答をし"
"ます："

#: src/decl-macros/minutiae/hygiene.md:22
#, fuzzy
msgid ""
"```text\n"
"error[E0425]: cannot find value `a` in this scope\n"
"  --> src/main.rs:13:21\n"
"   |\n"
"13 | let four = using_a!(a / 10);\n"
"   |                     ^ not found in this scope\n"
"```"
msgstr ""
"テキスト\n"
"error[E0425]: このスコープで値 `a` が見つかりません。\n"
"  --> src/main.rs:13:21\n"
"   |\n"
"13 | let four = using_a!(a / 10)；\n"
"   | このスコープでは見つかりません。\n"
"```"

#: src/decl-macros/minutiae/hygiene.md:30
#, fuzzy
msgid ""
"Note that the background colour (_i.e._ syntax context) for the expanded "
"macro _changes_ as part of expansion. Each `macro_rules!` macro expansion is "
"given a new, unique syntax context for its contents. As a result, there are "
"_two different `a`s_ in the expanded code: one in the first syntax context, "
"the second in the other. In other words, "
msgstr ""
"展開されたマクロの背景色(_i._構文コンテキスト)は展開の一部として変更されるこ"
"とに注意してください。各 `macro_rules!` マクロ展開には、その内容に対して新し"
"い一意の構文コンテキストが与えられます。その結果、展開されたコードには2つの異"
"なる `a`s_ が存在します。つまり"

#: src/decl-macros/minutiae/hygiene.md:33
#, fuzzy
msgid " is not the same identifier as "
msgstr "と同じ識別子ではありません。"

#: src/decl-macros/minutiae/hygiene.md:33
#, fuzzy
msgid ", however similar they may appear."
msgstr "どんなに似ていても。"

#: src/decl-macros/minutiae/hygiene.md:35
#, fuzzy
msgid ""
"That said, tokens that were substituted _into_ the expanded output _retain_ "
"their original syntax context (by virtue of having been provided to the "
"macro as opposed to being part of the macro itself). Thus, the solution is "
"to modify the macro as follows:"
msgstr ""
"とはいえ、展開された出力に置換されたトークンは、元の構文コンテキストを保持し"
"ます（マクロ自体の一部ではなく、マクロに提供されたという理由で）。したがっ"
"て、解決策はマクロを次のように変更することです："

#: src/decl-macros/minutiae/hygiene.md:40
#, fuzzy
msgid "Which, upon expansion becomes:"
msgstr "拡大するとこうなります："

#: src/decl-macros/minutiae/hygiene.md:44
#, fuzzy
msgid ""
"The compiler will accept this code because there is only one `a` being used."
msgstr "コンパイラーはこのコードを受け入れます。"

#: src/decl-macros/minutiae/hygiene.md:46
#, fuzzy
msgid "`$crate`"
msgstr ""
"善意のあるcrate作成者は、自分たちのコードが警告なしでビルドされることを保証し"
"たいと考えています。\n"
"そこで、彼らはcrateのルートに次のようなアノテーションを付けます："

#: src/decl-macros/minutiae/hygiene.md:48
#, fuzzy
msgid ""
"Hygiene is also the reason that we need the `$crate` metavariable when our "
"macro needs access to other items in the defining crate. What this special "
"metavariable does is that it expands to an absolute path to the defining "
"crate."
msgstr ""
"マクロが定義クレート内の他のアイテムにアクセスする必要があるときに `$crate` "
"メタ変数が必要になるのも、衛生上の理由からです。この特別なメタ変数は定義ク"
"レートへの絶対パスに展開されます。"

#: src/decl-macros/minutiae/hygiene.md:51
#, fuzzy
msgid ""
"```rust,ignore\n"
"//// Definitions in the `helper_macro` crate.\n"
"#[macro_export]\n"
"macro_rules! helped {\n"
"    // () => { helper!() } // This might lead to an error due to 'helper' "
"not being in scope.\n"
"    () => { $crate::helper!() }\n"
"}\n"
"\n"
"#[macro_export]\n"
"macro_rules! helper {\n"
"    () => { () }\n"
"}\n"
"\n"
"//// Usage in another crate.\n"
"// Note that `helper_macro::helper` is not imported!\n"
"use helper_macro::helped;\n"
"\n"
"fn unit() {\n"
"   // but it still works due to `$crate` properly expanding to the crate "
"path `helper_macro`\n"
"   helped!();\n"
"}\n"
"```"
msgstr ""
"ラスト,無視\n"
"//// helper_macro` クレートでの定義。\n"
"#マクロルール!\n"
"macro_rules!\n"
"    // () => { helper!() }.// これは、'helper' がスコープ内にないためにエラー"
"になるかもしれません。\n"
"    () => { $crate::helper!() } // これは、'helper' がスコープ内にないために"
"エラーになる可能性があります。\n"
"}\n"
"\n"
"#[macro_export］\n"
"マクロルール!\n"
"    () => { () }\n"
"}\n"
"\n"
"//// 別のクレートでの使用法。\n"
"// helper_macro::helper` はインポートされていないことに注意してください！\n"
"helper_macro::helped を使用してください；\n"
"\n"
"fn unit() {\n"
"   // しかし、`$crate` がクレートパス `helper_macro` に適切に展開されるため、"
"まだ動作します。\n"
"   help!\n"
"}\n"
"```"

#: src/decl-macros/minutiae/hygiene.md:74
#, fuzzy
msgid ""
"Note that, because `$crate` refers to the current crate, it must be used "
"with a fully qualified module path when referring to non-macro items:"
msgstr ""
"ただし、`$crate` は現在のクレートを参照するので、マクロ以外のアイテムを参照す"
"るときは、完全修飾されたモジュールパスとともに使用しなければならないことに注"
"意してください："

#: src/decl-macros/minutiae/hygiene.md:76
#, fuzzy
msgid ""
"```rust\n"
"pub mod inner {\n"
"    #[macro_export]\n"
"    macro_rules! call_foo {\n"
"        () => { $crate::inner::foo() };\n"
"    }\n"
"\n"
"    pub fn foo() {}\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"pub mod inner {\n"
"    #[macro_export］\n"
"    macro_rules!\n"
"        () => { $crate::inner::foo() }；\n"
"    }\n"
"\n"
"    pub fn foo() {}.\n"
"}\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:3
#, fuzzy
msgid ""
"There are two tokens which you are likely to run into eventually that _look_ "
"like identifiers, but aren't. Except when they are."
msgstr ""
"識別子のように見えるが、そうではない2つのトークンがあります。そうである場合を"
"除きます。"

#: src/decl-macros/minutiae/identifiers.md:6
#, fuzzy
msgid ""
"First is `self`. This is _very definitely_ a keyword. However, it also "
"happens to fit the definition of an identifier. In regular Rust code, "
"there's no way for `self` to be interpreted as an identifier, but it _can_ "
"happen with `macro_rules!` macros:"
msgstr ""
"まず、`self`です。これは間違いなくキーワードです。しかし、識別子の定義にも当"
"てはまります。通常のRustのコードでは、`self`を識別子として解釈することはでき"
"ませんが、`macro_rules!`マクロを使えば、`self`を識別子として解釈することがで"
"きます："

#: src/decl-macros/minutiae/identifiers.md:11
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! what_is {\n"
"    (self) => {\"the keyword `self`\"};\n"
"    ($i:ident) => {concat!(\"the identifier `\", stringify!($i), \"`\")};\n"
"}\n"
"\n"
"macro_rules! call_with_ident {\n"
"    ($c:ident($i:ident)) => {$c!($i)};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\", what_is!(self));\n"
"    println!(\"{}\", call_with_ident!(what_is(self)));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ what_is {\n"
"    (self) => {\"キーワード `self`\"}；\n"
"    ($i:ident) => {concat!(\"識別子 `\", stringify!($i), \"`\")}；\n"
"}\n"
"\n"
"マクロ規則 call_with_ident { ($c:ident($i)) => {concat!\n"
"    ($c:ident($i:ident)) => {$c!($i)}；\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\", what_is!(self))；\n"
"    println!(\"{}\", call_with_ident!(what_is(self)))；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:27
#, fuzzy
msgid "The above outputs:"
msgstr "上記の出力："

#: src/decl-macros/minutiae/identifiers.md:29
#, fuzzy
msgid ""
"```text\n"
"the keyword `self`\n"
"the keyword `self`\n"
"```"
msgstr ""
"テキスト\n"
"キーワード `self`\n"
"キーワード `self`\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:34
#, fuzzy
msgid ""
"But that makes no sense; `call_with_ident!` required an identifier, matched "
"one, and substituted it! So `self` is both a keyword and not a keyword at "
"the same time. You might wonder how this is in any way important. Take this "
"example:"
msgstr ""
"call_with_ident!`は識別子を必要とし、それにマッチして代入します！つまり、"
"`self`はキーワードであると同時にキーワードではないのです。これがどのように重"
"要なのか不思議に思うかもしれません。この例を見てください："

#: src/decl-macros/minutiae/identifiers.md:39
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! make_mutable {\n"
"    ($i:ident) => {let mut $i = $i;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_mutable!(self);\n"
"        self.0 *= 2;\n"
"        self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ make_mutable {\n"
"    ($i:ident) => {let mut $i = $i;}；\n"
"}\n"
"\n"
"struct Dummy(i32)；\n"
"\n"
"ダミー\n"
"    fn double(self) -> ダミー {.\n"
"        make_mutable!\n"
"        self.0 *= 2；\n"
"        self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"# println!(\"{:?}\", Dummy(4).double().0)；\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:59
#, fuzzy
msgid "This fails to compile with:"
msgstr "ではコンパイルに失敗します："

#: src/decl-macros/minutiae/identifiers.md:61
#, fuzzy
msgid ""
"```text\n"
"error: `mut` must be followed by a named binding\n"
" --> src/main.rs:2:24\n"
"  |\n"
"2 |     ($i:ident) => {let mut $i = $i;};\n"
"  |                        ^^^^^^ help: remove the `mut` prefix: `self`\n"
"...\n"
"9 |         make_mutable!(self);\n"
"  |         -------------------- in this macro invocation\n"
"  |\n"
"  = note: `mut` may be followed by `variable` and `variable @ pattern`\n"
"```"
msgstr ""
"テキスト\n"
"error: `mut` の後には名前付きバインディングが必要です。\n"
" --> src/main.rs:2:24\n"
"  |\n"
"2 | ($i:ident) => {let mut $i = $i;}；\n"
"  | ヘルプ: プレフィックス `mut` を削除します。\n"
"...\n"
"9 | make_mutable!\n"
"  | このマクロの呼び出しでは\n"
"  |\n"
"  = 注意: `mut` の後には `variable` や `variable @ pattern` を付けることがで"
"きます。\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:74
#, fuzzy
msgid ""
"So the macro will happily match `self` as an identifier, allowing you to use "
"it in cases where you can't actually use it. But, fine; it somehow remembers "
"that `self` is a keyword even when it's an identifier, so you _should_ be "
"able to do this, right?"
msgstr ""
"つまり、マクロは`self`を識別子として喜んでマッチさせ、実際には使えないケース"
"でも使えるようにします。self`は識別子であってもキーワードであることを記憶して"
"いるので、このようなことができるはずです。"

#: src/decl-macros/minutiae/identifiers.md:77
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! make_self_mutable {\n"
"    ($i:ident) => {let mut $i = self;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_self_mutable!(mut_self);\n"
"        mut_self.0 *= 2;\n"
"        mut_self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ make_self_mutable {\n"
"    ($i:ident) => {let mut $i = self;}；\n"
"}\n"
"\n"
"struct Dummy(i32)；\n"
"\n"
"ダミー\n"
"    fn double(self) -> ダミー { {.\n"
"        make_self_mutable!(mut_self)；\n"
"        mut_self.0 *= 2；\n"
"        mut_self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"# println!(\"{:?}\", Dummy(4).double().0)；\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:97
#, fuzzy
msgid "This fails with:"
msgstr "これは失敗です："

#: src/decl-macros/minutiae/identifiers.md:99
#, fuzzy
msgid ""
"```text\n"
"error[E0424]: expected value, found module `self`\n"
"  --> src/main.rs:2:33\n"
"   |\n"
"2  |       ($i:ident) => {let mut $i = self;};\n"
"   |                                   ^^^^ `self` value is a keyword only "
"available in methods with a `self` parameter\n"
"...\n"
"8  | /     fn double(self) -> Dummy {\n"
"9  | |         make_self_mutable!(mut_self);\n"
"   | |         ----------------------------- in this macro invocation\n"
"10 | |         mut_self.0 *= 2;\n"
"11 | |         mut_self\n"
"12 | |     }\n"
"   | |_____- this function has a `self` parameter, but a macro invocation "
"can only access identifiers it receives from parameters\n"
"   |\n"
"```"
msgstr ""
"テキスト\n"
"error[E0424]: 期待される値、見つかったモジュール `self`\n"
"  --> src/main.rs:2:33\n"
"   |\n"
"2 | ($i:ident) => {let mut $i = self;}；\n"
"   |^^ `self` 値は `self` パラメータを持つメソッドでのみ使用可能なキーワード"
"です。\n"
"...\n"
"8 | / fn double(self) -> ダミー {...\n"
"9 | | make_self_mutable!(mut_self)；\n"
"   | このマクロ呼び出しでは\n"
"10 | mut_self.0 *= 2；\n"
"11｜｜ mut_self\n"
"\n"
"   | この関数は `self` パラメータを持ちますが、マクロ呼び出しはパラメータから"
"受け取った識別子にしかアクセスできません。\n"
"   |\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:116
#, fuzzy
msgid ""
"Now the compiler thinks we refer to our module with `self`, but that doesn't "
"make sense. We already have a `self` right there, in the function signature "
"which is definitely not a module. It's almost like it's complaining that the "
"`self` it's trying to use isn't the _same_ `self`... as though the `self` "
"keyword has hygiene, like an... identifier."
msgstr ""
"self`でモジュールを参照しているとコンパイラーは考えますが、それは意味がありま"
"せん。関数のシグネチャにはすでに `self` がありますが、これは間違いなくモ"
"ジュールではありません。まるで、使おうとしている `self` が同じ `self` ではな"
"いことに文句を言っているようです... まるで `self` キーワードが識別子のように"
"衛生的であるかのように。"

#: src/decl-macros/minutiae/identifiers.md:120
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($body:expr) => {\n"
"        fn double(mut self) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {{\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ double_method {\n"
"    ($body:expr) => {\n"
"        fn double(mut self) -> ダミー { $body:expr\n"
"            ボディ\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32)；\n"
"\n"
"ダミー\n"
"    double_method！{{\n"
"        self.0 *= 2；\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"# println!(\"{:?}\", Dummy(4).double().0)；\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:143
#, fuzzy
msgid "Same error.  What about..."
msgstr "同じエラー。  では..."

#: src/decl-macros/minutiae/identifiers.md:145
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double(mut $self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {self, {\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double(mut $self_) -> ダミー {.\n"
"            ボディ\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32)；\n"
"\n"
"ダミー\n"
"    double_method！{self, {\n"
"        self.0 *= 2；\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"# println!(\"{:?}\", Dummy(4).double().0)；\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:168
#, fuzzy
msgid ""
"At last, _this works_. So `self` is both a keyword _and_ an identifier when "
"it feels like it. Surely this works for other, similar constructs, right?"
msgstr ""
"ついに、これが機能するようになりました。つまり、`self`はキーワードであると同"
"時に、その気になれば識別子にもなるのです。きっとこれは他の似たような構成要素"
"でも使えるんですよね？"

#: src/decl-macros/minutiae/identifiers.md:172
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double($self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {_, 0}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double($self_) -> ダミー { $body:expr\n"
"            ボディ\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32)；\n"
"\n"
"ダミー\n"
"    double_method！{_, 0}\n"
"}\n"
"#\n"
"# fn main() {\n"
"# println!(\"{:?}\", Dummy(4).double().0)；\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:192
#, fuzzy
msgid ""
"```text\n"
"error: no rules expected the token `_`\n"
"  --> src/main.rs:12:21\n"
"   |\n"
"1  | macro_rules! double_method {\n"
"   | -------------------------- when calling this macro\n"
"...\n"
"12 |     double_method! {_, 0}\n"
"   |                     ^ no rules expected this token in macro call\n"
"```"
msgstr ""
"テキスト\n"
"error: トークン `_` を期待するルールがありません。\n"
"  --> src/main.rs:12:21\n"
"   |\n"
"1 | macro_rules!\n"
"   | このマクロを呼び出すとき\n"
"...\n"
"12 | double_method！{_, 0}\n"
"   | ^ マクロ呼び出しでこのトークンを期待するルールはありません。\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:203
#, fuzzy
msgid ""
"No, of course not. `_` is a keyword that is valid in patterns and "
"expressions, but somehow _isn't_ an identifier like the keyword `self` is, "
"despite matching the definition of an identifier just the same."
msgstr ""
"いいえ、もちろん違います。キーワード `_` はパターンや式の中で有効なキーワード"
"ですが、キーワード `self` と同じように識別子の定義に合致しているにもかかわら"
"ず、なぜか識別子ではありません。"

#: src/decl-macros/minutiae/identifiers.md:206
#, fuzzy
msgid ""
"You might think you can get around this by using `$self_:pat` instead; that "
"way, `_` will match! Except, no, because `self` isn't a pattern. Joy."
msgstr ""
"代わりに `$self_:pat` を使えば、`_` はマッチします！なぜなら `self` はパター"
"ンではないからです。喜び。"

#: src/decl-macros/minutiae/identifiers.md:209
#, fuzzy
msgid ""
"The only work around for this (in cases where you want to accept some "
"combination of these tokens) is to use a [`tt`](./fragment-specifiers.md#tt) "
"matcher instead."
msgstr ""
"これを回避するには（これらのトークンの組み合わせを受け入れたい場合）、代わり"
"に[`tt`](./fragment-specifiers.md#tt)マッチャーを使うしかありません。"

#: src/decl-macros/minutiae/debugging.md:3
#, fuzzy
msgid ""
"**Note**: This is a list of debugging tools specifically tailored towards "
"declarative macros, additional means of debugging these can be found in the "
"[debugging chapter](../../syntax-extensions/debugging.md) of syntax "
"extensions."
msgstr ""
"**注意**：これは宣言的マクロに特化したデバッグツールのリストです。これらのデ"
"バッグの追加手段は、構文拡張の[デバッグの章](../../syntax-extensions/"
"debugging.md)にあります。"

#: src/decl-macros/minutiae/debugging.md:5
#, fuzzy
msgid ""
"One of the most useful is [`trace_macros!`](https://doc.rust-lang.org/std/"
"macro.trace_macros.html), which is a directive to the compiler instructing "
"it to dump every `macro_rules!` macro invocation prior to expansion. For "
"example, given the following:"
msgstr ""
"最も便利なものの1つは、[`trace_macros!`](https://doc.rust-lang.org/std/macro."
"trace_macros.html)です。これはコンパイラに対する指示で、展開する前に"
"`macro_rules!`マクロを呼び出すたびにダンプするように指示します。例えば、次の"
"ようにします："

#: src/decl-macros/minutiae/debugging.md:8
#, fuzzy
msgid ""
"```rust,ignore\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(trace_macros)]\n"
"\n"
"macro_rules! each_tt {\n"
"    () => {};\n"
"    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};\n"
"}\n"
"\n"
"each_tt!(foo bar baz quux);\n"
"trace_macros!(true);\n"
"each_tt!(spim wak plee whum);\n"
"trace_macros!(false);\n"
"each_tt!(trom qlip winp xod);\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト,無視\n"
"# // 注意: 必ずナイトリーチャンネルコンパイラを使用してください。\n"
"#![feature(trace_macros)].\n"
"\n"
"macro_rules!\n"
"    () => {};\n"
"    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);}；\n"
"}\n"
"\n"
"each_tt!(foo bar baz quux)；\n"
"trace_macros!(true)；\n"
"each_tt!(spim wak plee whum)；\n"
"trace_macros!(false)；\n"
"each_tt!(trom qlip winp xod)；\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/debugging.md:28
#, fuzzy
msgid ""
"```text\n"
"note: trace_macro\n"
"  --> src/main.rs:11:1\n"
"   |\n"
"11 | each_tt!(spim wak plee whum);\n"
"   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"   |\n"
"   = note: expanding `each_tt! { spim wak plee whum }`\n"
"   = note: to `each_tt ! (wak plee whum) ;`\n"
"   = note: expanding `each_tt! { wak plee whum }`\n"
"   = note: to `each_tt ! (plee whum) ;`\n"
"   = note: expanding `each_tt! { plee whum }`\n"
"   = note: to `each_tt ! (whum) ;`\n"
"   = note: expanding `each_tt! { whum }`\n"
"   = note: to `each_tt ! () ;`\n"
"   = note: expanding `each_tt! {  }`\n"
"   = note: to ``\n"
"```"
msgstr ""
"テキスト\n"
"note: trace_macro\n"
"  --> src/main.rs:11:1\n"
"   |\n"
"11 | each_tt!(spim wak plee whum)；\n"
"   \n"
"   |\n"
"   = 注：`each_tt！{ spim wak plee whum }`.\n"
"   = 注： `each_tt ！(wak plee whum) ;`)\n"
"   = note: `each_tt！(wak plee whum) }` = note: `each_tt!\n"
"   = note: to `each_tt ！(plee whum) ;`\n"
"   = note: `each_tt！(plee whum) }` = note: `each_tt!\n"
"   = note: to `each_tt ！(whum) ;`\n"
"   = note: `each_tt！(whum) ;` = note: `each_tt!\n"
"   = note: `each_tt ！() ;`\n"
"   = note: `each_tt！{ }`\n"
"   = note: ``へ\n"
"```"

#: src/decl-macros/minutiae/debugging.md:47
#, fuzzy
msgid ""
"This is _particularly_ invaluable when debugging deeply recursive "
"`macro_rules!` macros. You can also enable this from the command-line by "
"adding `-Z trace-macros` to the compiler command line."
msgstr ""
"これは特に再帰的な `macro_rules!` マクロをデバッグするときに非常に便利です。"
"また、コンパイラのコマンドラインに `-Z trace-macros` を追加することで、コマン"
"ドラインからこの機能を有効にすることもできます。"

#: src/decl-macros/minutiae/debugging.md:50
#, fuzzy
msgid ""
"Secondly, there is [`log_syntax!`](https://doc.rust-lang.org/std/macro."
"log_syntax.html) which causes the compiler to output all tokens passed to "
"it. For example, this makes the compiler sing a song:"
msgstr ""
"次に、[`log_syntax!`](https://doc.rust-lang.org/std/macro.log_syntax.html) が"
"あります。これはコンパイラに渡されたすべてのトークンを出力します。例えば、こ"
"れはコンパイラに歌を歌わせます："

#: src/decl-macros/minutiae/debugging.md:53
#, fuzzy
msgid ""
"```rust\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(log_syntax)]\n"
"\n"
"macro_rules! sing {\n"
"    () => {};\n"
"    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};\n"
"}\n"
"\n"
"sing! {\n"
"    ^ < @ < . @ *\n"
"    '\\x08' '{' '\"' _ # ' '\n"
"    - @ '$' && / _ %\n"
"    ! ( '\\t' @ | = >\n"
"    ; '\\x08' '\\'' + '$' ? '\\x7f'\n"
"    , # '\"' ~ | ) '\\x07'\n"
"}\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"# // 注意: 必ずナイトリーチャンネルコンパイラを使用してください。\n"
"#![feature(log_syntax)].\n"
"\n"
"macro_rules!\n"
"    () => {};\n"
"    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);}；\n"
"}\n"
"\n"
"を歌います！{\n"
"    ^ < @ < . @ *\n"
"    '\\x08' '{' '\"'_ # ' '\n"
"    - @ '$' && / _ %\n"
"    !( '\\t' @ | = >\n"
"    ; '\\x08' '\\''+ '$' ?'\\x7f'\n"
"    , # '\"'~ | )'\\x07'\n"
"}\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/debugging.md:74
#, fuzzy
msgid ""
"This can be used to do slightly more targeted debugging than [`trace_macros!"
"`](https://doc.rust-lang.org/std/macro.trace_macros.html)."
msgstr ""
"これは、[`trace_macros!`](https://doc.rust-lang.org/std/macro.trace_macros."
"html) よりも少し的を絞ったデバッグを行うために使うことができます。"

#: src/decl-macros/minutiae/debugging.md:76
#, fuzzy
msgid ""
"Another amazing tool is [`lukaslueg`'s](https://github.com/lukaslueg) "
"[`macro_railroad`](https://github.com/lukaslueg/macro_railroad), a tool that "
"allows you visualize and generate syntax diagrams for Rust's `macro_rules!` "
"macros. It visualizes the accepted macro's grammar as an automata."
msgstr ""
"もう一つの素晴らしいツールは、[`lukaslueg` さんの](https://github.com/"
"lukaslueg) [`macro_railroad`](https://github.com/lukaslueg/macro_railroad) で"
"す。これは、Rust の `macro_rules!` マクロの構文図を視覚化して生成できるツール"
"です。マクロの文法をオートマトンとして視覚化します。"

#: src/decl-macros/minutiae/scoping.md:3
#, fuzzy
msgid ""
"The way in which mbe macros are scoped can be somewhat unintuitive. They use "
"two forms of scopes: textual scope, and path-based scope."
msgstr ""
"mbeマクロのスコープは、やや直感的でない場合があります。テキストスコープとパス"
"ベースのスコープです。"

#: src/decl-macros/minutiae/scoping.md:6
#, fuzzy
msgid ""
"When such a macro is invoked by an unqualified identifier(an identifier that "
"isn't part of a multi-segment path), it is first looked up in textual "
"scoping and then in path-based scoping should the first lookup not yield any "
"results. If it is invoked by a qualified identifier it will skip the textual "
"scoping lookup and instead only do a look up in the path-based scoping."
msgstr ""
"このようなマクロが非修飾識別子 (マルチセグメントパスの一部ではない識別子) に"
"よって呼び出されると、最初にテキストスコープで検索され、最初の検索で結果が得"
"られない場合はパスベーススコープで検索されます。修飾された識別子で呼び出され"
"た場合は、テキストスコープでの検索はスキップされ、代わりにパスベーススコープ"
"での検索のみが行われます。"

#: src/decl-macros/minutiae/scoping.md:9
#, fuzzy
msgid "Textual Scope"
msgstr "テキストの範囲"

#: src/decl-macros/minutiae/scoping.md:11
#, fuzzy
msgid ""
"Firstly, unlike everything else in the language, function-like macros will "
"remain visible in sub-modules."
msgstr ""
"まず、他の言語とは異なり、関数に似たマクロはサブモジュールでも表示されたまま"
"になります。"

#: src/decl-macros/minutiae/scoping.md:13
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! X { () => {}; }\n"
"mod a {\n"
"    X!(); // defined\n"
"}\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules！X { () => {}; }\n"
"mod a {\n"
"    X!(); // 定義済み\n"
"}\n"
"mod b {\n"
"    X!(); // 定義済み\n"
"}\n"
"mod c {\n"
"    X!(); // 定義済み\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:27
#, fuzzy
msgid ""
"**Note**: In these examples, remember that all of them have the _same "
"behavior_ when the module contents are in separate files."
msgstr ""
"**注意**：これらの例では、モジュールの内容が別々のファイルにある場合、すべて"
"のモジュールが同じ動作をすることを覚えておいてください。"

#: src/decl-macros/minutiae/scoping.md:29
#, fuzzy
msgid ""
"Secondly, _also_ unlike everything else in the language, `macro_rules!` "
"macros are only accessible _after_ their definition. Also note that this "
"example demonstrates how `macro_rules!` macros do not \"leak\" out of their "
"defining scope:"
msgstr ""
"第二に、言語の他のすべてのものと違って、`macro_rules!また、この例は "
"`macro_rules!` マクロが定義されたスコープから「漏れる」ことがないことを示して"
"います："

#: src/decl-macros/minutiae/scoping.md:32
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"mod b {\n"
"    // X!(); // undefined\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    // X!(); // undefined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // X!(); // 未定義\n"
"}\n"
"mod b {\n"
"    // X!(); // 未定義\n"
"    macro_rules！X { () => {}; }\n"
"    X!(); // 定義済み\n"
"}\n"
"mod c { // X!\n"
"    // X!(); // 未定義\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:47
#, fuzzy
msgid ""
"To be clear, this lexical order dependency applies even if you move the "
"macro to an outer scope:"
msgstr ""
"はっきりさせておきたいのは、この字句の順序依存性は、マクロを外側のスコープに"
"移した場合でも適用されるということです："

#: src/decl-macros/minutiae/scoping.md:49
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => {}; }\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // X!(); // 未定義\n"
"}\n"
"macro_rules！X { () => {}; }\n"
"mod b { // X!\n"
"    X!(); // 定義済み\n"
"}\n"
"mod c {\n"
"    X!(); // 定義済み\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:63
#, fuzzy
msgid "However, this dependency _does not_ apply to macros themselves:"
msgstr "しかし、この依存関係はマクロ自体には適用されません："

#: src/decl-macros/minutiae/scoping.md:65
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => { Y!(); }; }\n"
"mod b {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // X!(); // 未定義\n"
"}\n"
"macro_rules！x { () => { y!(); }; }.\n"
"mod b {\n"
"    // X!(); // 定義されていますが、Y!\n"
"}\n"
"macro_rules！Y { () => {}; }\n"
"mod c {\n"
"    X!(); // 定義されており、Yも定義されています！\n"
"}\n"
"# fn main() {}.\n"
"```"

#: src/decl-macros/minutiae/scoping.md:80
#, fuzzy
msgid ""
"Defining `macro_rules!` macros multiple times is allowed and the most recent "
"declaration will simply shadow previous ones unless it has gone out of scope."
msgstr "マクロ `macro_rules!` マクロを複数回定義してもかまいません。"

#: src/decl-macros/minutiae/scoping.md:82
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! X { (1) => {}; }\n"
"X!(1);\n"
"macro_rules! X { (2) => {}; }\n"
"// X!(1); // Error: no rule matches `1`\n"
"X!(2);\n"
"\n"
"mod a {\n"
"    macro_rules! X { (3) => {}; }\n"
"    // X!(2); // Error: no rule matches `2`\n"
"    X!(3);\n"
"}\n"
"// X!(3); // Error: no rule matches `3`\n"
"X!(2);\n"
"\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules！X { (1) => {}; }\n"
"X!(1);\n"
"macro_rules！X { (2) => {}; }\n"
"// X!(1); // エラー: `1` にマッチするルールがありません。\n"
"X!(2);\n"
"\n"
"mod a {\n"
"    macro_rules！X { (3) => {}; }\n"
"    // X!(2); // エラー: `2` にマッチするルールがありません。\n"
"    X!(3);\n"
"}\n"
"// X!(3); // エラー: `3` にマッチするルールはありません。\n"
"X!(2);\n"
"\n"
"```"

#: src/decl-macros/minutiae/scoping.md:99
#, fuzzy
msgid ""
"`macro_rules!` macros can be exported from a module using the `#[macro_use]` "
"attribute. Using this on a module is similar to saying that you do not want "
"to have the module's macro's scope end with the module."
msgstr ""
"macro_rules!`マクロは `#[macro_use]` 属性を使用してモジュールからエクスポート"
"できます。これをモジュールで使用することは、モジュールのマクロのスコープをモ"
"ジュールで終わらせたくないということと同じです。"

#: src/decl-macros/minutiae/scoping.md:102
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // X!(); // 未定義\n"
"}\n"
"#[macro_use］\n"
"mod b {\n"
"    macro_rules！X { () => {}; }\n"
"    X!(); // 定義\n"
"}\n"
"mod c {\n"
"    X!(); // 定義済み\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:117
#, fuzzy
msgid ""
"Note that this can interact in somewhat bizarre ways due to the fact that "
"identifiers in a `macro_rules!` macro (including other macros) are only "
"resolved upon expansion:"
msgstr ""
"macro_rules!`マクロ（他のマクロも含む）内の識別子は展開時にしか解決されないた"
"め、多少奇妙な相互作用が起こる可能性があることに注意してください："

#: src/decl-macros/minutiae/scoping.md:119
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => { Y!(); }; }\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // X!(); // 未定義\n"
"}\n"
"#[macro_use］\n"
"mod b {\n"
"    macro_rules！x { () => { y!(); }; } // X!\n"
"    // X!(); // 定義されていますが、Y!\n"
"}\n"
"macro_rules！Y { () => {}; }\n"
"mod c {\n"
"    X!(); // 定義されており、Yも定義されています！\n"
"}\n"
"# fn main() {}.\n"
"```"

#: src/decl-macros/minutiae/scoping.md:135
#, fuzzy
msgid ""
"Another complication is that `#[macro_use]` applied to an `extern crate` "
"_does not_ behave this way: such declarations are effectively _hoisted_ to "
"the top of the module. Thus, assuming `X!` is defined in an external crate "
"called `macs`, the following holds:"
msgstr ""
"もう1つの複雑な点は、`#[macro_use]` を `extern crate` に適用した場合、このよ"
"うな動作はしません。したがって、`X!`が `macs` という外部クレートで定義されて"
"いると仮定すると、次のようになります："

#: src/decl-macros/minutiae/scoping.md:137
#, fuzzy
msgid ""
"```rust,ignore\n"
"mod a {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod b {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"#[macro_use] extern crate macs;\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆、無視\n"
"mod a {\n"
"    // X!(); // 定義されていますが、Y!\n"
"}\n"
"macro_rules！Y { () => {}; }\n"
"mod b {\n"
"    X!(); // 定義されており、Yも定義されています！\n"
"}\n"
"#macro_use] extern crate macs；\n"
"mod c {\n"
"    X!(); // 定義済み、Yも同様！\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:152
#, fuzzy
msgid ""
"Finally, note that these scoping behaviors apply to _functions_ as well, "
"with the exception of `#[macro_use]` (which isn't applicable):"
msgstr "ただし、`#[macro_use]`は例外です）："

#: src/decl-macros/minutiae/scoping.md:154
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! X {\n"
"    () => { Y!() };\n"
"}\n"
"\n"
"fn a() {\n"
"    macro_rules! Y { () => {\"Hi!\"} }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"    {\n"
"        assert_eq!(X!(), \"Hi!\");\n"
"        macro_rules! Y { () => {\"Bye!\"} }\n"
"        assert_eq!(X!(), \"Bye!\");\n"
"    }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"}\n"
"\n"
"fn b() {\n"
"    macro_rules! Y { () => {\"One more\"} }\n"
"    assert_eq!(X!(), \"One more\");\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     a();\n"
"#     b();\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules！X {\n"
"    () => { Y!() };\n"
"}\n"
"\n"
"fn a() {\n"
"    macro_rules！Y { () => {\"Hi!\"} }\n"
"    assert_eq!(X!(), \"Hi!\")；\n"
"    {\n"
"        assert_eq!(X!(), \"Hi!\")；\n"
"        macro_rules！Y { () => {\"Bye!\"} }\n"
"        assert_eq!(X!(), \"Bye!\")；\n"
"    }\n"
"    assert_eq!(X!(), \"Hi!\")；\n"
"}\n"
"\n"
"fn b() {\n"
"    macro_rules！Y { () => {\"もうひとつ\"}。}\n"
"    assert_eq!(X!(), \"One more\")；\n"
"}\n"
"#\n"
"# fn main() {\n"
"# a();\n"
"# b();\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/scoping.md:181
#, fuzzy
msgid ""
"These scoping rules are why a common piece of advice is to place all "
"`macro_rules!` macros which should be accessible \"crate wide\" at the very "
"top of your root module, before any other modules. This ensures they are "
"available _consistently_. This also applies to `mod` definitions for files, "
"as in:"
msgstr ""
"このようなスコープルールがあるため、一般的なアドバイスとして、\"crate wide "
"\"にアクセス可能なすべての `macro_rules!` マクロを、他のモジュールよりも先"
"に、ルートモジュールの最上位に置くことが推奨されています。こうすることで、安"
"定して利用できるようになります。これはファイルに対する `mod` の定義にも当ては"
"まります："

#: src/decl-macros/minutiae/scoping.md:185
#, fuzzy
msgid ""
"```rs\n"
"#[macro_use]\n"
"mod some_mod_that_defines_macros;\n"
"mod some_mod_that_uses_those_macros;\n"
"```"
msgstr ""
"``rs\n"
"#[macro_use]\n"
"mod some_mod_that_defines_macros；\n"
"mod some_mod_that_uses_those_macros；\n"
"```"

#: src/decl-macros/minutiae/scoping.md:191
#, fuzzy
msgid ""
"The order here is important, swap the declaration order and it won't compile."
msgstr "宣言の順番を入れ替えるとコンパイルできません。"

#: src/decl-macros/minutiae/scoping.md:193
#, fuzzy
msgid "Path-Based Scope"
msgstr "パスベースのスコープ"

#: src/decl-macros/minutiae/scoping.md:195
#, fuzzy
msgid ""
"By default, a `macro_rules!` macro has no path-based scope. However, if it "
"has the `#[macro_export]` attribute, then it is declared in the crate root "
"scope and can be referred to similar to how you refer to any other item. The "
"[Import and Export](./import-export.html) chapter goes more in-depth into "
"said attribute."
msgstr ""
"デフォルトでは、`macro_rules!しかし、`#[macro_export]`属性を持つ場合、木枠の"
"ルートスコープで宣言され、他のアイテムと同様に参照することができます。イン"
"ポートとエクスポート](./import-export.html)の章では、この属性についてさらに詳"
"しく説明しています。"

#: src/decl-macros/minutiae/import-export.md:3
#, fuzzy
msgid ""
"Importing `macro_rules!` macros differs between the two Rust Editions, 2015 "
"and 2018. It is recommended to read both parts nevertheless, as the 2018 "
"Edition can still use the constructs that are explained in the 2015 Edition."
msgstr ""
"macro_rules!`マクロのインポートは、2015と2018の2つのRust Editionで異なりま"
"す。とはいえ、2018 Editionでも2015 Editionで説明されているコンストラクトを使"
"用することができるので、両方のパートを読むことをお勧めします。"

#: src/decl-macros/minutiae/import-export.md:6
#, fuzzy
msgid "Edition 2015"
msgstr "2015年版"

#: src/decl-macros/minutiae/import-export.md:8
#, fuzzy
msgid ""
"In Edition 2015 you have to use the `#[macro_use]` attribute that has "
"already been introduced in the [scoping chapter](./scoping.md). This can be "
"applied to _either_ modules or external crates. For example:"
msgstr ""
"Edition 2015 では、[scoping chapter](./scoping.md) で既に紹介されている "
"`#[macro_use]` 属性を使用する必要があります。これはモジュールと外部クレートの"
"どちらにも適用できます。例えば"

#: src/decl-macros/minutiae/import-export.md:12
#, fuzzy
msgid ""
"```rust\n"
"#[macro_use]\n"
"mod macros {\n"
"    macro_rules! X { () => { Y!(); } }\n"
"    macro_rules! Y { () => {} }\n"
"}\n"
"\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"ラスト\n"
"#[macro_use]\n"
"MODマクロ\n"
"    macro_rules！x { () => { y!(); }.}\n"
"    macro_rules！Y { () => {} }\n"
"}\n"
"\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/import-export.md:24
#, fuzzy
msgid ""
"`macro_rules!` macros can be exported from the current crate using "
"`#[macro_export]`. Note that this _ignores_ all visibility."
msgstr ""
"macro_rules!`マクロは `#[macro_export]` を使用して現在のクレートからエクス"
"ポートできます。これはすべての可視性を無視することに注意してください。"

#: src/decl-macros/minutiae/import-export.md:27
#, fuzzy
msgid "Given the following definition for a library package `macs`:"
msgstr "ライブラリパッケージ `macs` の定義を以下に示します："

#: src/decl-macros/minutiae/import-export.md:29
#, fuzzy
msgid ""
"```rust,ignore\n"
"mod macros {\n"
"    #[macro_export] macro_rules! X { () => { Y!(); } }\n"
"    #[macro_export] macro_rules! Y { () => {} }\n"
"}\n"
"\n"
"// X! and Y! are *not* defined here, but *are* exported,\n"
"// despite `macros` being private.\n"
"```"
msgstr ""
"錆、無視\n"
"modマクロ{\n"
"    #[macro_export] macro_rules！x { () => { y!(); }.}\n"
"    #[macro_export] macro_rules！Y { () => {} }\n"
"}\n"
"\n"
"// X! と Y! はここでは *定義* されていませんが、*エクスポート* されていま"
"す、\n"
"// マクロはプライベートであるにもかかわらず。\n"
"```"

#: src/decl-macros/minutiae/import-export.md:39
#, fuzzy
msgid "The following code will work as expected:"
msgstr "以下のコードは期待通りに動作します："

#: src/decl-macros/minutiae/import-export.md:41
#, fuzzy
msgid ""
"```rust,ignore\n"
"X!(); // X is defined\n"
"#[macro_use] extern crate macs;\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"錆、無視\n"
"X!(); // Xは定義されています\n"
"#[macro_use] extern crate macs；\n"
"X!();\n"
"#\n"
"# fn main() [0］\n"
"```"

#: src/decl-macros/minutiae/import-export.md:49
#, fuzzy
msgid ""
"This works, as said in the [scoping chapter](./scoping.md), because "
"`#[macro_use]` works slightly different on extern crates, as it basically "
"_hoists_ the exported macros out of the crate to the top of the module."
msgstr ""
"これは[scoping chapter](./scoping.md)で述べられているように、`#[macro_use]`は"
"externクレートでは少し異なる働きをします。"

#: src/decl-macros/minutiae/import-export.md:51
#, fuzzy
msgid ""
"Note: you can _only_ `#[macro_use]` an external crate from the root module."
msgstr "注意: `#[macro_use]` はルートモジュールからしか使えません。"

#: src/decl-macros/minutiae/import-export.md:53
#, fuzzy
msgid ""
"Finally, when importing `macro_rules!` macros from an external crate, you "
"can control _which_ macros you import. You can use this to limit namespace "
"pollution, or to override specific macros, like so:"
msgstr ""
"最後に、外部クレートから `macro_rules!` マクロをインポートする場合、インポー"
"トするマクロを制御できます。これを使用して、名前空間の汚染を制限したり、特定"
"のマクロを上書きしたりすることができます："

#: src/decl-macros/minutiae/import-export.md:56
#, fuzzy
msgid ""
"```rust,ignore\n"
"// Import *only* the `X!` macro.\n"
"#[macro_use(X)] extern crate macs;\n"
"\n"
"// X!(); // X is defined, but Y! is undefined\n"
"\n"
"macro_rules! Y { () => {} }\n"
"\n"
"X!(); // X is defined, and so is Y!\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""
"ラスト,無視\n"
"// マクロ `X!\n"
"#macro_use(X)] extern crate macs；\n"
"\n"
"// X!(); // Xは定義されていますが、Y!\n"
"\n"
"macro_rules！Y { () => {} }\n"
"\n"
"X!(); // X は定義されており、Y も定義されています！\n"
"\n"
"fn main() [1］\n"
"```"

#: src/decl-macros/minutiae/import-export.md:69
#, fuzzy
msgid ""
"When exporting `macro_rules!` macros, it is often useful to refer to non-"
"macro symbols in the defining crate. Because crates can be renamed, there is "
"a special substitution variable available: [`$crate`](./hygiene.md#crate). "
"This will _always_ expand to an absolute path prefix to the containing crate "
"(_e.g._ `:: macs`)."
msgstr ""
"マクロの `macro_rules!` マクロをエクスポートするとき、定義している木枠の中の"
"マクロ以外のシンボルを参照すると便利なことがよくあります。クレートは名前を変"
"更することができるので、特別な置換変数が用意されています：[crate`](./hygiene."
"md#crate)。これは常に、含まれるクレートの絶対パスの接頭辞に展開されます（例："
"`:: macs`）。"

#: src/decl-macros/minutiae/import-export.md:73
#, fuzzy
msgid ""
"Note that unless your compiler version is >= 1.30, this does _not_ work for "
"`macro_rules!` macros, because `macro_rules!` macros do not interact with "
"regular name resolution in any way. Otherwise, you cannot use something like "
"`$crate::Y!` to refer to a particular macro within your crate. The "
"implication, combined with selective imports via `#[macro_use]` is that "
"there is currently _no way_ to guarantee any given macro will be available "
"when imported by another crate."
msgstr ""
"なぜなら、`macro_rules!そうでなければ、`$crate::Y!このことは、`#[macro_use]`"
"による選択的なインポートとの組み合わせにより、他の木枠でインポートされたとき"
"に、任意のマクロが使用可能であることを保証する方法は現在のところありません。"

#: src/decl-macros/minutiae/import-export.md:77
#, fuzzy
msgid ""
"It is recommended that you _always_ use absolute paths to non-macro names, "
"to avoid conflicts, _including_ names in the standard library."
msgstr ""
"標準ライブラリの名前も含め、コンフリクトを避けるため、マクロ以外の名前には常"
"に絶対パスを使用することをお勧めします。"

#: src/decl-macros/minutiae/import-export.md:81
#, fuzzy
msgid "Edition 2018"
msgstr "2018年版"

#: src/decl-macros/minutiae/import-export.md:83
#, fuzzy
msgid ""
"The 2018 Edition made our lives a lot easier when it comes to `macro_rules!` "
"macros. Why you ask? Quite simply because it managed to make them feel more "
"like proper items than some special thing in the language. What this means "
"is that we can properly import and use them in a namespaced fashion!"
msgstr ""
"2018年版では、`macro_rules!`マクロに関して、私たちの生活がとても楽になりまし"
"た。なぜかって？それは単純に、マクロを言語内の特別なものというよりも、適切な"
"アイテムのように感じられるようになったからです。これはどういうことかという"
"と、適切にインポートして名前空間付きで使えるようになったということです！"

#: src/decl-macros/minutiae/import-export.md:88
#, fuzzy
msgid ""
"So instead of using `#[macro_use]` to import every exported macro from a "
"crate into the global namespace we can now do the following:"
msgstr ""
"そのため、`#[macro_use]`を使用してクレートからエクスポートされたマクロをすべ"
"てグローバル名前空間にインポートする代わりに、次のようにすることができます："

#: src/decl-macros/minutiae/import-export.md:90
#, fuzzy
msgid ""
"```rs\n"
"use some_crate::some_macro;\n"
"\n"
"fn main() {\n"
"    some_macro!(\"hello\");\n"
"    // as well as\n"
"    some_crate::some_other_macro!(\"macro world\");\n"
"}\n"
"```"
msgstr ""
"``rs\n"
"some_crate::some_macro を使用します；\n"
"\n"
"fn main() {\n"
"    some_macro!(\"hello\")；\n"
"    // 同様に\n"
"    some_crate::some_other_macro!(\"マクロの世界\")；\n"
"}\n"
"```"

#: src/decl-macros/minutiae/import-export.md:100
#, fuzzy
msgid ""
"Unfortunately, this only applies for external crates, if you use "
"`macro_rules!` macros that you have defined in your own crate you are still "
"required to go with `#[macro_use]` on the defining modules. So scoping "
"applies there the same way as before as well."
msgstr ""
"残念ながら、これは外部クレートにのみ適用されます。自分のクレートで定義した "
"`macro_rules!` マクロを使用する場合は、定義モジュールで `#[macro_use]` を使用"
"する必要があります。そのため、スコープは以前と同じように適用されます。"

#: src/decl-macros/minutiae/import-export.md:103
#, fuzzy
msgid ""
"The `$crate` prefix works in this version for everything, macros and items "
"alike since this Edition came out with Rust 1.31."
msgstr ""
"接頭辞 `$crate` は、Rust 1.31 で登場したこのバージョンでは、マクロもアイテム"
"も、すべてに対して機能します。"

#: src/decl-macros/patterns.md:3
#, fuzzy
msgid "Parsing and expansion patterns."
msgstr "構文解析と展開パターン。"

#: src/decl-macros/patterns/callbacks.md:3
#, fuzzy
msgid ""
"Due to the order that macros are expanded in, it is (as of Rust 1.2) "
"impossible to pass information to a macro from the expansion of _another_ "
"macro:"
msgstr ""
"マクロの展開順のため、（Rust 1.2では）他のマクロの展開からマクロに情報を渡す"
"ことはできません："

#: src/decl-macros/patterns/callbacks.md:5
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! recognize_tree {\n"
"    (larch) => { println!(\"#1, the Larch.\") };\n"
"    (redwood) => { println!(\"#2, the Mighty Redwood.\") };\n"
"    (fir) => { println!(\"#3, the Fir.\") };\n"
"    (chestnut) => { println!(\"#4, the Horse Chestnut.\") };\n"
"    (pine) => { println!(\"#5, the Scots Pine.\") };\n"
"    ($($other:tt)*) => { println!(\"I don't know; some kind of birch maybe?"
"\") };\n"
"}\n"
"\n"
"macro_rules! expand_to_larch {\n"
"    () => { larch };\n"
"}\n"
"\n"
"fn main() {\n"
"    recognize_tree!(expand_to_larch!());\n"
"    // first expands to:  recognize_tree! { expand_to_larch ! (  ) }\n"
"    // and then:          println! { \"I don't know; some kind of birch "
"maybe?\" }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    (カラマツ) => { println!(\"#1、カラマツ。\") }；\n"
"    (redwood) => { println!(\"#2, the Mighty Redwood.\") }；\n"
"    (モミ) => { println!(\"#3, モミ。\") }；\n"
"    (chestnut) => { println!(\"#4、トチノキ。\") }；\n"
"    (pine) => { println!(\"#5, スコッツパイン\") }；\n"
"    ($($other:tt)*) => { println!(\"I don't know; some kind of birch maybe?"
"\") }；\n"
"}\n"
"\n"
"macro_rules!\n"
"    () => { カラマツ }；\n"
"}\n"
"\n"
"fn main() {\n"
"    recognize_tree!(expand_to_larch!())；\n"
"    // 最初の展開先：recognize_tree！{ expand_to_larch ！( ) }\n"
"    // そして: println！{白樺の一種かな？\"}\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:26
#, fuzzy
msgid "This can make modularizing macros very difficult."
msgstr "このため、マクロのモジュール化が非常に難しくなります。"

#: src/decl-macros/patterns/callbacks.md:28
#, fuzzy
msgid "An alternative is to use recursion and pass a callback:"
msgstr "再帰を使用してコールバックを渡す方法もあります："

#: src/decl-macros/patterns/callbacks.md:30
#, fuzzy
msgid ""
"```rust\n"
"// ...\n"
"\n"
"macro_rules! call_with_larch {\n"
"    ($callback:ident) => { $callback!(larch) };\n"
"}\n"
"\n"
"fn main() {\n"
"    call_with_larch!(recognize_tree);\n"
"    // first expands to:  call_with_larch! { recognize_tree }\n"
"    // then:              recognize_tree! { larch }\n"
"    // and finally:       println! { \"#1, the Larch.\" }\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"// ...\n"
"\n"
"マクロルール call_with_larch { ($callback:ident) => { $callback!\n"
"    ($callback:ident) => { $callback!(larch) }；\n"
"}\n"
"\n"
"fn main() {\n"
"    call_with_larch!(recognize_tree)；\n"
"    // 最初に次のように展開します: call_with_larch！{ recognize_tree } に展開"
"します。\n"
"    // その後：recognize_tree！{ larch } に展開します。\n"
"    // そして最後に: println！{\"#1、カラマツ\"}\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:45
#, fuzzy
msgid ""
"Using a `tt` repetition, one can also forward arbitrary arguments to a "
"callback."
msgstr ""
"tt` の繰り返しを使うと、任意の引数をコールバックに転送することもできます。"

#: src/decl-macros/patterns/callbacks.md:47
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! callback {\n"
"    ($callback:ident( $($args:tt)* )) => {\n"
"        $callback!( $($args)* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    callback!(callback(println(\"Yes, this *was* unnecessary.\")));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！コールバック {\n"
"    ($callback:ident( $($args:tt)* )) => {\n"
"        コールバック！( $($args)* ) )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    callback!(コールバック(println(\"はい、これは*不要でした。\")))；\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:59
#, fuzzy
msgid ""
"You can, of course, insert additional tokens in the arguments as needed."
msgstr "もちろん、必要に応じて引数にトークンを追加することもできます。"

#: src/decl-macros/patterns/tt-muncher.md:3
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! mixed_rules {\n"
"    () => {};\n"
"    (trace $name:ident; $($tail:tt)*) => {\n"
"        {\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"    (trace $name:ident = $init:expr; $($tail:tt)*) => {\n"
"        {\n"
"            let $name = $init;\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     let a = 42;\n"
"#     let b = \"Ho-dee-oh-di-oh-di-oh!\";\n"
"#     let c = (false, 2, 'c');\n"
"#     mixed_rules!(\n"
"#         trace a;\n"
"#         trace b;\n"
"#         trace c;\n"
"#         trace b = \"They took her where they put the crazies.\";\n"
"#         trace b;\n"
"#     );\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ mixed_rules {\n"
"    () => {};\n"
"    (trace $name:ident; $($tail:tt)*) => { { (trace $name:ident; $($tail:"
"tt)*) => *)\n"
"        {\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name)；\n"
"            mixed_rules!($($tail)*)；\n"
"        }\n"
"    };\n"
"    (trace $name:ident = $init:expr; $($tail:tt)*) => {.\n"
"        {\n"
"            let $name = $init；\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name)；\n"
"            mixed_rules!($($tail)*)；\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"# let a = 42；\n"
"# let b = \"ほーでぃーおーでぃーおー！\"；\n"
"# let c = (false, 2, 'c')；\n"
"# mixed_rules!\n"
"# trace a；\n"
"# trace b；\n"
"# trace c；\n"
"# trace b = \"They took her where they put the crazies.\"；\n"
"# trace b；\n"
"# );\n"
"# }\n"
"```"

#: src/decl-macros/patterns/tt-muncher.md:35
#, fuzzy
msgid ""
"This pattern is perhaps the _most powerful_ macro parsing technique "
"available, allowing one to parse grammars of significant complexity. "
"However, it can increase compile times if used excessively, so should be "
"used with care."
msgstr ""
"このパターンは、おそらく最も強力なマクロ解析手法であり、非常に複雑な文法を解"
"析することができます。しかし、過度に使用するとコンパイル時間が長くなる可能性"
"があるので、使用には注意が必要です。"

#: src/decl-macros/patterns/tt-muncher.md:39
#, fuzzy
msgid ""
"A _TT muncher_ is a recursive `macro_rules!` macro that works by "
"incrementally processing its input one step at a time. At each step, it "
"matches and removes (munches) some sequence of tokens from the start of its "
"input, generates some intermediate output, then recurses on the input tail."
msgstr ""
"TT muncher_ は再帰的な `macro_rules!` マクロです。各ステップで、入力の先頭か"
"らトークンのシーケンスをマッチして削除し (munches)、中間出力を生成し、入力の"
"末尾を再帰的に処理します。"

#: src/decl-macros/patterns/tt-muncher.md:42
#, fuzzy
msgid ""
"The reason for \"TT\" in the name specifically is that the unprocessed part "
"of the input is _always_ captured as `$($tail:tt)*`. This is done as a [`tt`]"
"(../minutiae/fragment-specifiers.html#tt) repetition is the only way to "
"_losslessly_ capture part of a macro's input."
msgstr ""
"TT \"が名前に含まれている理由は、入力の未処理の部分が常に `$($tail:tt)*` とし"
"てキャプチャされるからです。これは、[`tt`](../minutiae/fragment-specifiers."
"html#tt)の繰り返しが、マクロの入力の一部をロスなくキャプチャする唯一の方法だ"
"からです。"

#: src/decl-macros/patterns/tt-muncher.md:45
#, fuzzy
msgid ""
"The only hard restrictions on TT munchers are those imposed on the "
"`macro_rules!` macro system as a whole:"
msgstr ""
"TTマンチャーに対する唯一の厳しい制限は、`macro_rules!`マクロシステム全体に課"
"されるものです："

#: src/decl-macros/patterns/tt-muncher.md:47
#, fuzzy
msgid ""
"You can only match against literals and grammar constructs which can be "
"captured by `macro_rules!`."
msgstr ""
"マッチできるのは `macro_rules!` で捕捉できるリテラルと文法構文だけです。"

#: src/decl-macros/patterns/tt-muncher.md:48
#, fuzzy
msgid "You cannot match unbalanced groups."
msgstr "不均衡なグループにはマッチできません。"

#: src/decl-macros/patterns/tt-muncher.md:50
#, fuzzy
msgid ""
"It is important, however, to keep the macro recursion limit in mind. "
"`macro_rules!` does not have _any_ form of tail recursion elimination or "
"optimization. It is recommended that, when writing a TT muncher, you make "
"reasonable efforts to keep recursion as limited as possible. This can be "
"done by adding additional rules to account for variation in the input (as "
"opposed to recursion into an intermediate layer), or by making compromises "
"on the input syntax to make using standard repetitions more tractable."
msgstr ""
"しかし、マクロの再帰制限を念頭に置くことが重要です。macro_rules!`には、末尾再"
"帰の除去や最適化はありません。TTマンチャーを書くときには、再帰をできるだけ制"
"限するように合理的な努力をすることをお勧めします。これは、(中間層への再帰では"
"なく)入力のばらつきを考慮したルールを追加したり、標準的な繰り返しをより扱いや"
"すくするために入力構文を妥協したりすることで行うことができます。"

#: src/decl-macros/patterns/tt-muncher.md:57
#: src/decl-macros/patterns/internal-rules.md:84
#: src/decl-macros/patterns/push-down-acc.md:78
msgid "Performance"
msgstr "パフォーマンス"

#: src/decl-macros/patterns/tt-muncher.md:59
#, fuzzy
msgid ""
"TT munchers are inherently quadratic. Consider a TT muncher rule that "
"consumes one token tree and then recursively calls itself on the remaining "
"input. If it is passed 100 token trees:"
msgstr ""
"TTマンチャーは本質的に2次関数です。1つのトークンツリーを消費し、残りの入力に"
"対して再帰的に自分自身を呼び出すTTマンチャーのルールを考えてみましょう。100個"
"のトークンツリーが渡された場合"

#: src/decl-macros/patterns/tt-muncher.md:62
#, fuzzy
msgid "The initial invocation will match against all 100 token trees."
msgstr "最初の呼び出しは、100個のトークンツリーすべてに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:63
#, fuzzy
msgid "The first recursive invocation will match against 99 token trees."
msgstr "最初の再帰呼び出しは99個のトークンツリーに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:64
#, fuzzy
msgid "The next recursive invocation will match against 98 token trees."
msgstr "次の再帰呼び出しは、98個のトークンツリーに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:66
#, fuzzy
msgid ""
"And so on, down to 1. This is a classic quadratic pattern, and long inputs "
"can cause macro expansion to blow out compile times."
msgstr ""
"これは典型的な2次関数パターンであり、長い入力はマクロの展開によるコンパイル時"
"間の浪費を引き起こします。"

#: src/decl-macros/patterns/tt-muncher.md:69
#, fuzzy
msgid ""
"Try to avoid using TT munchers too much, especially with long inputs. The "
"default value of the `recursion_limit` attribute is a good sanity check; if "
"you have to exceed it, you might be heading for trouble."
msgstr ""
"特に長い入力では、TTマンチャーを使いすぎないようにしましょう。"
"recursion_limit`属性のデフォルト値は良いサニティチェックになります。"

#: src/decl-macros/patterns/tt-muncher.md:72
#, fuzzy
msgid ""
"If you have the choice between writing a TT muncher that can be called once "
"to handle multiple things, or a simpler macro that can be called multiple "
"times to handle a single thing, prefer the latter. For example, you could "
"change a macro that is called like this:"
msgstr ""
"複数のことを処理するために一度だけ呼び出せるTTマンチャーを書くか、一つのこと"
"を処理するために複数回呼び出せるより単純なマクロを書くか、どちらかを選べるの"
"であれば、後者を選びましょう。例えば、このように呼び出されるマクロを変更する"
"ことができます："

#: src/decl-macros/patterns/tt-muncher.md:74
#, fuzzy
msgid ""
"```rust\n"
"# macro_rules! f { ($($tt:tt)*) => {} }\n"
"f! {\n"
"    fn f_u8(x: u32) -> u8;\n"
"    fn f_u16(x: u32) -> u16;\n"
"    fn f_u32(x: u32) -> u32;\n"
"    fn f_u64(x: u64) -> u64;\n"
"    fn f_u128(x: u128) -> u128;\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"# macro_rules! f { ($($tt:tt)*) => {} }.\n"
"f!{\n"
"    fn f_u8(x: u32) -> u8；\n"
"    fn f_u16(x: u32) -> u16；\n"
"    fn f_u32(x: u32) -> u32；\n"
"    fn f_u64(x: u64) -> u64；\n"
"    fn f_u128(x: u128) -> u128；\n"
"}\n"
"```"

#: src/decl-macros/patterns/tt-muncher.md:84
#, fuzzy
msgid "To one that is called like this:"
msgstr "こう呼ばれるものに："

#: src/decl-macros/patterns/tt-muncher.md:85
#, fuzzy
msgid ""
"```rust\n"
"# macro_rules! f { ($($tt:tt)*) => {} }\n"
"f! { fn f_u8(x: u32) -> u8; }\n"
"f! { fn f_u16(x: u32) -> u16; }\n"
"f! { fn f_u32(x: u32) -> u32; }\n"
"f! { fn f_u64(x: u64) -> u64; }\n"
"f! { fn f_u128(x: u128) -> u128; }\n"
"```"
msgstr ""
"ラスト\n"
"# macro_rules! f { ($($tt:tt)*) => {} }.\n"
"f!{ fn f_u8(x: u32) -> u8; } f!\n"
"f!{ fn f_u16(x: u32) -> u16; } f!\n"
"f!{ fn f_u32(x: u32) -> u32; } f!\n"
"f!{ fn f_u64(x: u64) -> u64; } f!\n"
"f!{ fn f_u128(x: u128) -> u128; } f!\n"
"```"

#: src/decl-macros/patterns/tt-muncher.md:93
#, fuzzy
msgid "The longer the input, the more likely this will improve compile times."
msgstr ""
"入力が長ければ長いほど、コンパイル時間が短縮される可能性が高くなります。"

#: src/decl-macros/patterns/tt-muncher.md:95
#, fuzzy
msgid ""
"Also, if a TT muncher macro has many rules, put the most frequently matched "
"rules as early as possible. This avoids unnecessary matching failures. (In "
"fact, this is good advice for any kind of declarative macro, not just TT "
"munchers.)"
msgstr ""
"また、TT マンチャー マクロに多くのルールがある場合、最も頻繁にマッチするルー"
"ルをできるだけ早い段階で配置します。これにより、不必要なマッチングの失敗を避"
"けることができます。(実際、これは TT マンチャーだけでなく、どのような種類の宣"
"言型マクロにも良いアドバイスです)。"

#: src/decl-macros/patterns/tt-muncher.md:100
#, fuzzy
msgid ""
"Finally, if you can write a macro using normal repetition via `*` or `+`, "
"that should be preferred to a TT muncher. This is most likely if each "
"invocation of the TT muncher would only process one token at a time. In more "
"complicated cases, there is an advanced technique used within the `quote` "
"crate that can avoid the quadratic behaviour, at the cost of some conceptual "
"complexity. See [this comment](https://github.com/dtolnay/quote/"
"blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746) for "
"details."
msgstr ""
"最後に、もし `*` や `+` を使った通常の繰り返しでマクロを書けるのであれば、TT"
"マンチャーよりもそちらを使うことをお勧めします。これは、TTマンチャーの各呼び"
"出しが一度に1つのトークンしか処理しない場合に最も適しています。より複雑なケー"
"スでは、`quote`クレート内で使用される高度なテクニックがあります。詳細は[この"
"コメント](https://github.com/dtolnay/quote/"
"blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746)を参照して"
"ください。"

#: src/decl-macros/patterns/internal-rules.md:3
#: src/decl-macros/patterns/internal-rules.md:53
#, fuzzy
msgid ""
"```rust\n"
"#[macro_export]\n"
"macro_rules! foo {\n"
"    (@as_expr $e:expr) => {$e};\n"
"\n"
"    ($($tts:tt)*) => {\n"
"        foo!(@as_expr $($tts)*)\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(foo!(42), 42);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"#[macro_export]\n"
"macro_rules!\n"
"    (@as_expr $e:expr) => {$e}；\n"
"\n"
"    ($($tts:tt)*) => { { foo!\n"
"        foo！(@as_expr $($tts)*)\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(foo!(42), 42)；\n"
"# }\n"
"```"

#: src/decl-macros/patterns/internal-rules.md:18
#, fuzzy
msgid ""
"Internal rules can be used to unify multiple `macro_rules!` macros into one, "
"or to make it easier to read and write [TT Munchers](./tt-muncher.html) by "
"explicitly naming what rule you wish to call in a macro."
msgstr ""
"内部ルールは、複数の `macro_rules!` マクロを一つにまとめたり、マクロの中で呼"
"び出したいルールを明示的に指定することで、[TT Munchers](./tt-muncher.html) の"
"読み書きを簡単にするために使うことができます。"

#: src/decl-macros/patterns/internal-rules.md:20
#, fuzzy
msgid ""
"So why is it useful to unify multiple macros-by-example into one? The main "
"reasoning for this is how they are handled in the 2015 Edition of Rust due "
"to `macro_rules!` macros not being namespaced in said edition. This gives "
"one the troubles of having to re-export all the internal `macro_rules!` "
"macros as well as polluting the global macro namespace or even worse, macro "
"name collisions with other crates. In short, it's quite a hassle. This "
"fortunately isn't really a problem anymore nowadays with a rustc version >= "
"1.30, for more information consult the [Import and Export chapter](../"
"minutiae/import-export.html)."
msgstr ""
"では、なぜ複数のマクロを1つに統一するのが便利なのでしょうか？その主な理由は、"
"Rustの2015年版では `macro_rules!` マクロが名前空間化されていないため、これら"
"のマクロがどのように扱われるかにあります。このため、内部の `macro_rules!` マ"
"クロをすべて再エクスポートしなければならないだけでなく、グローバルなマクロ名"
"前空間を汚染したり、さらに悪いことに他のクレートとマクロ名が衝突したりすると"
"いうトラブルが発生します。要するに、かなり面倒なのです。幸いなことに、rustcの"
"バージョンが1.30以上であれば、この問題はなくなりました。詳しくは[インポートと"
"エクスポートの章](../minutiae/import-export.html)を参照してください。"

#: src/decl-macros/patterns/internal-rules.md:26
#, fuzzy
msgid ""
"Nevertheless, let's talk about how we can unify multiple `macro_rules!` "
"macros into one with this technique and what exactly this technique even is."
msgstr ""
"とはいえ、このテクニックを使えば、複数の `macro_rules!` マクロをひとつに統合"
"することができます。"

#: src/decl-macros/patterns/internal-rules.md:28
#, fuzzy
msgid ""
"We have two `macro_rules!` macros, the common [`as_expr!` macro](../building-"
"blocks/ast-coercion.html) and a `foo` macro that makes use of the first one:"
msgstr ""
"2つの `macro_rules!` マクロ、一般的な [`as_expr!` マクロ](../building-blocks/"
"ast-coercion.html) と、最初のマクロを利用する `foo` マクロがあります："

#: src/decl-macros/patterns/internal-rules.md:30
#, fuzzy
msgid ""
"```rust\n"
"#[macro_export]\n"
"macro_rules! as_expr { ($e:expr) => {$e} }\n"
"\n"
"#[macro_export]\n"
"macro_rules! foo {\n"
"    ($($tts:tt)*) => {\n"
"        as_expr!($($tts)*)\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(foo!(42), 42);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"#[macro_export]\n"
"macro_rules! as_expr { ($e:expr) => {$e} }.\n"
"\n"
"#[macro_export]\n"
"macro_rules!\n"
"    ($($tts:tt)*) => { { {$e} } #[マクロ_エクスポート] macro_rules!\n"
"        as_expr!\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(foo!(42), 42)；\n"
"# }\n"
"```"

#: src/decl-macros/patterns/internal-rules.md:46
#, fuzzy
msgid ""
"This is definitely not the nicest solution we could have for this macro, as "
"it pollutes the global macro namespace as mentioned earlier. In this "
"specific case `as_expr` is also a very simple macro that we only used once, "
"so let's \"embed\" this macro in our `foo` macro with internal rules! To do "
"so, we simply prepend a new matcher for our macro, which consists of the "
"matcher used in the `as_expr` macro, but with a small addition. We prepend a "
"tokentree that makes it match only when specifically asked to. In this case "
"we can for example use `@as_expr`, so our matcher becomes `(@as_expr $e:"
"expr) => {$e};`. With this we get the macro that was defined at the very top "
"of this page:"
msgstr ""
"このマクロはグローバルマクロの名前空間を汚染してしまうので、このマクロのため"
"の最も良い解決策ではありません。この特定のケースでは `as_expr` も一度しか使用"
"しない非常に単純なマクロなので、このマクロを内部ルールで `foo` マクロに \"埋"
"め込み\" ましょう！このマクロは `as_expr` マクロで使用されているマッチャーを"
"少し追加したものです。これは `as_expr` マクロで使用されている matcher から構"
"成されていますが、少し追加されています。特に要求された場合にのみマッチするよ"
"うにトークンツリーを追加しています。この場合、例えば `@as_expr` を使うことが"
"できるので、マッチャーは `(@as_expr $e:expr) => {$e};` となります。これで、こ"
"のページの一番上で定義したマクロが得られます："

#: src/decl-macros/patterns/internal-rules.md:68
#, fuzzy
msgid ""
"You see how we embedded the `as_expr` macro in the `foo` one? All that "
"changed is that instead of invoking the `as_expr` macro, we now invoke `foo` "
"recursively but with a special token tree prepended to the arguments, `foo!"
"(@as_expr $($tts)*)`. If you look closely you might even see that this "
"pattern can be combined quite nicely with [TT Munchers](./tt-muncher.html)!"
msgstr ""
"foo`マクロの中に `as_expr` マクロを埋め込んだのがわかりますか？変更されたの"
"は `as_expr` マクロを呼び出す代わりに `foo` を再帰的に呼び出すようになっただ"
"けです。よく見ると、このパターンは[TT Munchers](./tt-muncher.html)とうまく組"
"み合わせることができます！"

#: src/decl-macros/patterns/internal-rules.md:72
#, fuzzy
msgid ""
"The reason for using `@` was that, as of Rust 1.2, the `@` token is _not_ "
"used in prefix position; as such, it cannot conflict with anything. This "
"reasoning became obsolete later on when in Rust 1.7 macro matchers got "
"future proofed by emitting a warning to prevent certain tokens from being "
"allowed to follow certain fragments[^ambiguity-restrictions], which in Rust "
"1.12 became a hard-error. Other symbols or unique prefixes may be used as "
"desired, but use of `@` has started to become widespread, so using it may "
"aid readers in understanding your macro."
msgstr ""
"を使用する理由は、Rust 1.2 では `@` トークンはプレフィックスの位置では使用さ"
"れないからです。この理由は、Rust 1.7 のマクロマッチで、特定のトークンが特定の"
"フラグメント[^ambiguity-restrictions]に続くことを許可しないように警告を出すよ"
"うになり、それが Rust 1.12 でハードエラーになったため、後に時代遅れになりまし"
"た。他のシンボルやユニークな接頭辞を使用することもできますが、 `@` の使用が普"
"及し始めているので、これを使用することで読者があなたのマクロを理解する助けに"
"なるかもしれません。"

#: src/decl-macros/patterns/internal-rules.md:76
#, fuzzy
msgid "[ambiguity-restrictions](../minutiae/metavar-and-expansion.html)"
msgstr "[曖昧さ制限](../minutiae/metavar-and-expansion.html)"

#: src/decl-macros/patterns/internal-rules.md:78
#, fuzzy
msgid ""
"**Note**: in the early days of Rust the `@` token was previously used in "
"prefix position to denote a garbage-collected pointer, back when the "
"language used sigils to denote pointer types. Its only _current_ purpose is "
"for binding names to patterns. For this, however, it is used as an _infix_ "
"operator, and thus does not conflict with its use here."
msgstr ""
"*注***: Rustの初期の頃、`@` トークンはガベージコレクションポインタを示すため"
"にプレフィックスの位置で使われていました。現在の唯一の用途は、名前をパターン"
"にバインドすることです。しかし、これは_infix_演算子として使用されるため、ここ"
"での使用と衝突することはありません。"

#: src/decl-macros/patterns/internal-rules.md:82
#, fuzzy
msgid ""
"Additionally, internal rules will often come _before_ any \"bare\" rules, to "
"avoid issues with `macro_rules!` incorrectly attempting to parse an internal "
"invocation as something it cannot possibly be, such as an expression."
msgstr "さらに、`macro_rules!"

#: src/decl-macros/patterns/internal-rules.md:86
#, fuzzy
msgid ""
"One downside of internal rules is that they can hurt compile times. Only one "
"macro rule can match any (valid) macro invocation, but the compiler must try "
"to match all rules in order. If a macro has many rules, there can be many "
"such failures, and the use of internal rules will increase the number of "
"such failures."
msgstr ""
"内部ルールの欠点は、コンパイル時間が長くなることです。有効な）マクロ呼び出し"
"に一致するマクロ ルールは 1 つだけですが、コンパイラはすべてのルールを順番に"
"一致させようとします。マクロに多くのルールがある場合、このような失敗が多数発"
"生する可能性があり、内部ルールを使用するとこのような失敗の数が増えます。"

#: src/decl-macros/patterns/internal-rules.md:90
#, fuzzy
msgid ""
"Also, the `@as_expr`\\-style identifier makes rules longer, slightly "
"increasing the amount of work the compiler must do when matching."
msgstr ""
"また、`@as_expr`スタイルの識別子はルールを長くし、マッチング時にコンパイラが"
"行わなければならない作業量を少し増やします。"

#: src/decl-macros/patterns/internal-rules.md:93
#, fuzzy
msgid ""
"Therefore, for best performance, avoiding internal rules is best. Avoiding "
"them often makes complex macros easier to read, too."
msgstr ""
"したがって、最高のパフォーマンスを得るためには、内部ルールを避けるのが最善で"
"す。内部ルールを避けると、複雑なマクロも読みやすくなります。"

#: src/decl-macros/patterns/push-down-acc.md:3
#, fuzzy
msgid "The following macro uses _push-down accumulation_."
msgstr "以下のマクロは_push-down accumulation_を使用しています。"

#: src/decl-macros/patterns/push-down-acc.md:5
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! init_array {\n"
"    [$e:expr; $n:tt] => { \n"
"        {   \n"
"            let e = $e; \n"
"            accum!([$n, e.clone()] -> [])\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules! accum {\n"
"    ([3, $e:expr] -> [$($body:tt)*]) => { accum!([2, $e] -> [$($body)* "
"$e,]) };\n"
"    ([2, $e:expr] -> [$($body:tt)*]) => { accum!([1, $e] -> [$($body)* "
"$e,]) };\n"
"    ([1, $e:expr] -> [$($body:tt)*]) => { accum!([0, $e] -> [$($body)* "
"$e,]) };\n"
"    ([0, $_:expr] -> [$($body:tt)*]) => { [$($body)*] };\n"
"}\n"
"\n"
"let strings: [String; 3] = init_array![String::from(\"hi!\"); 3];\n"
"# assert_eq!(format!(\"{:?}\", strings), \"[\\\"hi!\\\", \\\"hi!\\\", \\\"hi!"
"\\\"]\");\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ init_array { [$e:expr; $n:tt\n"
"    [$e:expr; $n:tt] => {\n"
"        {\n"
"            let e = $e；\n"
"            accum!([$n, e.clone()] -> [])\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules!\n"
"    ([3, $e:expr] -> [$($body:tt)*]) => { accum!([2, $e] -> [$($body)* "
"$e,])};\n"
"    ([2, $e:expr] -> [$($body:tt)*]) => { accum!([1, $e] -> [$($body)* "
"$e,]) }; { accum!};\n"
"    ([1, $e:expr] -> [$($body:tt)*]) => { accum!([0, $e] -> [$($body)* "
"$e,]) }; { accum!};\n"
"    ([0, $_:expr] -> [$($body:tt)*]) => { [$($body)*] }；\n"
"}\n"
"\n"
"文字列：[文字列; 3] = init_array![String::from(\"hi!\"); 3]；\n"
"# assert_eq!(format!(\"{:?}\", strings), \"[ \\\"hi!）\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:25
#, fuzzy
msgid ""
"All syntax extensions in Rust **must** result in a complete, supported "
"syntax element (such as an expression, item, _etc._). This means that it is "
"impossible to have a syntax extension expand to a partial construct."
msgstr ""
"Rustのすべての構文拡張は、サポートされる完全な構文要素（式、アイテム、_etc.）"
"つまり、構文拡張を部分的な構成要素に展開することはできません。"

#: src/decl-macros/patterns/push-down-acc.md:28
#, fuzzy
msgid ""
"One might hope that the above example could be more directly expressed like "
"so:"
msgstr "上記の例をもっと直接的に表現することができればと思うかもしれません："

#: src/decl-macros/patterns/push-down-acc.md:30
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! init_array {\n"
"    [$e:expr; $n:tt] => {\n"
"        {\n"
"            let e = $e;\n"
"            [accum!($n, e.clone())]\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules! accum {\n"
"    (3, $e:expr) => { $e, accum!(2, $e) };\n"
"    (2, $e:expr) => { $e, accum!(1, $e) };\n"
"    (1, $e:expr) => { $e };\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"マクロルール！ init_array { { [$e:expr; $n:tt\n"
"    [$e:expr; $n:tt] => {\n"
"        {\n"
"            let e = $e；\n"
"            [accum!($n, e.clone())]。\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules!\n"
"    (3, $e:expr) => { $e, accum!(2, $e) }；\n"
"    (2, $e:expr) => { $e, accum!(1, $e) }；\n"
"    (1, $e:expr) => { $e }；\n"
"}\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:46
#, fuzzy
msgid ""
"The expectation is that the expansion of the array literal would proceed as "
"follows:"
msgstr "期待されるのは、配列リテラルの展開が次のように進むことです："

#: src/decl-macros/patterns/push-down-acc.md:48
#, fuzzy
msgid ""
"```rust,ignore\n"
"    [accum!(3, e.clone())]\n"
"    [e.clone(), accum!(2, e.clone())]\n"
"    [e.clone(), e.clone(), accum!(1, e.clone())]\n"
"    [e.clone(), e.clone(), e.clone()]\n"
"```"
msgstr ""
"ラスト,無視\n"
"    [accum!(3, e.clone())].\n"
"    [e.clone(), accum!(2, e.clone())].\n"
"    [e.clone(), e.clone(), accum!(1, e.clone())].\n"
"    [e.clone(), e.clone(), e.clone()].\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:55
#, fuzzy
msgid ""
"However, this would require each intermediate step to expand to an "
"incomplete expression. Even though the intermediate results will never be "
"used _outside_ of a macro context, it is still forbidden."
msgstr ""
"しかし、この場合、各中間ステップを不完全な式に展開する必要があります。中間結"
"果はマクロコンテキスト以外で使用されることはありませんが、それでも禁止されて"
"います。"

#: src/decl-macros/patterns/push-down-acc.md:58
#, fuzzy
msgid ""
"Push-down, however, allows us to incrementally build up a sequence of tokens "
"without needing to actually have a complete construct at any point prior to "
"completion. In the example given at the top, the sequence of invocations "
"proceeds as follows:"
msgstr ""
"しかし、プッシュダウンでは、完了する前のどの時点でも、実際に完全なコンストラ"
"クトを持っている必要はなく、トークンのシーケンスをインクリメンタルに構築する"
"ことができます。冒頭の例では、呼び出しのシーケンスは次のように進みます："

#: src/decl-macros/patterns/push-down-acc.md:61
#, fuzzy
msgid ""
"```rust,ignore\n"
"init_array!(String::from(\"hi!\"); 3)\n"
"accum!([3, e.clone()] -> [])\n"
"accum!([2, e.clone()] -> [e.clone(),])\n"
"accum!([1, e.clone()] -> [e.clone(), e.clone(),])\n"
"accum!([0, e.clone()] -> [e.clone(), e.clone(), e.clone(),])\n"
"[e.clone(), e.clone(), e.clone(),]\n"
"```"
msgstr ""
"錆、無視\n"
"init_array!(String::from(\"hi!\"); 3)\n"
"accum!([3, e.clone()] -> [])\n"
"accum!([2, e.clone()] -> [e.clone(),])\n"
"accum!([1, e.clone()] -> [e.clone(), e.clone(),])\n"
"accum!([0, e.clone()] -> [e.clone(), e.clone(),])\n"
"[e.clone(), e.clone(), e.clone(),])\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:70
#, fuzzy
msgid ""
"As you can see, each layer adds to the accumulated output until the "
"terminating rule finally emits it as a complete construct."
msgstr ""
"おわかりのように、各レイヤーは、最終的に終了ルールが完全な構成体として出力す"
"るまで、蓄積された出力を追加します。"

#: src/decl-macros/patterns/push-down-acc.md:72
#, fuzzy
msgid ""
"The only critical part of the above formulation is the use of `$($body:tt)*` "
"to preserve the output without triggering parsing. The use of `($input) -> "
"($output)` is simply a convention adopted to help clarify the behavior of "
"such macros."
msgstr ""
"上記の定式化で唯一重要なのは、パースすることなく出力を保持するために "
"`$($body:tt)*` を使っていることです。($input) -> ($output)`の使用は、単にこの"
"ようなマクロの動作を明確にするために採用された慣習です。"

#: src/decl-macros/patterns/push-down-acc.md:75
#, fuzzy
msgid ""
"Push-down accumulation is frequently used as part of [incremental TT "
"munchers](./tt-muncher.md), as it allows arbitrarily complex intermediate "
"results to be constructed. [Internal Rules](./internal-rules.md) were of use "
"here as well, as they simplify creating such macros."
msgstr ""
"プッシュダウン累積は、[incremental TT muncher](./tt-muncher.md)の一部として頻"
"繁に使用されます。[内部ルール](./internal-rules.md)は、このようなマクロの作成"
"を単純化するので、ここでも役に立ちました。"

#: src/decl-macros/patterns/push-down-acc.md:80
#, fuzzy
msgid ""
"Push-down accumulation is inherently quadratic. Consider a push-down "
"accumulation rule that builds up an accumulator of 100 token trees, one "
"token tree per invocation."
msgstr ""
"プッシュダウン累積は本質的に2次式です。100個のトークンツリーのアキュムレータ"
"を構築するプッシュダウン累積規則を考えてみましょう。"

#: src/decl-macros/patterns/push-down-acc.md:82
#, fuzzy
msgid "The initial invocation will match against the empty accumulator."
msgstr "最初の呼び出しは空のアキュムレータとマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:83
#, fuzzy
msgid ""
"The first recursive invocation will match against the accumulator of 1 token "
"tree."
msgstr ""
"最初の再帰呼び出しは、1トークンツリーのアキュムレータに対してマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:84
#, fuzzy
msgid ""
"The next recursive invocation will match against the accumulator of 2 token "
"trees."
msgstr ""
"次の再帰呼び出しは、2つのトークンツリーのアキュムレータに対してマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:86
#, fuzzy
msgid ""
"And so on, up to 100. This is a classic quadratic pattern, and long inputs "
"can cause macro expansion to blow out compile times. Furthermore, TT "
"munchers are also inherently quadratic over their input, so a macro that "
"uses both TT munching _and_ push-down accumulation will be doubly quadratic!"
msgstr ""
"というように、最大100まで。これは典型的な 2 次パターンであり、長い入力はマク"
"ロの展開がコンパイル時間を吹っ飛ばす原因になります。さらに、TT マンチャーも本"
"質的に入力に対して 2 次パターンなので、TT マンチャーとプッシュダウン蓄積の両"
"方を使用するマクロは 2 次パターンになります！"

#: src/decl-macros/patterns/push-down-acc.md:90
#, fuzzy
msgid ""
"All the [performance advice](./tt-muncher.md#performance) about TT munchers "
"holds for push-down accumulation.  In general, avoid using them too much, "
"and keep them as simple as possible."
msgstr ""
"TTマンチャーに関する[パフォーマンスに関するアドバイス](./tt-muncher."
"md#performance)はすべて、プッシュダウン・アキュムレーションにも当てはまりま"
"す。  一般的には、使い過ぎは避け、できるだけシンプルにしてください。"

#: src/decl-macros/patterns/push-down-acc.md:93
#, fuzzy
msgid ""
"Finally, make sure you put the accumulator at the _end_ of rules, rather "
"than the beginning. That way, if a rule fails, the compiler won't have had "
"to match the (potentially long) accumulator before hitting the part of the "
"rule that fails to match. This can make a large difference to compile times."
msgstr ""
"最後に、アキュムレータをルールの最初ではなく最後に置くようにしてください。そ"
"うすることで、ルールが失敗した場合、コンパイラはマッチに失敗したルールの部分"
"をヒットする前に、（潜在的に長い）アキュムレータをマッチさせる必要がなくなり"
"ます。これはコンパイル時間に大きな違いをもたらします。"

#: src/decl-macros/patterns/repetition-replacement.md:3
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! replace_expr {\n"
"    ($_t:tt $sub:expr) => {$sub};\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    ($_t:tt $sub:expr) => {$sub}；\n"
"}\n"
"```"

#: src/decl-macros/patterns/repetition-replacement.md:9
#, fuzzy
msgid ""
"This pattern is where a matched repetition sequence is simply discarded, "
"with the variable being used to instead drive some repeated pattern that is "
"related to the input only in terms of length."
msgstr ""
"このパターンでは、マッチした繰り返しシーケンスが単に破棄され、代わりに、長さ"
"の点でのみ入力に関連する繰り返しパターンを駆動するために変数が使用されます。"

#: src/decl-macros/patterns/repetition-replacement.md:11
#, fuzzy
msgid ""
"For example, consider constructing a default instance of a tuple with more "
"than 12 elements (the limit as of Rust 1.2)."
msgstr ""
"例えば、12個以上の要素（Rust 1.2での制限）を持つタプルのデフォルトインスタン"
"スを作成することを考えてみましょう。"

#: src/decl-macros/patterns/repetition-replacement.md:13
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! tuple_default {\n"
"    ($($tup_tys:ty),*) => {\n"
"        (\n"
"            $(\n"
"                replace_expr!(\n"
"                    ($tup_tys)\n"
"                    Default::default()\n"
"                ),\n"
"            )*\n"
"        )\n"
"    };\n"
"}\n"
"#\n"
"# macro_rules! replace_expr {\n"
"#     ($_t:tt $sub:expr) => {$sub};\n"
"# }\n"
"#\n"
"# assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::"
"default(), String::default()));\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ tuple_default {\n"
"    ($($tup_tys:ty),*) => {\n"
"        (\n"
"            $(\n"
"                replace_expr!\n"
"                    ($tup_tys)\n"
"                    デフォルト::default()\n"
"                ),\n"
"            )*\n"
"        )\n"
"    };\n"
"}\n"
"#\n"
"# マクロルール！ replace_expr {\n"
"# ($_t:tt $sub:expr) => {$sub}；\n"
"# }\n"
"#\n"
"# assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::"
"default(), String::default()))；\n"
"```"

#: src/decl-macros/patterns/repetition-replacement.md:34
#, fuzzy
msgid "**: we _could_ have simply used `$tup_tys::default()`."
msgstr "**: 単純に `$tup_tys::default()` を使うこともできました。"

#: src/decl-macros/patterns/repetition-replacement.md:36
#, fuzzy
msgid ""
"Here, we are not actually _using_ the matched types. Instead, we throw them "
"away and replace them with a single, repeated expression. To put it another "
"way, we don't care _what_ the types are, only _how many_ there are."
msgstr ""
"ここでは、マッチした型を実際には_使用しません。その代わりに、それらを捨て、単"
"一の繰り返し式に置き換えます。別の言い方をすれば、型が何であるかは気にしませ"
"ん。"

#: src/decl-macros/patterns/tt-bundling.md:3
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! call_a_or_b_on_tail {\n"
"    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) => {\n"
"        $a(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) => {\n"
"        $b(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ($ab:tt, $_skip:tt $($tail:tt)*) => {\n"
"        call_a_or_b_on_tail!($ab, $($tail)*)\n"
"    };\n"
"}\n"
"\n"
"fn compute_len(s: &str) -> Option<usize> {\n"
"    Some(s.len())\n"
"}\n"
"\n"
"fn show_tail(s: &str) -> Option<usize> {\n"
"    println!(\"tail: {:?}\", s);\n"
"    None\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            the recursive part that skips over all these\n"
"            tokens does not much care whether we will call a\n"
"            or call b: only the terminal rules care.\n"
"        ),\n"
"        None\n"
"    );\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            and now, to justify the existence of two paths\n"
"            we will also call a: its input should somehow\n"
"            be self-referential, so let us make it return\n"
"            some ninety-one!\n"
"        ),\n"
"        Some(91)\n"
"    );\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロのルール！ call_a_or_b_on_tail {\n"
"    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) =&gt; {\n"
"        a(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) =&gt; { $b(stringify!"
"($($tail)*)) }; { $a(stringify!\n"
"        b(文字列化!($($tail)*))\n"
"    };\n"
"\n"
"    ($ab:tt, $_skip:tt $($tail:tt)*)=&gt;{。\n"
"        call_a_or_b_on_tail!($ab, $($tail)*)\n"
"    };\n"
"}\n"
"\n"
"fn compute_len(s: &amp;str) -&gt; オプション<usize> {。\n"
"    some(s.len())\n"
"}\n"
"\n"
"fn show_tail(s: &amp;str) -&gt; オプション<usize> {。\n"
"    println!(\"tail:{:?}\", s)；\n"
"    なし\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail)、\n"
"            これらのすべての\n"
"            を呼び出すかbを呼び出すかはあまり気にしません。\n"
"            を呼び出すかbを呼び出すかはあまり気にしません。\n"
"        ),\n"
"        なし\n"
"    );\n"
"    assert_eq!\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail)、\n"
"            そして今、2つのパスの存在を正当化するために\n"
"            を呼び出すことにします。\n"
"            を返すようにしましょう。\n"
"            を返すようにしましょう！\n"
"        ),\n"
"        いくつかの(91)\n"
"    );\n"
"}\n"
"```"

#: src/decl-macros/patterns/tt-bundling.md:50
#, fuzzy
msgid ""
"In particularly complex recursive macros, a large number of arguments may be "
"needed in order to carry identifiers and expressions to successive layers. "
"However, depending on the implementation there may be many intermediate "
"layers which need to forward these arguments, but do not need to _use_ them."
msgstr ""
"特に複雑な再帰的マクロでは、識別子と式を連続するレイヤに運ぶために、多数の引"
"数が必要になるかもしれません。しかし、実装によっては、これらの引数を転送する"
"必要があっても、それらを_使用する必要がない中間層が多数あるかもしれません。"

#: src/decl-macros/patterns/tt-bundling.md:53
#, fuzzy
msgid ""
"As such, it can be very useful to bundle all such arguments together into a "
"single TT by placing them in a group. This allows layers which do not need "
"to use the arguments to simply capture and substitute a single [`tt`](../"
"minutiae/fragment-specifiers.html#tt), rather than having to exactly capture "
"and substitute the entire argument group."
msgstr ""
"そのため、このような引数をグループにまとめて、1つのTTにまとめると非常に便利で"
"す。これにより、引数を使用する必要のないレイヤーは、引数グループ全体を正確に"
"キャプチャして代入する必要がなく、単純に単一の[`tt`](../minutiae/fragment-"
"specifiers.html#tt)をキャプチャして代入することができます。"

#: src/decl-macros/patterns/tt-bundling.md:56
#, fuzzy
msgid ""
"The example above bundles the `$a` and `$b` expressions into a group which "
"can then be forwarded as a single [`tt`](../minutiae/fragment-specifiers."
"html#tt) by the recursive rule. This group is then destructured by the "
"terminal rules to access the expressions."
msgstr ""
"上の例では、`$a` 式と `$b` 式を1つのグループにまとめ、再帰ルールによって1つ"
"の [`tt`](../minutiae/fragment-specifiers.html#tt) として転送しています。そし"
"て、このグループは、式にアクセスするための終端ルールによって再構築されます。"

#: src/decl-macros/building-blocks.md:3
#, fuzzy
msgid "Reusable snippets of `macro_rules!` macro code."
msgstr "マクロコード `macro_rules!` の再利用可能なスニペット。"

#: src/decl-macros/building-blocks/ast-coercion.md:3
#, fuzzy
msgid ""
"The Rust parser is not very robust in the face of `tt` substitutions. "
"Problems can arise when the parser is expecting a particular grammar "
"construct and _instead_ finds a lump of substituted `tt` tokens. Rather than "
"attempt to parse them, it will often just _give up_. In these cases, it is "
"necessary to employ an AST coercion."
msgstr ""
"Rust パーサーは `tt` の置換にあまり強くありません。パーサが特定の文法構文を期"
"待していて、その代わりに置換された `tt` トークンの塊を見つけたときに問題が発"
"生することがあります。このような場合、パーサは構文を解析しようとするのではな"
"く、単にあきらめることになります。このような場合、AST強制を使う必要がありま"
"す。"

#: src/decl-macros/building-blocks/ast-coercion.md:7
#, fuzzy
msgid ""
"```rust\n"
"# #![allow(dead_code)]\n"
"macro_rules! as_expr { ($e:expr) => {$e} }\n"
"macro_rules! as_item { ($i:item) => {$i} }\n"
"macro_rules! as_pat  { ($p:pat)  => {$p} }\n"
"macro_rules! as_stmt { ($s:stmt) => {$s} }\n"
"macro_rules! as_ty   { ($t:ty)   => {$t} }\n"
"\n"
"as_item!{struct Dummy;}\n"
"\n"
"fn main() {\n"
"    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#![allow(dead_code)].\n"
"macro_rules! as_expr { ($e:expr) => {$e} }.\n"
"macro_rules! as_item { ($i:item) => {$i} }.\n"
"マクロルール！ as_pat { ($p:pat) => {$p} }.\n"
"マクロルール！ as_stmt { ($s:stmt) => {$s} }.\n"
"\n"
"\n"
"as_item!\n"
"\n"
"fn main() {\n"
"    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42))；\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/ast-coercion.md:22
#, fuzzy
msgid ""
"These coercions are often used with [push-down accumulation](../patterns/"
"push-down-acc.md) macros in order to get the parser to treat the final `tt` "
"sequence as a particular kind of grammar construct."
msgstr ""
"これらの強制子はしばしば[push-down accumulation](../patterns/push-down-acc."
"md)マクロと一緒に使われます。"

#: src/decl-macros/building-blocks/ast-coercion.md:24
#, fuzzy
msgid ""
"Note that this specific set of macros is determined by what macros are "
"allowed to expand to, _not_ what they are able to capture."
msgstr ""
"このマクロの特定のセットは、マクロが何をキャプチャできるかではなく、マクロが"
"何を展開できるかによって決定されることに注意してください。"

#: src/decl-macros/building-blocks/counting.md:3
#, fuzzy
msgid ""
"What follows are several techniques for counting in `macro_rules!` macros:"
msgstr ""
"以下は、`macro_rules!` マクロでカウントするためのいくつかのテクニックです："

#: src/decl-macros/building-blocks/counting.md:5
#, fuzzy
msgid ""
"**Note**: If you are just interested in the most efficient way [look here](./"
"counting.md#bit-twiddling)"
msgstr ""
"**注**：最も効率的な方法に興味があるなら[ここ](./counting.md#bit-twiddling)を"
"見てください。"

#: src/decl-macros/building-blocks/counting.md:7
#, fuzzy
msgid "Repetition with replacement"
msgstr "交換を伴う繰り返し"

#: src/decl-macros/building-blocks/counting.md:9
#, fuzzy
msgid ""
"Counting things in a macro is a surprisingly tricky task. The simplest way "
"is to use replacement with a repetition match."
msgstr ""
"マクロで数を数えるのは意外と厄介な作業です。最も単純な方法は、繰り返しマッチ"
"で置換を使うことです。"

#: src/decl-macros/building-blocks/counting.md:12
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! replace_expr {\n"
"    ($_t:tt $sub:expr) => {$sub};\n"
"}\n"
"\n"
"macro_rules! count_tts {\n"
"    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*};\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(count_tts!(0 1 2), 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($_t:tt $sub:expr) => {$sub}；\n"
"}\n"
"\n"
"マクロルール!\n"
"    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*}；\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(count_tts!(0 1 2), 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:26
#, fuzzy
msgid ""
"This is a fine approach for smallish numbers, but will likely _crash the "
"compiler_ with inputs of around 500 or so tokens. Consider that the output "
"will look something like this:"
msgstr ""
"この方法は小さな数であれば問題ありませんが、500トークン程度の入力ではコンパイ"
"ラがクラッシュする可能性が高くなります。出力は次のようになると考えてくださ"
"い："

#: src/decl-macros/building-blocks/counting.md:29
#, fuzzy
msgid ""
"```rust,ignore\n"
"0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize\n"
"```"
msgstr ""
"錆、無視\n"
"0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize\n"
"```"

#: src/decl-macros/building-blocks/counting.md:33
#, fuzzy
msgid ""
"The compiler must parse this into an AST, which will produce what is "
"effectively a perfectly unbalanced binary tree 500+ levels deep."
msgstr ""
"コンパイラーはこれをASTにパースしなければなりません。ASTは、500レベル以上の深"
"さの完全にアンバランスなバイナリツリーを生成します。"

#: src/decl-macros/building-blocks/counting.md:35
msgid "Recursion"
msgstr "再帰"

#: src/decl-macros/building-blocks/counting.md:37
#, fuzzy
msgid "An older approach is to use recursion."
msgstr "古いアプローチとしては、再帰を使う方法があります。"

#: src/decl-macros/building-blocks/counting.md:39
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_tts {\n"
"    () => {0usize};\n"
"    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(count_tts!(0 1 2), 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_tts {\n"
"    () => {0usize};\n"
"    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)}；\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(count_tts!(0 1 2), 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:50
#, fuzzy
msgid ""
"**Note**: As of `rustc` 1.2, the compiler has _grievous_ performance "
"problems when large numbers of integer literals of unknown type must undergo "
"inference. We are using explicitly `usize`\\-typed literals here to avoid "
"that."
msgstr ""
"**注意**：rustc` 1.2 では、未知の型の大量の整数リテラルが推論を受けなければな"
"らない場合、コンパイラは_悲しむべき_パフォーマンス問題を抱えています。それを"
"避けるために、ここでは明示的に `usize` 型のリテラルを使用しています。"

#: src/decl-macros/building-blocks/counting.md:53
#, fuzzy
msgid ""
"If this is not suitable (such as when the type must be substitutable), you "
"can help matters by using `as` (_e.g._ `0 as $ty`, `1 as $ty`, _etc._)."
msgstr ""
"これが適切でない場合(置換可能な型でなければならない場合など)は、`as`を使用す"
"ることで、問題を解決することができます(_e._ `0 as $ty`、`1 as $ty`など)。"

#: src/decl-macros/building-blocks/counting.md:55
#, fuzzy
msgid ""
"This _works_, but will trivially exceed the recursion limit. Unlike the "
"repetition approach, you can extend the input size by matching multiple "
"tokens at once."
msgstr ""
"これはうまくいきますが、些細なことで再帰の制限を超えてしまいます。繰り返しの"
"アプローチとは異なり、複数のトークンを一度にマッチさせることで入力サイズを拡"
"張することができます。"

#: src/decl-macros/building-blocks/counting.md:58
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_tts {\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt\n"
"     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt\n"
"     $($tail:tt)*)\n"
"        => {20usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $($tail:tt)*)\n"
"        => {10usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $($tail:tt)*)\n"
"        => {5usize + count_tts!($($tail)*)};\n"
"    ($_a:tt\n"
"     $($tail:tt)*)\n"
"        => {1usize + count_tts!($($tail)*)};\n"
"    () => {0usize};\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(700, count_tts!(\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        // Repetition breaks somewhere after this\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_tts {\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     k:tt $_l:tt $_m:tt $_n:tt $_o:tt\n"
"     p:tt $_q:tt $_r:tt $_s:tt $_t:tt\n"
"     ($tail:tt)*)\n"
"        => {20usize + count_tts!($($tail)*)}；\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     ($tail:tt)*)\n"
"        => {10usize + count_tts!($($tail)*)}；\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     ($($tail:tt)*))\n"
"        => {5usize + count_tts!($($tail)*)}；\n"
"    ($_a:tt\n"
"     ($($tail:tt)*)\n"
"        => {1usize + count_tts!($($tail)*)}；\n"
"    () => {0usize};\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(700, count_tts!(),,,,,,,,,,,.\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        // この後、どこかで繰り返しが中断\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"    ));\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/counting.md:106
#, fuzzy
msgid "This particular formulation will work up to ~1,200 tokens."
msgstr "この製剤は、～1,200トークンまで使用できます。"

#: src/decl-macros/building-blocks/counting.md:108
#, fuzzy
msgid "Slice length"
msgstr "スライス長"

#: src/decl-macros/building-blocks/counting.md:110
#, fuzzy
msgid ""
"A third approach is to help the compiler construct a shallow AST that won't "
"lead to a stack overflow. This can be done by constructing an array literal "
"and calling the `len` method."
msgstr ""
"3つ目の方法は、スタックオーバーフローにならないような浅いASTをコンパイラが構"
"築できるようにすることです。これは、配列リテラルを構築して `len` メソッドを呼"
"び出すことで実現できます。"

#: src/decl-macros/building-blocks/counting.md:113
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! replace_expr {\n"
"    ($_t:tt $sub:expr) => {$sub};\n"
"}\n"
"\n"
"macro_rules! count_tts {\n"
"    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ())),*])};\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(count_tts!(0 1 2), 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($_t:tt $sub:expr) => {$sub}；\n"
"}\n"
"\n"
"マクロルール!\n"
"    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ()),*])}；\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(count_tts!(0 1 2), 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:127
#, fuzzy
msgid ""
"This has been tested to work up to 10,000 tokens, and can probably go much "
"higher."
msgstr ""
"これは10,000トークンまで動作することがテストされており、おそらくもっと高くす"
"ることができます。"

#: src/decl-macros/building-blocks/counting.md:129
#, fuzzy
msgid "Array length"
msgstr "配列の長さ"

#: src/decl-macros/building-blocks/counting.md:131
#, fuzzy
msgid ""
"Another modification of the previous approach is to use const generics "
"stabilized in Rust 1.51. It's only slightly slower than slice length method "
"on 20,000 tokens and works in const contexts."
msgstr ""
"以前のアプローチのもう1つの修正は、Rust 1.51で安定したconstジェネリックを使う"
"ことです。20,000トークンではslice lengthメソッドよりわずかに遅く、constコンテ"
"キストで動作します。"

#: src/decl-macros/building-blocks/counting.md:134
#, fuzzy
msgid ""
"```rust\n"
"const fn count_helper<const N: usize>(_: [(); N]) -> usize { N }\n"
"\n"
"macro_rules! replace_expr {\n"
"    ($_t:tt $sub:expr) => { $sub }\n"
"}\n"
"\n"
"macro_rules! count_tts {\n"
"    ($($smth:tt)*) => {\n"
"        count_helper([$(replace_expr!($smth ())),*])\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(count_tts!(0 1 2), 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"const fn count_helper<const N: usize>(_: [(); N]) -&gt; usize { N }.\n"
"\n"
"マクロルール！ replace_expr { ($_t:tt $sub:expr) =&gt; { $sub }.\n"
"    ($_t:tt $sub:expr) =&gt; { $sub }.\n"
"}\n"
"\n"
"マクロルール!\n"
"    ($($smth:tt)*) =&gt; { $sub } } マクロルール!\n"
"        count_helper([$(replace_expr!($smth ())),*])\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(count_tts!(0 1 2), 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:152
#, fuzzy
msgid "Enum counting"
msgstr "列挙カウント"

#: src/decl-macros/building-blocks/counting.md:154
#, fuzzy
msgid ""
"This approach can be used where you need to count a set of mutually distinct "
"identifiers."
msgstr ""
"この方法は、互いに異なる識別子の集合を数える必要がある場合に使用できます。"

#: src/decl-macros/building-blocks/counting.md:156
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_idents {\n"
"    () => {0};\n"
"    ($last_ident:ident, $($idents:ident),* $(,)?) => {\n"
"        {\n"
"            #[allow(dead_code, non_camel_case_types)]\n"
"            enum Idents { $($idents,)* $last_ident }\n"
"            const COUNT: u32 = Idents::$last_ident as u32 + 1;\n"
"            COUNT\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     const COUNT: u32 = count_idents!(A, B, C);\n"
"#     assert_eq!(COUNT, 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_idents {\n"
"    () => {0};\n"
"    ($last_ident:ident, $($idents:ident),* $(,)?) => { { $(,)?\n"
"        {\n"
"            #[allow(dead_code, non_camel_case_types)] のようにします。\n"
"            enum Idents { $($idents,)* $last_ident }.\n"
"            const COUNT: u32 = Idents::$last_ident as u32 + 1；\n"
"            COUNT\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"# const COUNT: u32 = count_idents!(A, B, C)；\n"
"# assert_eq!(COUNT, 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:175
#, fuzzy
msgid ""
"This method does have two drawbacks. As implied above, it can _only_ count "
"valid identifiers (which are also not keywords), and it does not allow those "
"identifiers to repeat."
msgstr ""
"この方法には2つの欠点があります。上記で暗示したように、有効な識別子(キーワー"
"ドでもない)のみを数えることができ、それらの識別子を繰り返すことはできません。"

#: src/decl-macros/building-blocks/counting.md:178
#, fuzzy
msgid "Bit twiddling"
msgstr "ビットいじり"

#: src/decl-macros/building-blocks/counting.md:180
#, fuzzy
msgid "Another recursive approach using bit operations:"
msgstr "ビット演算を使ったもう一つの再帰的アプローチ："

#: src/decl-macros/building-blocks/counting.md:182
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_tts {\n"
"    () => { 0 };\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 };\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(count_tts!(0 1 2), 3);\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_tts {\n"
"    () => { 0 };\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 };\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 };\n"
"}\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(count_tts!(0 1 2), 3)；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/counting.md:194
#, fuzzy
msgid ""
"This approach is pretty smart as it effectively halves its input whenever "
"its even and then multiplying the counter by 2 (or in this case shifting 1 "
"bit to the left which is equivalent). If the input is uneven it simply takes "
"one token tree from the input `or`s the token tree to the previous counter "
"which is equivalent to adding 1 as the lowest bit has to be a 0 at this "
"point due to the previous shifting. Rinse and repeat until we hit the base "
"rule `() => 0`."
msgstr ""
"このアプローチはかなりスマートで、入力が偶数であるときは常に入力を半分にし、"
"カウンターを2倍します（この場合は1ビットを左にシフトします）。入力が不均等な"
"場合は、単純に入力からトークンツリーを1つ取るか、トークンツリーを前のカウン"
"ターに移します。基本ルール `() => 0` にぶつかるまで繰り返します。"

#: src/decl-macros/building-blocks/counting.md:198
#, fuzzy
msgid ""
"The benefit of this is that the constructed AST expression that makes up the "
"counter value will grow with a complexity of `O(log(n))` instead of `O(n)` "
"like the other approaches. Be aware that you can still hit the recursion "
"limit with this if you try hard enough. Credits for this method go to Reddit "
"user [`YatoRust`](https://www.reddit.com/r/rust/comments/d3yag8/"
"the_little_book_of_rust_macros/)."
msgstr ""
"この利点は、カウンターの値を構成するAST式が他のアプローチのように `O(n)` では"
"なく `O(log(n))` の複雑さで成長することです。この方法でも頑張れば再帰限界にぶ"
"つかる可能性があることに注意してください。この方法のクレジットはRedditユー"
"ザー[`YatoRust`](https://www.reddit.com/r/rust/comments/d3yag8/"
"the_little_book_of_rust_macros/)にあります。"

#: src/decl-macros/building-blocks/counting.md:203
#, fuzzy
msgid "Let's go through the procedure by hand once:"
msgstr "一度、手で手順を確認してみましょう："

#: src/decl-macros/building-blocks/counting.md:205
#, fuzzy
msgid ""
"```rust,ignore\n"
"count_tts!(0 0 0 0 0 0 0 0 0 0);\n"
"```"
msgstr ""
"錆、無視\n"
"count_tts!(0 0 0 0 0 0 0 0 0 0)；\n"
"```"

#: src/decl-macros/building-blocks/counting.md:208
#, fuzzy
msgid ""
"This invocation will match the third rule due to the fact that we have an "
"even number of token trees(10). The matcher names the odd token trees in the "
"sequence `$a` and the even ones `$even` but the expansion only makes use of "
"`$a`, which means it effectively discards all the even elements cutting the "
"input in half. So the invocation now becomes:"
msgstr ""
"偶数のトークンツリー(10)があるため、この呼び出しは3番目のルールにマッチしま"
"す。マッチャーはトークン木列の奇数に `$a`、偶数に `$even` という名前を付けま"
"すが、展開では `$a` のみを使用します。そのため、呼び出しは次のようになりま"
"す："

#: src/decl-macros/building-blocks/counting.md:211
#, fuzzy
msgid ""
"```rust,ignore\n"
"count_tts!(0 0 0 0 0) << 1;\n"
"```"
msgstr ""
"錆、無視\n"
"count_tts!(0 0 0 0 0) << 1；\n"
"```"

#: src/decl-macros/building-blocks/counting.md:214
#, fuzzy
msgid ""
"This invocation will now match the second rule as its input is an uneven "
"amount of token trees. In this case the first token tree is discarded to "
"make the input even again, then we also do the halving step in this "
"invocation again since we know the input would be even now anyways. "
"Therefore we can count 1 for the uneven discard and multiply by 2 again "
"since we also halved."
msgstr ""
"この呼び出しは2番目のルールにマッチします。この場合、最初のトークンツリーを破"
"棄して入力を偶数にします。したがって、不均等な廃棄を1と数え、また半分にしたの"
"で2を掛けます。"

#: src/decl-macros/building-blocks/counting.md:217
#, fuzzy
msgid ""
"```rust,ignore\n"
"((count_tts!(0 0) << 1) | 1) << 1;\n"
"```"
msgstr ""
"錆、無視\n"
"((count_tts!(0 0) << 1) | 1) << 1；\n"
"```"

#: src/decl-macros/building-blocks/counting.md:220
#, fuzzy
msgid ""
"```rust,ignore\n"
"((count_tts!(0) << 1 << 1) | 1) << 1;\n"
"```"
msgstr ""
"錆、無視\n"
"((count_tts!(0) << 1 << 1) | 1) << 1；\n"
"```"

#: src/decl-macros/building-blocks/counting.md:223
#, fuzzy
msgid ""
"```rust,ignore\n"
"((((count_tts!() << 1) | 1) << 1 << 1) | 1) << 1;\n"
"```"
msgstr ""
"錆、無視\n"
"((((count_tts!() << 1) | 1) << 1 << 1) | 1) << 1；\n"
"```"

#: src/decl-macros/building-blocks/counting.md:226
#: src/decl-macros/building-blocks/counting.md:232
#, fuzzy
msgid ""
"```rust,ignore\n"
"((((0 << 1) | 1) << 1 << 1) | 1) << 1;\n"
"```"
msgstr ""
"錆、無視\n"
"((((0 << 1) | 1) << 1 << 1) | 1) << 1;\n"
"```"

#: src/decl-macros/building-blocks/counting.md:230
#, fuzzy
msgid ""
"Now to check if we expanded correctly manually we can use a one of the tools "
"we introduced for [`debugging`](../minutiae/debugging.md). When expanding "
"the macro there we should get:"
msgstr ""
"手動で正しく展開できたかどうかを確認するには、[`debugging`]（../minutiae/"
"debugging.md）で紹介したツールを使います。そこでマクロを展開すると"

#: src/decl-macros/building-blocks/counting.md:236
#, fuzzy
msgid "That's the same so we didn't make any mistakes, great!"
msgstr "それは同じなので、ミスはありませんでした！"

#: src/decl-macros/building-blocks/abacus-counting.md:1
#, fuzzy
msgid "Abacus Counters"
msgstr "そろばんカウンター"

#: src/decl-macros/building-blocks/abacus-counting.md:3
#, fuzzy
msgid ""
"**Provisional**: needs a more compelling example. Matching nested groups "
"that are _not_ denoted by Rust groups is sufficiently unusual that it may "
"not merit inclusion."
msgstr ""
"*仮***: もっと説得力のある例が必要です。Rustグループによって示されないネスト"
"されたグループとのマッチングは十分に珍しいので、含める価値はないかもしれませ"
"ん。"

#: src/decl-macros/building-blocks/abacus-counting.md:6
#, fuzzy
msgid ""
"**Note**: this section assumes understanding of [push-down accumulation]"
"(#push-down-accumulation) and [incremental TT munchers](#incremental-tt-"
"munchers)."
msgstr ""
"*注***: このセクションは、[push-down accumulation](#push-down-accumulation) "
"と [incremental TT munchers](#incremental-tt-munchers) を理解していることを前"
"提としています。"

#: src/decl-macros/building-blocks/abacus-counting.md:8
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! abacus {\n"
"    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((- $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (- $($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (+ $($count)*))\n"
"    };\n"
"\n"
"    // Check if the final result is zero.\n"
"    (() -> ()) => { true };\n"
"    (() -> ($($count:tt)+)) => { false };\n"
"}\n"
"\n"
"fn main() {\n"
"    let equals_zero = abacus!((++-+-+++--++---++----+) -> ());\n"
"    assert_eq!(equals_zero, true);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール\n"
"    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {\n"
"        そろばん！(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((- $($moves:tt)*) -> ($($count:tt)*)) => {そろばん!\n"
"        そろばん！(($($moves)*) -> (- $($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => { {そろばん!\n"
"        そろばん!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {そろばん!\n"
"        そろばん!(($($moves)*) -> (+ $($count)*))。\n"
"    };\n"
"\n"
"    // 最終結果が0かどうかを調べます。\n"
"    (() -> ()) => { true }；\n"
"    (() -> ($($count:tt)+)) => { false }；\n"
"}\n"
"\n"
"fn main() {\n"
"    let equals_zero = そろばん!((++-+-+++--++---++++----+) -> ())；\n"
"    assert_eq!(equals_zero, true)；\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/abacus-counting.md:34
#, fuzzy
msgid ""
"This technique can be used in cases where you need to keep track of a "
"varying counter that starts at or near zero, and must support the following "
"operations:"
msgstr ""
"このテクニックは、ゼロまたはゼロに近い値から始まる変化するカウンターを追跡す"
"る必要があり、以下の操作をサポートする必要がある場合に使用できます："

#: src/decl-macros/building-blocks/abacus-counting.md:36
#, fuzzy
msgid "Increment by one."
msgstr "1ずつ増やします。"

#: src/decl-macros/building-blocks/abacus-counting.md:37
#, fuzzy
msgid "Decrement by one."
msgstr "1つ減ります。"

#: src/decl-macros/building-blocks/abacus-counting.md:38
#, fuzzy
msgid "Compare to zero (or any other fixed, finite value)."
msgstr "ゼロ（または他の固定された有限の値）と比較してください。"

#: src/decl-macros/building-blocks/abacus-counting.md:40
#, fuzzy
msgid ""
"A value of _n_ is represented by _n_ instances of a specific token stored in "
"a group. Modifications are done using recursion and [push-down accumulation]"
"(#push-down-accumulation). Assuming the token used is `x`, the operations "
"above are implemented as follows:"
msgstr ""
"n_の値は、グループに格納された特定のトークンの_n_個のインスタンスで表されま"
"す。変更は再帰と[push-down accumulation](#push-down-accumulation)を使って行わ"
"れます。使用するトークンを `x` とすると、上記の操作は以下のように実装されま"
"す："

#: src/decl-macros/building-blocks/abacus-counting.md:44
#, fuzzy
msgid "Increment by one: match `($($count:tt)*)`, substitute `(x $($count)*)`."
msgstr ""
"1つ増やす: `($($count:tt)*)` にマッチし、 `(x $($count)*)` を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:45
#, fuzzy
msgid "Decrement by one: match `(x $($count:tt)*)`, substitute `($($count)*)`."
msgstr "1つ減らす: `(x $($count:tt)*)` にマッチ、 `($($count)*)` を代入。"

#: src/decl-macros/building-blocks/abacus-counting.md:46
#, fuzzy
msgid "Compare to zero: match `()`."
msgstr "ゼロとの比較: `()` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:47
#, fuzzy
msgid "Compare to one: match `(x)`."
msgstr "(x)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:48
#, fuzzy
msgid "Compare to two: match `(x x)`."
msgstr "(x)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:49
#: src/decl-macros/building-blocks/abacus-counting.md:78
#, fuzzy
msgid "_(and so on...)_"
msgstr ""
"また、APIが非推奨になることもあります。この場合、それを使用していると、今まで"
"無かった警告が出るようになります。"

#: src/decl-macros/building-blocks/abacus-counting.md:51
#, fuzzy
msgid ""
"In this way, operations on the counter are like flicking tokens back and "
"forth like an abacus.[^abacus]"
msgstr ""
"このように、カウンターの操作は、そろばんのようにトークンを前後にはじくような"
"ものです[^abacus]。"

#: src/decl-macros/building-blocks/abacus-counting.md:53
#, fuzzy
msgid ""
"This desperately thin reasoning conceals the _real_ reason for this name: to "
"avoid having _yet another_ thing with \"token\" in the name. Talk to your "
"writer about avoiding [semantic satiation](https://en.wikipedia.org/wiki/"
"Semantic_satiation) today!  \n"
"In fairness, it could _also_ have been called [\"unary counting\"](https://"
"en.wikipedia.org/wiki/Unary_numeral_system)."
msgstr ""
"この薄っぺらな理由付けには、この名前を付けた本当の理由が隠されています。意味"
"的飽和](https://en.wikipedia.org/wiki/Semantic_satiation)を避けるために、今日"
"あなたのライターに相談してください！  \n"
"公平を期すために、これは[\"単項カウント\"](https://en.wikipedia.org/wiki/"
"Unary_numeral_system)と呼ばれていたかもしれません。"

#: src/decl-macros/building-blocks/abacus-counting.md:58
#, fuzzy
msgid ""
"In cases where you want to represent negative values, _\\-n_ can be "
"represented as _n_ instances of a _different_ token. In the example given "
"above, _+n_ is stored as _n_ `+` tokens, and _\\-m_ is stored as _m_ `-` "
"tokens."
msgstr ""
"負の値を表現したい場合、_n_ は _n_ インスタンスの _different_ トークンとして"
"表現できます。上の例では、 _+n_ は _n_ `+` トークンとして格納され、 _-m_ は "
"_m_ `-` トークンとして格納されます。"

#: src/decl-macros/building-blocks/abacus-counting.md:62
#, fuzzy
msgid ""
"In this case, the operations become slightly more complicated; increment and "
"decrement effectively reverse their usual meanings when the counter is "
"negative. To which given `+` and `-` for the positive and negative tokens "
"respectively, the operations change to:"
msgstr ""
"この場合、操作は少し複雑になります。カウンタが負になると、インクリメントとデ"
"クリメントは通常の意味と逆になります。正と負のトークンにそれぞれ `+` と `-` "
"が与えられると、操作は次のように変わります："

#: src/decl-macros/building-blocks/abacus-counting.md:65
#, fuzzy
msgid "Increment by one:"
msgstr "1ずつ増やします："

#: src/decl-macros/building-blocks/abacus-counting.md:66
#, fuzzy
msgid "match `()`, substitute `(+)`."
msgstr "マッチ `()`, 置き換える `(+)`."

#: src/decl-macros/building-blocks/abacus-counting.md:67
#, fuzzy
msgid "match `(- $($count:tt)*)`, substitute `($($count)*)`."
msgstr "マッチ `(- $($count:tt)*)`, substitute `($($count)*)`."

#: src/decl-macros/building-blocks/abacus-counting.md:68
#, fuzzy
msgid "match `($($count:tt)+)`, substitute `(+ $($count)+)`."
msgstr "($($count:tt)+)`にマッチする場合は、`(+ $($count)+)`を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:69
#, fuzzy
msgid "Decrement by one:"
msgstr "1つ減ります："

#: src/decl-macros/building-blocks/abacus-counting.md:70
#, fuzzy
msgid "match `()`, substitute `(-)`."
msgstr "マッチ `()`, 代入 `(-)`."

#: src/decl-macros/building-blocks/abacus-counting.md:71
#, fuzzy
msgid "match `(+ $($count:tt)*)`, substitute `($($count)*)`."
msgstr "マッチ `(+ $($count:tt)*)`, substitute `($($count)*)`."

#: src/decl-macros/building-blocks/abacus-counting.md:72
#, fuzzy
msgid "match `($($count:tt)+)`, substitute `(- $($count)+)`."
msgstr "($($count:tt)+)`にマッチする場合は、`(- $($count)+)`を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:73
#, fuzzy
msgid "Compare to 0: match `()`."
msgstr "0と比較: `()` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:74
#, fuzzy
msgid "Compare to +1: match `(+)`."
msgstr "(+)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:75
#, fuzzy
msgid "Compare to -1: match `(-)`."
msgstr "1との比較: `(-)` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:76
#, fuzzy
msgid "Compare to +2: match `(++)`."
msgstr "(++)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:77
#, fuzzy
msgid "Compare to -2: match `(--)`."
msgstr "(--)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:80
#, fuzzy
msgid ""
"Note that the example at the top combines some of the rules together (for "
"example, it combines increment on `()` and `($($count:tt)+)` into an "
"increment on `($($count:tt)*)`)."
msgstr ""
"一番上の例では、いくつかのルールを組み合わせていることに注意してください (例"
"えば、 `()` のインクリメントと `($($count:tt)+)` のインクリメントを組み合わせ"
"て、 `($($count:tt)*)` のインクリメントにしています)。"

#: src/decl-macros/building-blocks/abacus-counting.md:82
#, fuzzy
msgid ""
"If you want to extract the actual _value_ of the counter, this can be done "
"using a regular [counter macro](./counting.md). For the example above, the "
"terminal rules can be replaced with the following:"
msgstr ""
"カウンターの実際の_値_を抽出したい場合は、通常の[カウンターマクロ](./"
"counting.md)を使って行うことができます。上の例では、端末のルールを次のように"
"置き換えることができます："

#: src/decl-macros/building-blocks/abacus-counting.md:85
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! abacus {\n"
"    // ...\n"
"\n"
"    // This extracts the counter as an integer expression.\n"
"    (() -> ()) => {0};\n"
"    (() -> (- $($count:tt)*)) => {\n"
"        - ( count_tts!($( $count_tts:tt )*) )\n"
"    };\n"
"    (() -> (+ $($count:tt)*)) => {\n"
"        count_tts!($( $count_tts:tt )*)\n"
"    };\n"
"}\n"
"\n"
"// One of the many token tree counting macros in the counting chapter\n"
"macro_rules! count_tts {\n"
"    // ...\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    // ...\n"
"\n"
"    // これはカウンタを整数式として取り出します。\n"
"    (() -> ()) => {0};\n"
"    (() -> (- $($count:tt)*)) => { ...\n"
"        - ( count_tts!($( $count_tts:tt )*) ) )\n"
"    };\n"
"    (() -> (+ $($count:tt)*))=>{。\n"
"        count_tts!($( $count_tts:tt )* ))\n"
"    };\n"
"}\n"
"\n"
"// カウントの章では、トークン木をカウントするマクロを多数用意しています。\n"
"macro_rules!\n"
"    // ...\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/abacus-counting.md:105
#, fuzzy
msgid ""
"**: strictly speaking, the above formulation of `abacus!` is needlessly "
"complex. It can be implemented much more efficiently using repetition, "
"provided you _do not_ need to match against the counter's value in a macro:"
msgstr ""
"**: 厳密に言えば、上記の`abacus!マクロの中でカウンターの値とマッチする必要が"
"なければ、繰り返しを使うことで、より効率的に実装することができます："

#: src/decl-macros/building-blocks/abacus-counting.md:108
#, fuzzy
msgid ""
"```ignore\n"
"macro_rules! abacus {\n"
"    (-) => {-1};\n"
"    (+) => {1};\n"
"    ($( $moves:tt )*) => {\n"
"        0 $(+ abacus!($moves))*\n"
"    }\n"
"}\n"
"```"
msgstr ""
"無視\n"
"マクロルール\n"
"    (-) => {-1};\n"
"    (+) => {1};\n"
"    ($( $moves:tt )*) => { { 0\n"
"        0 $(+ そろばん!($moves))*) => { $(+ そろばん!($moves))*)\n"
"    }\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:3
#, fuzzy
msgid ""
"Parsing some of Rust's items can be useful in certain situations. This "
"section will show a few macros that can parse some of Rust's more complex "
"items like structs and functions to a certain extent. The goal of these "
"macros is not to be able to parse the entire grammar of the items but to "
"parse parts that are in general quite useful without being too complex to "
"parse. This means we ignore things like generics and such."
msgstr ""
"Rustのいくつかの項目を解析することは、特定の状況において有用です。このセク"
"ションでは、構造体や関数のようなRustのより複雑な項目をある程度解析できるマク"
"ロをいくつか紹介します。これらのマクロの目的は、項目の文法全体を解析できるよ"
"うにすることではなく、解析が複雑すぎず、一般的に非常に有用な部分を解析するこ"
"とです。つまり、ジェネリクスなどは無視します。"

#: src/decl-macros/building-blocks/parsing.md:7
#, fuzzy
msgid ""
"The main points of interest of these macros are their `matchers`. The "
"transcribers are only there for example purposes and are usually not that "
"impressive."
msgstr ""
"これらのマクロの主な注目点は `matchers` です。テープ起こしはあくまでも例とし"
"て行われるもので、通常はそれほど印象的なものではありません。"

#: src/decl-macros/building-blocks/parsing.md:10
msgid "Function"
msgstr "関数"

#: src/decl-macros/building-blocks/parsing.md:12
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! function_item_matcher {\n"
"    (\n"
"\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* "
"$(,)? )\n"
"    //                          ^~~~~~~~~~~~~~~~argument list!"
"~~~~~~~~~~~~~~^\n"
"            $( -> $ret_ty:ty )?\n"
"    //      ^~~~return type~~~^\n"
"            { $($tt:tt)* }\n"
"    //      ^~~~~body~~~~^\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )? "
"{ $($tt)* }\n"
"    }\n"
"}\n"
"\n"
"#function_item_matcher!(\n"
"#    #[inline]\n"
"#    #[cold]\n"
"#    pub fn foo(bar: i32, baz: i32, ) -> String {\n"
"#        format!(\"{} {}\", bar, baz)\n"
"#    }\n"
"#);\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(foo(13, 37), \"13 37\");\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ function_item_matcher {\n"
"    (\n"
"\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)?)\n"
"    // "
"^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"            $( -> $ret_ty:ty )?\n"
"    // ^~~~リターン・タイプ~~~~^ $( -> $ret_ty:ty )?\n"
"            { $($tt:tt)* }?\n"
"    // ^~~~~本文~~~~~^ ?\n"
"    ) => {\n"
"        $( #[$meta] )*)\n"
"        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )?"
"{ $($tt)* } ?\n"
"    }\n"
"}\n"
"\n"
"#function_item_matcher!(\n"
"#[inline]\n"
"#[cold]\n"
"pub fn foo(bar: i32, baz: i32, ) -> String { # format!\n"
"# format!(\"{} {}\", bar, baz)\n"
"# }\n"
"#);\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(foo(13, 37), \"13 37\")；\n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:43
#, fuzzy
msgid ""
"A simple function matcher that ignores qualifiers like `unsafe`, "
"`async`, ... as well as generics and where clauses. If parsing those is "
"required it is likely that you are better off using a proc-macro instead."
msgstr ""
"unsafe`、`async` などの修飾子やジェネリクス、where 節を無視するシンプルな関数"
"マッチャです。これらのパースが必要な場合は、代わりに proc-macro を使用する方"
"が良いでしょう。"

#: src/decl-macros/building-blocks/parsing.md:46
#, fuzzy
msgid ""
"This lets you for example, inspect the function signature, generate some "
"extra things from it and then re-emit the entire function again. Kind of "
"like a `Derive` proc-macro but weaker and for functions."
msgstr ""
"これにより、例えば、関数のシグネチャを検査し、そこから余分なものを生成し、関"
"数全体を再度実行することができます。Derive`マクロのようなものです。"

#: src/decl-macros/building-blocks/parsing.md:49
#, fuzzy
msgid ""
"Ideally we would like to use a pattern fragment specifier instead of an "
"ident for the arguments but this is currently not allowed. Fortunately "
"people don't use non-identifier patterns in function signatures that often "
"so this is okay(a shame, really)."
msgstr ""
"理想的には、引数にidentの代わりにパターン断片指定子を使いたいところですが、現"
"在のところこれは許可されていません。幸いなことに、関数のシグネチャでidentでな"
"いパターンを使うことはあまりありません。"

#: src/decl-macros/building-blocks/parsing.md:52
#, fuzzy
msgid "Method"
msgstr "方法"

#: src/decl-macros/building-blocks/parsing.md:54
#, fuzzy
msgid ""
"The macro for parsing basic functions is nice and all, but sometimes we "
"would like to also parse methods, functions that refer to their object via "
"some form of `self` usage. This makes things a bit trickier:"
msgstr ""
"基本的な関数を解析するマクロはいいのですが、時にはメソッドや、何らかの形で "
"`self` を使ってオブジェクトを参照する関数も解析したいことがあります。これは少"
"し厄介です："

#: src/decl-macros/building-blocks/parsing.md:56
#, fuzzy
msgid "WIP"
msgstr "仕掛品"

#: src/decl-macros/building-blocks/parsing.md:58
#, fuzzy
msgid "Struct"
msgstr "構造"

#: src/decl-macros/building-blocks/parsing.md:60
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! struct_item_matcher {\n"
"    // Unit-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident;\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name;\n"
"    };\n"
"\n"
"    // Tuple-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident (\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~~^\n"
"                $field_vis:vis $field_ty:ty\n"
"    //          ^~~~~~a single field~~~~~~^\n"
"            ),*\n"
"        $(,)? );\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name (\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_ty\n"
"            ),*\n"
"        );\n"
"    };\n"
"\n"
"    // Named-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident {\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~!^\n"
"                $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"            ),*\n"
"        $(,)? }\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name {\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_name : $field_ty\n"
"            ),*\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Foo {\n"
"#       pub bar: i32,\n"
"#       baz: &'static str,\n"
"#       qux: f32\n"
"#    }\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Bar;\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) struct Baz (i32, pub f32, String);\n"
"#);\n"
"#fn main() {\n"
"#    let _: Foo = Foo { bar: 42, baz: \"macros can be nice\", qux: 3.14, };\n"
"#    let _: Bar = Bar;\n"
"#    let _: Baz = Baz(2, 0.1234, String::new());\n"
"#}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ struct_item_matcher {\n"
"    // ユニット構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident；\n"
"    ) => {\n"
"        ( $( #[$meta] )* ) => { $vis struct $name: ident; ) => { $vis struct "
"$name: ident\n"
"        vis struct $name；\n"
"    };\n"
"\n"
"    // タプル構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident (\n"
"            $(\n"
"                フィールドの属性は以下のようになります。\n"
"    // フィールドの属性\n"
"                field_vis:vis $field_ty:ty\n"
"    // ^~~~~単一のフィールド~~~~~~^\n"
"            ),*\n"
"        $(,)?);\n"
"    ) => {\n"
"        $( #[$meta] )*。\n"
"        vis構造体 $name (\n"
"            $(\n"
"                $( #[$field_meta] )* $vis\n"
"                $field_vis $field_ty\n"
"            ),*\n"
"        );\n"
"    };\n"
"\n"
"    // 名前付き構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident { $vis:vis struct $name:ident { $vis:vis構"
"造体\n"
"            $(\n"
"                フィールドの属性\n"
"    // フィールドの属性\n"
"                field_vis:vis $field_name:ident : $field_ty:ty\n"
"    // ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"            ),*\n"
"        $(,)?}\n"
"    ) => {\n"
"        $( #[$meta] )*。\n"
"        構造体 $name { $vis\n"
"            $(\n"
"                $( #[$field_meta] )* $vis\n"
"                $field_vis $field_name : $field_ty\n"
"            ),*\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#struct_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) struct Foo {\n"
"# pub bar: i32、\n"
"# baz: &'static str、\n"
"# qux: f32\n"
"# }\n"
"#);\n"
"#struct_item_matcher!(\n"
"#[derive(Copy, Clone)].\n"
"# pub(crate) struct Bar；\n"
"#);\n"
"#struct_item_matcher!\n"
"#[derive(Clone)] # pub(crate) struct Bar; #); #struct_item_matcher!\n"
"# pub(crate) struct Baz (i32, pub f32, String)；\n"
"#);\n"
"#fn main() {\n"
"# let _：Foo = Foo { bar：42, baz：\"macros can be nice\", qux: 3.14, }；\n"
"# let _：Bar = Bar；\n"
"# let _：Baz = Baz(2, 0.1234, String::new())；\n"
"#}\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:140
#, fuzzy
msgid "Enum"
msgstr ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:142
#, fuzzy
msgid ""
"Parsing enums is a bit more complex than structs so we will finally make use "
"of some of the [patterns](../patterns.md) we have discussed, [Incremental TT "
"Muncher](../patterns/tt-muncher.md) and [Internal Rules](../patterns/"
"internal-rules.md). Instead of just building the parsed enum again we will "
"merely visit all the tokens of the enum, as rebuilding the enum would "
"require us to collect all the parsed tokens temporarily again via a [Push "
"Down Accumulator](../patterns/push-down-acc.md)."
msgstr ""
"列挙型の解析は構造体よりも少し複雑なので、最後に、これまで説明した [パターン]"
"(../patterns.md) の一部、[インクリメンタル TT マンチャー](../patterns/tt-"
"muncher.md) と [内部ルール](../patterns/internal-rules.md) を利用します。enum"
"を再構築するには、[Push Down Accumulator](../patterns/push-down-acc.md)を使っ"
"て、パースされたトークンを一時的に収集する必要があるからです。"

#: src/decl-macros/building-blocks/parsing.md:145
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! enum_item_matcher {\n"
"    // tuple variant\n"
"    (@variant $variant:ident (\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~~^\n"
"            $field_vis:vis $field_ty:ty\n"
"    //      ^~~~~~a single field~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    ) $(, $($tt:tt)* )? ) => {\n"
"\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // named variant\n"
"    (@variant $variant:ident {\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~!^\n"
"            $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    } $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // unit variant\n"
"    (@variant $variant:ident $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // trailing comma\n"
"    (@variant ,) => {};\n"
"    // base case\n"
"    (@variant) => {};\n"
"    // entry point\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"        $vis:vis enum $name:ident {\n"
"            $($tt:tt)*\n"
"        }\n"
"    ) => {\n"
"        enum_item_matcher!(@variant $($tt)*)\n"
"    };\n"
"}\n"
"\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Foo {\n"
"#        Bar,\n"
"#        Baz,\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Bar {\n"
"#        Foo(i32, f32),\n"
"#        Bar,\n"
"#        Baz(),\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) enum Baz {}\n"
"#);\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ enum_item_matcher { // タプルのバリアント\n"
"    // タプルのバリアント\n"
"    (@variant $variant:ident (\n"
"        $(\n"
"            フィールドの属性は以下のようになります。\n"
"    // フィールドの属性\n"
"            field_vis:vis $field_ty:ty\n"
"    // ^~~~~単一のフィールド~~~~~^ $( #[$field_meta:meta] ),* $(,?\n"
"        ),* $(,)?\n"
"    // ∨~~~入力の残り~~~∨\n"
"    ) $(, $($tt:tt)* )?) => {\n"
"\n"
"        // 残りの列挙を処理\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // 名前付きバリアント\n"
"    (@variant $variant:ident {)?\n"
"        $(\n"
"            $( #[$field_meta:meta] )* )?\n"
"    // フィールドの属性\n"
"            field_vis:vis $field_name:ident : $field_ty:ty\n"
"    // ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~入力の残り\n"
"    }$(, $($tt:tt)* )?) => {\n"
"        // 残りの列挙を処理\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // ユニットバリアント\n"
"    (@variant $variant:ident $(, $($tt:tt)* )?) => {\n"
"        // 残りの列挙型を処理します\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // 末尾のカンマ\n"
"    (@variant ,) => {}；\n"
"    // 基本の場合\n"
"    (@variant) => {}；\n"
"    // エントリ・ポイント\n"
"    (\n"
"        $$( #[$meta:meta] )*の場合\n"
"        vis:vis列挙型 $name:ident { $($tt:tt)\n"
"            $($tt:tt)*\n"
"        }\n"
"    ) => {\n"
"        enum_item_matcher！(@変数 $($tt)*)\n"
"    };\n"
"}\n"
"\n"
"#enum_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) enum Foo {.\n"
"# バー\n"
"# Baz、\n"
"# }\n"
"#);\n"
"#enum_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) enum Bar {.\n"
"# Foo(i32, f32)、\n"
"# Bar、\n"
"# Baz()、\n"
"# }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#[derive(Clone)] #.\n"
"# pub(crate) enum Baz {}.\n"
"#);\n"
"```"

#: src/decl-macros/macros2.md:3
#, fuzzy
msgid ""
"_RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-"
"macros.md)  \n"
"_Tracking Issue_: [rust#39412](https://github.com/rust-lang/rust/"
"issues/39412)  \n"
"_Feature_: `#![feature(decl_macro)]`"
msgstr ""
"RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-"
"macros.md)\n"
"_Tracking Issue_: [rust#39412](https://github.com/rust-lang/rust/"
"issues/39412)\n"
"_Feature_: `#![feature(decl_macro)]`."

#: src/decl-macros/macros2.md:7
#, fuzzy
msgid ""
"While not yet stable(or rather far from being finished), there is proposal "
"for a new declarative macro system that is supposed to replace `macro_rules!"
"` dubbed declarative macros 2.0, `macro`, `decl_macro` or confusingly also "
"`macros-by-example`."
msgstr ""
"まだ安定していませんが（というか、完成にはほど遠いですが）、宣言的マクロ2.0、"
"`macro`、`decl_macro`、あるいは紛らわしいですが`macros-by-example`と名付けら"
"れた `macro_rules!"

#: src/decl-macros/macros2.md:9
#, fuzzy
msgid ""
"This chapter is only meant to quickly glance over the current state, showing "
"how to use this macro system and where it differs. Nothing described here is "
"final or complete, and may be subject to change."
msgstr ""
"この章は、現状をざっと見渡し、このマクロシステムの使い方と異なる点を示すこと"
"を目的としています。ここに記載されている内容は最終的なものでも完全なものでも"
"なく、変更される可能性があります。"

#: src/decl-macros/macros2.md:12
#, fuzzy
msgid "Syntax"
msgstr "シンタックス"

#: src/decl-macros/macros2.md:14
#, fuzzy
msgid ""
"We'll do a comparison between the `macro` and `macro_rules` syntax for two "
"macros we have implemented in previous chapters:"
msgstr ""
"前の章で実装した2つのマクロについて、`macro`構文と`macro_rules`構文を比較して"
"みましょう："

#: src/decl-macros/macros2.md:16
#, fuzzy
msgid ""
"```rust\n"
"#![feature(decl_macro)]\n"
"\n"
"macro_rules! replace_expr_ {\n"
"    ($_t:tt $sub:expr) => { $sub }\n"
"}\n"
"macro replace_expr($_t:tt $sub:expr) {\n"
"    $sub\n"
"}\n"
"\n"
"macro_rules! count_tts_ {\n"
"    () => { 0 };\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 };\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 };\n"
"}\n"
"macro count_tts {\n"
"    () => { 0 },\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 },\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 },\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#特徴(decl_macro)]。\n"
"\n"
"macro_rules! replace_expr_ { ($_t:tt $sub:expr) => { $sub }.\n"
"    ($_t:tt $sub:expr) => { $sub }.\n"
"}\n"
"マクロ replace_expr($_t:tt $sub:expr) { { ($_t:tt $sub:expr)\n"
"    $sub\n"
"}\n"
"\n"
"マクロルール!\n"
"    () => { 0 };\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 };\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 };\n"
"}\n"
"マクロ count_tts {\n"
"    () => { 0 },\n"
"    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 },\n"
"    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 },\n"
"}\n"
"```"

#: src/decl-macros/macros2.md:38
#, fuzzy
msgid ""
"As can be seen, they look very similar, with just a few differences as well "
"as that `macro`s have two different forms."
msgstr ""
"ご覧のように、両者は非常によく似ていますが、マクロには2つの異なる形があること"
"だけが少し違います。"

#: src/decl-macros/macros2.md:40
#, fuzzy
msgid ""
"Let's inspect the `count_tts` macro first, as that one looks more like what "
"we are used to. As can be seen, it practically looks identical to the "
"`macro_rules` version with two exceptions, it uses the `macro` keyword and "
"the rule separator is a `,` instead of a `;`."
msgstr ""
"まず `count_tts` マクロを見てみましょう。見てわかるように、実質的に "
"`macro_rules` バージョンと同じように見えますが、2つの例外があります。"

#: src/decl-macros/macros2.md:43
#, fuzzy
msgid ""
"There is a second form to this though, which is a shorthand for macros that "
"only have one rule. Taking a look at `replace_expr` we can see that in this "
"case we can write the definition in a way that more resembles an ordinary "
"function. We can write the matcher directly after the name followed by the "
"transcriber, dropping a pair of braces and the `=>` token."
msgstr ""
"これは1つのルールしか持たないマクロの省略記法です。replace_expr`を見てみる"
"と、この場合は普通の関数に近い形で定義を書くことができることがわかります。中"
"括弧と `=>` トークンを削除して、名前の後に直接マッチャーを書くことができま"
"す。"

#: src/decl-macros/macros2.md:47
#, fuzzy
msgid ""
"Syntax for invoking `macro`s is the same as for `macro_rules` and function-"
"like procedural macros, the name followed by a `!` followed by the macro "
"input token tree."
msgstr ""
"マクロを呼び出す構文は `macro_rules` や関数のような手続き型マクロと同じで、名"
"前の後に `!"

#: src/decl-macros/macros2.md:49
#, fuzzy
msgid "`macro` are proper items"
msgstr "マクロ`は適切なアイテムです。"

#: src/decl-macros/macros2.md:51
#, fuzzy
msgid ""
"Unlike with `macro_rules` macros, which are textually scoped and require "
"`#[macro_export]`(and potentially a re-export) to be treated as an item, "
"`macro` macros behave like proper rust items by default."
msgstr ""
"macro_rules`マクロはテキストでスコープされ、アイテムとして扱うには "
"`#[macro_export]` (そして潜在的には再エクスポート)が必要ですが、`macro`マクロ"
"はデフォルトで適切なRustアイテムのように振る舞います。"

#: src/decl-macros/macros2.md:53
#, fuzzy
msgid ""
"As such, you can properly qualify them with visibility specifiers like "
"`pub`, `pub(crate)`, `pub(in path)` and the like."
msgstr ""
"そのため、`pub`、`pub(crate)`、`pub(in path)`などの可視性指定子で適切に修飾す"
"ることができます。"

#: src/decl-macros/macros2.md:58
#, fuzzy
msgid ""
"Hygiene is by far the biggest difference between the two declarative macro "
"systems. Unlike `macro_rules` which have [mixed site hygiene](./minutiae/"
"hygiene.md), `macro` have definition site hygiene, meaning they do not leak "
"identifiers outside of their invocation."
msgstr ""
"2つの宣言型マクロシステムの最大の違いは衛生です。混合サイトハイジーン](./"
"minutiae/hygiene.md)を持つ `macro_rules` とは異なり、`macro` は定義サイトハイ"
"ジーンを持っています。"

#: src/decl-macros/macros2.md:61
#, fuzzy
msgid ""
"As such the following compiles with a `macro_rules` macro, but fails with a "
"`macro` definition:"
msgstr ""
"そのため、`macro_rules`マクロを使うと次のようにコンパイルされますが、`macro`"
"定義では失敗します："

#: src/decl-macros/macros2.md:63
#, fuzzy
msgid ""
"```rust\n"
"#![feature(decl_macro)]\n"
"// try uncommenting the following line, and commenting out the line right "
"after\n"
"\n"
"macro_rules! foo {\n"
"// macro foo {\n"
"    ($name: ident) => {\n"
"        pub struct $name;\n"
"\n"
"        impl $name {\n"
"            pub fn new() -> $name {\n"
"                $name\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foo!(Foo);\n"
"\n"
"fn main() {\n"
"    // this fails with a `macro`, but succeeds with a `macro_rules`\n"
"    let foo = Foo::new();\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#![feature(decl_macro)]]。\n"
"// 以下の行のコメントを外し、直後の行をコメントアウトしてみてください。\n"
"\n"
"macro_rules!\n"
"// マクロ foo {\n"
"    ($name: ident) => {\n"
"        pub struct $name；\n"
"\n"
"        impl $name {\n"
"            pub fn new() -> $name { {.\n"
"                名前\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foo!\n"
"\n"
"fn main() {\n"
"    // これは `macro` では失敗しますが、`macro_rules` では成功します。\n"
"    let foo = Foo::new()；\n"
"}\n"
"```"

#: src/decl-macros/macros2.md:88
#, fuzzy
msgid ""
"There may be plans to allow escaping hygiene for identifiers(hygiene "
"bending) in the future."
msgstr ""
"将来的には、識別子のエスケープハイジーン(ハイジーンベンディング)を許可する計"
"画があるかもしれません。"

#: src/proc-macros.md:3
#, fuzzy
msgid "Note: This section is still very incomplete!"
msgstr "注：このセクションはまだ非常に不完全です！"

#: src/proc-macros.md:5
#, fuzzy
msgid ""
"This chapter will introduce Rust's second syntax extension type, _procedural "
"macros_."
msgstr ""
"この章では、Rustの2番目の構文拡張タイプである_procedural macros_を紹介しま"
"す。"

#: src/proc-macros.md:7
#, fuzzy
msgid ""
"As with the [declarative macros](./decl-macros.md) chapter, this one is also "
"split into a [methodical](./proc-macros/methodical.md) and a (WIP) practical "
"subchapter with the former being a more formal introduction and the latter "
"being a more practical oriented one."
msgstr ""
"宣言的マクロ](./decl-macros.md)の章と同様に、この章も[方法論](./proc-macros/"
"methodical.md)と(WIP)実践的な小章に分かれており、前者はより形式的な紹介で、後"
"者はより実践的なものです。"

#: src/proc-macros.md:9
#, fuzzy
msgid ""
"A lot of the basic information covered has been sourced from the [rust "
"reference](https://doc.rust-lang.org/nightly/reference/introduction.html), "
"as most knowledge about procedural macros is currently located there."
msgstr ""
"基本的な情報の多くは、[錆のリファレンス](https://doc.rust-lang.org/nightly/"
"reference/introduction.html) を参照しています。"

#: src/proc-macros/methodical.md:3
#, fuzzy
msgid ""
"This chapter will introduce Rust's procedural macro system by explaining the "
"system as a whole."
msgstr ""
"この章では、Rustの手続き型マクロシステムを紹介し、システム全体を説明します。"

#: src/proc-macros/methodical.md:5
#, fuzzy
msgid ""
"Unlike a [declarative macro](../decl-macros.md), a procedural macro takes "
"the form of a Rust function taking in a token stream(or two) and outputting "
"a token stream."
msgstr ""
"宣言型マクロ](../decl-macros.md)とは異なり、手続き型マクロは、トークンスト"
"リーム(または2つ)を取り込み、トークンストリームを出力するRust関数の形をとりま"
"す。"

#: src/proc-macros/methodical.md:7
#, fuzzy
msgid ""
"A proc-macro is at its core just a function exported from a crate with the "
"`proc-macro` [crate type](https://doc.rust-lang.org/reference/linkage.html), "
"so when writing multiple proc macros you can have them all live in one crate."
msgstr ""
"proc-macroは、基本的には`proc-macro` [crate type](https://doc.rust-lang.org/"
"reference/linkage.html)を持つcrateからエクスポートされる関数です。複数のproc"
"マクロを書く場合、それらを1つのcrateにまとめることができます。"

#: src/proc-macros/methodical.md:9
#, fuzzy
msgid ""
"**Note**: When using Cargo, to define a `proc-macro` crate you define and "
"set the `lib.proc-macro` key in the `Cargo.toml` to true."
msgstr ""
"**注意**：Cargo を使用する場合、`proc-macro` クレートを定義するには、`Cargo."
"toml` で `lib.proc-macro` キーを定義して true に設定します。"

#: src/proc-macros/methodical.md:10
#, fuzzy
msgid ""
"```toml\n"
"[lib]\n"
"proc-macro = true\n"
"```"
msgstr ""
"``toml\n"
"[lib]\n"
"proc-macro = true\n"
"```"

#: src/proc-macros/methodical.md:15
#, fuzzy
msgid ""
"A `proc-macro` type crate implicitly links to the compiler-provided "
"[proc_macro](https://doc.rust-lang.org/proc_macro/index.html) crate, which "
"contains all the things you need to get going with developing procedural "
"macros. The two most important types exposed by the crate are the "
"[`TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream."
"html), which are the proc-macro variant of the already familiar token trees "
"as well as the [`Span`](https://doc.rust-lang.org/proc_macro/struct.Span."
"html), which describes a part of source code used primarily for error "
"reporting and hygiene. See the [Hygiene and Spans](./hygiene.md) chapter for "
"more information."
msgstr ""
"proc-macro` 型の木枠はコンパイラが提供する [proc_macro](https://doc.rust-"
"lang.org/proc_macro/index.html) 木枠に暗黙的にリンクしています。このクレート"
"によって公開される2つの最も重要な型は、[`TokenStream`](https://doc.rust-lang."
"org/proc_macro/struct.TokenStream.html)です。これは、すでにおなじみのトークン"
"ツリーの proc-macro バリアントであり、[`Span`](https://doc.rust-lang.org/"
"proc_macro/struct.Span.html)は、主にエラーレポートとハイジーンに使用される"
"ソースコードの一部を記述します。詳しくは[Hygiene and Spans](./hygiene.md)の章"
"を参照してください。"

#: src/proc-macros/methodical.md:18
#, fuzzy
msgid ""
"As proc-macros therefore are functions living in a crate, they can be "
"addressed as all the other items in a Rust project. All thats required to "
"add the crate to the dependency graph of a project and bring the desired "
"item into scope."
msgstr ""
"したがって、proc-macrosはクレート内に存在する関数であるため、Rustプロジェクト"
"の他のすべての項目と同様に扱うことができます。必要なのは、プロジェクトの依存"
"関係グラフにクレートを追加し、目的のアイテムをスコープに入れることだけです。"

#: src/proc-macros/methodical.md:21
#, fuzzy
msgid ""
"**Note**: Procedural macros invocations still run at the same stage in the "
"compiler expansion-wise as declarative macros, just that they are standalone "
"Rust programs that the compiler compiles, runs, and finally either replaces "
"or appends to."
msgstr ""
"**注意**：注***: 手続き型マクロの呼び出しは、宣言型マクロと同じようにコンパイ"
"ラの拡張ステージで実行されます。"

#: src/proc-macros/methodical.md:24
#, fuzzy
msgid "Types of procedural macros"
msgstr "手続き型マクロの種類"

#: src/proc-macros/methodical.md:26
#, fuzzy
msgid ""
"With procedural macros, there actually exists 3 different kinds with each "
"having slightly different properties."
msgstr ""
"プロシージャル・マクロには、実際には3つの種類があり、それぞれ少しずつ性質が異"
"なります。"

#: src/proc-macros/methodical.md:27
#, fuzzy
msgid ""
"_function-like_ proc-macros which are used to implement `$name ! $arg` "
"invocable macros"
msgstr ""
"関数に似た proc マクロで、 `$name ！arg` を実装するために使われる proc マクロ"
"です。"

#: src/proc-macros/methodical.md:28
#, fuzzy
msgid ""
"_attribute_ proc-macros which are used to implement `#[$arg]` attributes"
msgstr "`#[$arg]` 属性を実装するために使われる _attribute_ proc-macros"

#: src/proc-macros/methodical.md:29
#, fuzzy
msgid ""
"_derive_ proc-macros which are used to implement a derive, an _input_ to a "
"`#[derive(…)]` attribute"
msgstr ""
"deriveを実装するために使用される_derive_ proc-macros、`#[derive(...)]`属性へ"
"の_input_。"

#: src/proc-macros/methodical.md:31
#, fuzzy
msgid ""
"At their core, all 3 work almost the same with a few differences in their "
"inputs and output reflected by their function definition. As mentioned all a "
"procedural macro really is, is a function that maps a token stream so let's "
"take a quick look at each basic definition and their differences."
msgstr ""
"核となる部分は3つともほとんど同じですが、関数の定義によって入出力に若干の違い"
"があります。前述したように、手続き型マクロの本質はトークンストリームをマッピ"
"ングする関数です。"

#: src/proc-macros/methodical.md:34
#, fuzzy
msgid "_function-like_"
msgstr "\"機能的な"

#: src/proc-macros/methodical.md:35
#, fuzzy
msgid ""
"```rs\n"
"#[proc_macro]\n"
"pub fn my_proc_macro(input: TokenStream) -> TokenStream {\n"
"    TokenStream::new()\n"
"}\n"
"```"
msgstr ""
"``rs\n"
"#[proc_macro］\n"
"pub fn my_proc_macro(input: TokenStream) -> TokenStream { {.\n"
"    TokenStream::new()\n"
"}\n"
"```"

#: src/proc-macros/methodical.md:42
#, fuzzy
msgid "_attribute_"
msgstr "属性"

#: src/proc-macros/methodical.md:43
#, fuzzy
msgid ""
"```rs\n"
"#[proc_macro_attribute]\n"
"pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -> "
"TokenStream {\n"
"    TokenStream::new()\n"
"}\n"
"```"
msgstr ""
"``rs\n"
"#[proc_macro_attribute] を参照してください。\n"
"pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -> "
"TokenStream { {.\n"
"    TokenStream::new()\n"
"}\n"
"```"

#: src/proc-macros/methodical.md:50
#, fuzzy
msgid "_derive_"
msgstr "{cH0000ffff}ありがとう"

#: src/proc-macros/methodical.md:51
#, fuzzy
msgid ""
"```rs\n"
"#[proc_macro_derive(MyDerive)]\n"
"pub fn my_derive(annotated_item: TokenStream) -> TokenStream {\n"
"    TokenStream::new()\n"
"}\n"
"```"
msgstr ""
"``rs\n"
"#[proc_macro_derive(MyDerive)] を参照してください。\n"
"pub fn my_derive(annotated_item: TokenStream) -> TokenStream { {.\n"
"    TokenStream::new()\n"
"}\n"
"```"

#: src/proc-macros/methodical.md:58
#, fuzzy
msgid ""
"As shown, the basic structure is the same for each, a public function marked "
"with an attribute defining its procedural macro type returning a "
"`TokenStream`. Note how the return type is a `TokenStream` and not a result "
"or something else that gives the notion of being fallible. This does not "
"mean that proc-macros cannot fail though, in fact they have two ways of "
"reporting errors, the first one being to panic and the second to emit a "
"[`compile_error!`](https://doc.rust-lang.org/std/macro.compile_error.html) "
"invocation. If a proc-macro panics the compiler will catch it and emit the "
"payload as an error coming from the macro invocation."
msgstr ""
"このように、基本的な構造はそれぞれ同じで、手続き型マクロの型を定義する属性で"
"マークされたパブリック関数が `TokenStream` を返します。戻り値の型が "
"`TokenStream` であり、結果や何か他のものではないことに注意してください。しか"
"し、これは proc マクロが失敗しないという意味ではありません。実際、proc マクロ"
"にはエラーを報告する 2 つの方法があり、1 つ目はパニックを起こす方法、2 つ目"
"は [`compile_error!`](https://doc.rust-lang.org/std/macro.compile_error."
"html) を呼び出す方法です。proc-macro がパニックを起こした場合、コンパイラはそ"
"れをキャッチし、マクロの呼び出しによるエラーとしてペイロードを出します。"

#: src/proc-macros/methodical.md:63
#, fuzzy
msgid ""
"**Beware**: The compiler will happily hang on endless loops spun up inside "
"proc-macros causing the compilation of crates using the proc-macro to hang "
"as well."
msgstr ""
"**注意してください**：注意**: コンパイラーはプロック・マクロの中で紡ぎ出され"
"る無限ループに喜んでハングし、プロック・マクロを使用するクレートのコンパイル"
"もハングします。"

#: src/proc-macros/methodical/function-like.md:3
#, fuzzy
msgid ""
"Function-like procedural macros are invoked like declarative macros that is "
"`makro!(…)`."
msgstr "関数のような手続き型マクロは、宣言型マクロのように `makro!"

#: src/proc-macros/methodical/function-like.md:5
#, fuzzy
msgid ""
"This type of macro is the simplest of the three though. It is also the only "
"one which you can't differentiate from declarative macros when solely "
"looking at the invocation."
msgstr ""
"しかし、このタイプのマクロは3つの中で最も単純です。また、呼び出しを見ただけで"
"は宣言型マクロと区別できない唯一のものです。"

#: src/proc-macros/methodical/function-like.md:8
#, fuzzy
msgid ""
"A simple skeleton of a function-like procedural macro looks like the "
"following:"
msgstr "関数のような手続き型マクロの簡単な骨格は以下のようになります："

#: src/proc-macros/methodical/function-like.md:9
#, fuzzy
msgid ""
"```rs\n"
"use proc_macro::TokenStream;\n"
"\n"
"#[proc_macro]\n"
"pub fn tlborm_fn_macro(input: TokenStream) -> TokenStream {\n"
"    input\n"
"}\n"
"```"
msgstr ""
"rs\n"
"proc_macro::TokenStream を使用します；\n"
"\n"
"#[proc_macro］\n"
"pub fn tlborm_fn_macro(input: TokenStream) -> TokenStream { {.\n"
"    input\n"
"}\n"
"```"

#: src/proc-macros/methodical/function-like.md:18
#, fuzzy
msgid ""
"As one can see this is in fact just a mapping from one [`TokenStream`]"
"(https://doc.rust-lang.org/proc_macro/struct.TokenStream.html) to another "
"where the `input` will be the tokens inside of the invocation delimiters, e."
"g. for an example invocation `foo!(bar)` the input token stream would "
"consist of the `bar` token. The returned token stream will **replace** the "
"macro invocation."
msgstr ""
"これは実際には、ある [`TokenStream`](https://doc.rust-lang.org/proc_macro/"
"struct.TokenStream.html) から別の [`TokenStream`](https://doc.rust-lang.org/"
"proc_macro/struct.TokenStream.html) へのマッピングに過ぎません。`input` は呼"
"び出しの区切り文字の中にあるトークンになります。例えば、`foo!(bar)` という呼"
"び出しの例では、入力トークン ストリームは `bar` トークンで構成されます。返さ"
"れるトークンストリームはマクロを **置き換えます** 。"

#: src/proc-macros/methodical/function-like.md:21
#, fuzzy
msgid ""
"For this macro type the same placement and expansion rules apply as for "
"declarative macros, that is the macro must output a correct token stream for "
"the invocation location. Unlike with declarative macros though, function-"
"like procedural macros do not have certain restrictions imposed on their "
"inputs though. That is the restrictions for what may follow fragment "
"specifiers listed in the [Metavariables and Expansion Redux](../../decl-"
"macros/minutiae/metavar-and-expansion.md) chapter listed is not applicable "
"here, as the procedural macros work on the tokens directly instead of "
"matching them against fragment specifiers or similar."
msgstr ""
"つまり、マクロは呼び出し位置に対して正しいトークンストリームを出力しなければ"
"なりません。しかし、宣言型マクロとは異なり、関数型手続きマクロでは、入力に特"
"定の制限が課されることはありません。つまり、[Metavariables and Expansion "
"Redux](../../decl-macros/minutiae/metavar-and-expansion.md)の章に記載されてい"
"る、フラグメント指定子の後に続くものの制限は、ここでは適用されません。"

#: src/proc-macros/methodical/function-like.md:25
#, fuzzy
msgid ""
"With that said it is apparent that the procedural counter part to these "
"macros is more powerful as they can arbitrarily modify their input, and "
"produce any output desired as long as its within the bounds of the language "
"syntax."
msgstr ""
"とはいえ、これらのマクロに対応する手続き的な部分がより強力であることは明らか"
"です。マクロは入力を任意に変更することができ、言語構文の範囲内であればどんな"
"出力でも出すことができるからです。"

#: src/proc-macros/methodical/function-like.md:29
#: src/proc-macros/methodical/attr.md:26
#: src/proc-macros/methodical/derive.md:20
#: src/proc-macros/methodical/derive.md:50
#, fuzzy
msgid "Usage example:"
msgstr "使用例"

#: src/proc-macros/methodical/function-like.md:30
#, fuzzy
msgid ""
"```rs\n"
"use tlborm_proc::tlborm_attribute;\n"
"\n"
"fn foo() {\n"
"    tlborm_attribute!(be quick; time is mana);\n"
"}\n"
"```"
msgstr ""
"rs\n"
"tlborm_proc::tlborm_attribute を使用します；\n"
"\n"
"fn foo() {\n"
"    tlborm_attribute!(be quick; time is mana)；\n"
"}\n"
"```"

#: src/proc-macros/methodical/attr.md:3
#, fuzzy
msgid ""
"Attribute procedural macros define new _outer_ attributes which can be "
"attached to items. This type can be invoked with the `#[attr]` or "
"`#[attr(…)]` syntax where `…` is an arbitrary token tree."
msgstr ""
"属性手続きマクロはアイテムに付加できる新しい_outer_属性を定義します。この型"
"は `#[attr]` または `#[attr(...)]` 構文で呼び出すことができます。"

#: src/proc-macros/methodical/attr.md:6
#, fuzzy
msgid ""
"A simple skeleton of an attribute procedural macro looks like the following:"
msgstr "属性プロシージャマクロの簡単なスケルトンは以下のようになります："

#: src/proc-macros/methodical/attr.md:7
#, fuzzy
msgid ""
"```rs\n"
"use proc_macro::TokenStream;\n"
"\n"
"#[proc_macro_attribute]\n"
"pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -> "
"TokenStream {\n"
"    annotated_item\n"
"}\n"
"```"
msgstr ""
"rs\n"
"proc_macro::TokenStream を使用します；\n"
"\n"
"proc_macro_attribute] #[proc_macro_attribute\n"
"pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -> "
"TokenStream {.\n"
"    注釈付き項目\n"
"}\n"
"```"

#: src/proc-macros/methodical/attr.md:16
#, fuzzy
msgid ""
"Of note here is that unlike the other two procedural macro kinds, this one "
"has two input parameters instead of one."
msgstr ""
"ここで注目すべきは、他の2種類の手続き型マクロとは異なり、このマクロには入力パ"
"ラメーターが1つではなく2つあるということです。"

#: src/proc-macros/methodical/attr.md:17
#, fuzzy
msgid ""
"The first parameter is the delimited token tree following the attribute's "
"name, excluding the delimiters around it. It is empty if the attribute is "
"written bare, that is just a name without a `(TokenTree)` following it, e.g. "
"`#[attr]`."
msgstr ""
"最初のパラメータは、属性名に続く区切られたトークンツリーです。例えば、 "
"`#[attr]`."

#: src/proc-macros/methodical/attr.md:19
#, fuzzy
msgid ""
"The second token stream is the item the attribute is attached to _without_ "
"the attribute this proc macro defines. As this is an [`active`](https://doc."
"rust-lang.org/reference/attributes.html#active-and-inert-attributes) "
"attribute, the attribute will be stripped from the item before it is being "
"passed to the proc macro."
msgstr ""
"2つ目のトークンストリームは、この proc マクロが定義するアトリビュートを除い"
"た、アトリビュートがアタッチされているアイテムです。これは[`active`](https://"
"doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes)属性"
"なので、属性はprocマクロに渡される前にアイテムから取り除かれます。"

#: src/proc-macros/methodical/attr.md:22
#, fuzzy
msgid ""
"The returned token stream will **replace** the annotated item fully. Note "
"that the replacement does not have to be a single item, it can be 0 or more."
msgstr ""
"返されたトークンストリームは、アノテーションされた項目を完全に **置換** しま"
"す。置換される項目は1つである必要はなく、0個以上でもよいことに注意してくださ"
"い。"

#: src/proc-macros/methodical/attr.md:27
#, fuzzy
msgid ""
"```rs\n"
"use tlborm_proc::tlborm_attribute;\n"
"\n"
"#[tlborm_attribute]\n"
"fn foo() {}\n"
"\n"
"#[tlborm_attribute(attributes are pretty handsome)]\n"
"fn bar() {}\n"
"```"
msgstr ""
"rs\n"
"tlborm_proc::tlborm_attribute を使用します；\n"
"\n"
"#[tlborm_attribute］\n"
"fn foo() [0］\n"
"\n"
"#[tlborm_attribute(attribute is pretty handsome)] fn bar() {}.\n"
"fn bar() [1］\n"
"```"

#: src/proc-macros/methodical/derive.md:3
#, fuzzy
msgid ""
"Derive procedural macros define new inputs for the [`derive`](https://doc."
"rust-lang.org/reference/attributes/derive.html) attribute. This type can be "
"invoked by feeding it to a derive attribute's input, e.g. "
"`#[derive(TlbormDerive)]`."
msgstr ""
"Derive 手続き型マクロは、[`derive`](https://doc.rust-lang.org/reference/"
"attributes/derive.html) 属性の新しい入力を定義します。この型は "
"`#[derive(TlbormDerive)]` のようにderive属性の入力に与えることで呼び出すこと"
"ができます。"

#: src/proc-macros/methodical/derive.md:6
#, fuzzy
msgid ""
"A simple skeleton of a derive procedural macro looks like the following:"
msgstr "派生プロシージャマクロの簡単なスケルトンは以下のようになります："

#: src/proc-macros/methodical/derive.md:7
#, fuzzy
msgid ""
"```rs\n"
"use proc_macro::TokenStream;\n"
"\n"
"#[proc_macro_derive(TlbormDerive)]\n"
"pub fn tlborm_derive(item: TokenStream) -> TokenStream {\n"
"    TokenStream::new()\n"
"}\n"
"```"
msgstr ""
"rs\n"
"proc_macro::TokenStream を使用します；\n"
"\n"
"#[proc_macro_derive(TlbormDerive)] を参照してください。\n"
"pub fn tlborm_derive(item: TokenStream) -> TokenStream { 次のようにします。\n"
"    TokenStream::new()\n"
"}\n"
"```"

#: src/proc-macros/methodical/derive.md:16
#, fuzzy
msgid ""
"The `proc_macro_derive` is a bit more special in that it requires an extra "
"identifier, this identifier will become the actual name of the derive proc "
"macro. The input token stream is the item the derive attribute is attached "
"to, that is, it will always be an `enum`, `struct` or `union` as these are "
"the only items a derive attribute can annotate. The returned token stream "
"will be **appended** to the containing block or module of the annotated item "
"with the requirement that the token stream consists of a set of valid items."
msgstr ""
"proc_macro_derive` は少し特殊で、特別な識別子を必要とします。入力されるトーク"
"ンストリームは、derive 属性がアタッチされるアイテムです。つまり、derive 属性"
"がアノテーションできるアイテムは `enum`、`struct`、`union` だけなので、常に "
"`enum`、`struct`、`union` になります。返されたトークンストリームは、アノテー"
"ションされたアイテムのブロックまたはモジュールに **付加** されます。"

#: src/proc-macros/methodical/derive.md:21
#, fuzzy
msgid ""
"```rs\n"
"use tlborm_proc::TlbormDerive;\n"
"\n"
"#[derive(TlbormDerive)]\n"
"struct Foo;\n"
"```"
msgstr ""
"``rs\n"
"tlborm_proc::TlbormDerive を使用します；\n"
"\n"
"#derive(TlbormDerive)]を使用します。\n"
"struct Foo；\n"
"```"

#: src/proc-macros/methodical/derive.md:28
#, fuzzy
msgid "Helper Attributes"
msgstr "ヘルパーの属性"

#: src/proc-macros/methodical/derive.md:30
#, fuzzy
msgid ""
"Derive proc macros are a bit more special in that they can add additional "
"attributes visible only in the scope of the item definition. These "
"attributes are called _derive macro helper attributes_ and are [inert]"
"(https://doc.rust-lang.org/reference/attributes.html#active-and-inert-"
"attributes). Their purpose is to give derive proc macros additional "
"customizability on a per field or variant basis, that is these attributes "
"can be used to annotate fields or enum variants while having no effect on "
"their own. As they are `inert` they will not be stripped and are visible to "
"all macros."
msgstr ""
"派生 proc マクロは少し特殊で、アイテム定義のスコープでのみ見える属性を追加す"
"ることができます。これらの属性は _derive macro helper attributes_ と呼ばれ、"
"[inert](https://doc.rust-lang.org/reference/attributes.html#active-and-inert-"
"attributes) です。これらの属性の目的は、derive proc マクロにフィールドやバリ"
"アントごとのカスタマイズ性を追加することです。これらの属性は `inert` なので、"
"取り除かれることはなく、すべてのマクロから見ることができます。"

#: src/proc-macros/methodical/derive.md:35
#, fuzzy
msgid ""
"They can be defined by adding an `attributes(helper0, helper1, ..)` argument "
"to the `proc_macro_derive` attribute containing a comma separated list of "
"identifiers which are the names of the helper attributes."
msgstr ""
"これらは `proc_macro_derive` 属性に `attributes(helper0, helper1, ...)` とい"
"う引数を追加することで定義することができます。"

#: src/proc-macros/methodical/derive.md:37
#, fuzzy
msgid ""
"Thus a simple skeleton of a derive procedural macro with helper attributes "
"looks like the following:"
msgstr ""
"このように、ヘルパー属性を持つderive手続き型マクロの簡単なスケルトンは以下の"
"ようになります："

#: src/proc-macros/methodical/derive.md:38
#, fuzzy
msgid ""
"```rs\n"
"use proc_macro::TokenStream;\n"
"\n"
"#[proc_macro_derive(TlbormDerive, attributes(tlborm_helper))]\n"
"pub fn tlborm_derive(item: TokenStream) -> TokenStream {\n"
"    TokenStream::new()\n"
"}\n"
"```"
msgstr ""
"rs\n"
"proc_macro::TokenStream を使用します；\n"
"\n"
"#proc_macro_derive(TlbormDerive, attributes(tlborm_helper))].\n"
"pub fn tlborm_derive(item: TokenStream) -> TokenStream "
"{ [proc_macro_derive(Tlborm_helper, attributes(tlborm_helper)]] #.\n"
"    TokenStream::new()\n"
"}\n"
"```"

#: src/proc-macros/methodical/derive.md:47
#, fuzzy
msgid ""
"That is all there is to helper attributes, to consume them in the proc macro "
"the implementation will then have to check the attributes of fields and "
"variants to see whether they are attributed with the corresponding helper. "
"It is an error to use a helper attribute if none of the used derive macros "
"of the given item declare it as such, as the compiler will then instead try "
"to resolve it as a normal attribute."
msgstr ""
"proc マクロでヘルパー属性を使うためには、実装はフィールドとバリアントの属性を"
"チェックして、対応するヘルパー属性があるかどうかを確認する必要があります。コ"
"ンパイラはそれを通常の属性として解決しようとします。"

#: src/proc-macros/methodical/derive.md:51
#, fuzzy
msgid ""
"```rs\n"
"use tlborm_proc::TlbormDerive;\n"
"\n"
"#[derive(TlbormDerive)]\n"
"struct Foo {\n"
"    #[tlborm_helper]\n"
"    field: u32\n"
"}\n"
"\n"
"#[derive(TlbormDerive)]\n"
"enum Bar {\n"
"    #[tlborm_helper]\n"
"    Variant { #[tlborm_helper] field: u32 }\n"
"}\n"
"```"
msgstr ""
"``rs\n"
"tlborm_proc::TlbormDerive を使用します；\n"
"\n"
"#[derive(TlbormDerive)] を参照してください。\n"
"struct Foo {\n"
"    #[tlborm_helper］\n"
"    field: u32\n"
"}\n"
"\n"
"#derive(TlbormDerive)]。\n"
"enum Bar {\n"
"    #[tlborm_helper] 変数 { #[tlborm_helper] field: u32 }.\n"
"    Variant { #[tlborm_helper] field: u32 }.\n"
"}\n"
"```"

#: src/proc-macros/third-party-crates.md:3
#, fuzzy
msgid ""
"**Note**: Crates beyond the automatically linked [`proc_macro`](https://doc."
"rust-lang.org/proc_macro/) crate are not required to write procedural "
"macros. The crates listed here merely make writing them simpler and more "
"concise, while potentially adding to the compilation time of the procedural "
"macro due to added dependencies."
msgstr ""
"**注意**：自動的にリンクされる [`proc_macro`](https://doc.rust-lang.org/"
"proc_macro/) 以外のクレートは、手続き型マクロを書くために必要ではありません。"
"ここに列挙されたクレートは、手続き型マクロのコンパイル時間を増加させる可能性"
"がある一方で、手続き型マクロの記述をより単純で簡潔にするだけです。"

#: src/proc-macros/third-party-crates.md:6
#, fuzzy
msgid ""
"As procedural macros live in a crate they can naturally depend on ([crates."
"io](https://crates.io/)) crates. turns out the crate ecosystem has some "
"really helpful crates tailored towards procedural macros that this chapter "
"will quickly go over, most of which will be used in the following chapters "
"to implement the example macros. As these are merely quick introductions it "
"is advised to look at each crate's documentation for more in-depth "
"information if required."
msgstr ""
"手続きマクロはクレートの中にあるので、当然([crates.io](https://crates.io/))ク"
"レートに依存することができます。クレートエコシステムには、手続きマクロのため"
"に調整された本当に便利なクレートがいくつかあるので、この章では簡単に説明しま"
"す。これらは単なる簡単な紹介なので、必要であれば、より詳細な情報を得るために"
"各クレートのドキュメントを見ることをお勧めします。"

#: src/proc-macros/third-party-crates.md:10
#, fuzzy
msgid "[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)"
msgstr "[proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)"

#: src/proc-macros/third-party-crates.md:12
#, fuzzy
msgid ""
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/), the successor "
"of the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate! Or so "
"you might think but that is of course not correct, the name might be a bit "
"misleading. This crate is actually just a wrapper around the [`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/) crate serving two specific purposes, "
"taken from the documentation:"
msgstr ""
"[proc_macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)は、[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)の後継クレートです！と思うかもしれませ"
"んが、それはもちろん正しくありません。このクレートは実際には[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)クレートのラッパーに過ぎず、ドキュメン"
"トから引用した2つの特定の目的を果たします："

#: src/proc-macros/third-party-crates.md:14
#, fuzzy
msgid ""
"Bring proc-macro-like functionality to other contexts like build.rs and main."
"rs."
msgstr ""
"build.rsやmain.rsのような他のコンテキストにproc-macroのような機能をもたらしま"
"す。"

#: src/proc-macros/third-party-crates.md:15
#, fuzzy
msgid "Make procedural macros unit testable."
msgstr "手続き型マクロをユニットテスト可能に"

#: src/proc-macros/third-party-crates.md:17
#, fuzzy
msgid ""
"As the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate is "
"exclusive to [`proc_macro`](https://doc.rust-lang.org/proc_macro/) type "
"crates, making them unit testable or accessing them from non-proc macro code "
"is next to impossible. With that in mind the [`proc-macro2`](https://docs.rs/"
"proc-macro2/*/proc_macro2/) crate mimics the original [`proc_macro`](https://"
"doc.rust-lang.org/proc_macro/) crate's api, acting as a wrapper in proc-"
"macro crates and standing on its own in non-proc-macro crates. Hence it is "
"advised to build libraries targeting proc-macro code to be built against "
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/) instead as that "
"will enable those libraries to be unit testable, which is also the reason "
"why the following listed crates take and emit [`proc-macro2::TokenStream`]"
"(https://docs.rs/proc-macro2/1.0.27/proc_macro2/struct.TokenStream.html)s "
"instead. When a `proc_macro` token stream is required, one can simply `."
"into()` the `proc-macro2` token stream to get the `proc_macro` version and "
"vice-versa."
msgstr ""
"proc_macro`](https://doc.rust-lang.org/proc_macro/)クレートは[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)タイプのクレートと排他的であるため、そ"
"れらをユニットテスト可能にしたり、非procマクロコードからアクセスすることは不"
"可能に近いです。この点を考慮して、[`proc-macro2`](https://docs.rs/proc-"
"macro2/*/proc_macro2/) クレートはオリジナルの [`proc_macro`](https://doc."
"rust-lang.org/proc_macro/) クレートの API を模倣し、proc-macro クレートでは"
"ラッパーとして動作し、proc-macro 以外のクレートでは単独で動作します。したがっ"
"て、proc-macro コードをターゲットにしたライブラリは、[`proc-macro2`](https://"
"docs.rs/proc-macro2/*/proc_macro2/) に対してビルドすることをお勧めします。"
"proc_macro` のトークンストリームが必要な場合、単純に `proc-macro2` のトークン"
"ストリームを `.into()` して `proc_macro` バージョンを取得することができます。"

#: src/proc-macros/third-party-crates.md:22
#, fuzzy
msgid ""
"Procedural macros using the `proc-macro2` crate will usually import the "
"`proc-macro2::TokenStream` in an aliased form like `use proc-macro2::"
"TokenStream as TokenStream2`."
msgstr ""
"proc-macro2` クレートを使用する手続き型マクロは、通常 `proc-macro2::"
"TokenStream` を `use proc-macro2::TokenStream as TokenStream2` のようなエイリ"
"アス形式でインポートします。"

#: src/proc-macros/third-party-crates.md:24
#, fuzzy
msgid "[`quote`](https://docs.rs/quote/*/quote/)"
msgstr "[`quote`](https://docs.rs/quote/*/quote/)"

#: src/proc-macros/third-party-crates.md:26
#, fuzzy
msgid ""
"The [`quote`](https://docs.rs/quote/*/quote/) crate mainly exposes just one "
"macro, the [`quote!`](https://docs.rs/quote/1/quote/macro.quote.html) macro."
msgstr ""
"quote`](https://docs.rs/quote/*/quote/)クレートは主に1つのマクロ、[`quote!`]"
"(https://docs.rs/quote/1/quote/macro.quote.html)マクロだけを公開します。"

#: src/proc-macros/third-party-crates.md:28
#, fuzzy
msgid ""
"This little macro allows you to easily create token streams by writing the "
"actual source out as syntax while also giving you the power of interpolating "
"tokens right into the written syntax. [Interpolation](https://docs.rs/"
"quote/1/quote/macro.quote.html#interpolation) can be done by using the "
"`#local` syntax where local refers to a local in the current scope. Likewise "
"`#( #local )*` can be used to interpolate over an iterator of types that "
"implement [`ToTokens`](https://docs.rs/quote/1/quote/trait.ToTokens.html), "
"this works similar to declarative `macro_rules!` repetitions in that they "
"allow a separator as well as extra tokens inside the repetition."
msgstr ""
"この小さなマクロを使うと、実際のソースを構文として書き出すことでトークン スト"
"リームを簡単に作成することができます。[補間](https://docs.rs/quote/1/quote/"
"macro.quote.html#interpolation) は `#local` 構文を使うことで行えます。local "
"は現在のスコープ内の local を指します。同様に `#( #local )*` を使うと、"
"[`ToTokens`](https://docs.rs/quote/1/quote/trait.ToTokens.html) を実装してい"
"る型のイテレータを補間することができます。これは宣言的な `macro_rules!` の繰"
"り返しに似ていて、繰り返しの中に余分なトークンだけでなくセパレータを置くこと"
"ができます。"

#: src/proc-macros/third-party-crates.md:32
#, fuzzy
msgid ""
"```rs\n"
"let name = /* some identifier */;\n"
"let exprs = /* an iterator over expressions tokenstreams */;\n"
"let expanded = quote! {\n"
"    impl SomeTrait for #name { // #name interpolates the name local from "
"above\n"
"        fn some_function(&self) -> usize {\n"
"            #( #exprs )* // #name interpolates exprs by iterating the "
"iterator\n"
"        }\n"
"    }\n"
"};\n"
"```"
msgstr ""
"``rs\n"
"let name = /* ある識別子 */；\n"
"let exprs = /* 式のトークンストリームに対するイテレータ */；\n"
"let expanded = quote！{\n"
"    impl SomeTrait for #name { // #nameは上記のローカルな名前を補間します。\n"
"        fn some_function(&self) -> usize { #( #exprs )* *; let expanded = "
"quote!\n"
"            #( #exprs )* // #nameはイテレータを反復することでexprsを補間しま"
"す。\n"
"        }\n"
"    }\n"
"};\n"
"```"

#: src/proc-macros/third-party-crates.md:44
#, fuzzy
msgid ""
"This a very useful tool when preparing macro output avoiding the need of "
"creating a token stream by inserting tokens one by one."
msgstr ""
"これは、トークンを1つずつ挿入してトークンストリームを作成する必要をなくし、マ"
"クロ出力を準備する際に非常に便利なツールです。"

#: src/proc-macros/third-party-crates.md:46
#, fuzzy
msgid ""
"**Note**: As stated earlier, this crate makes use of `proc_macro2` and thus "
"the `quote!` macro returns a `proc-macro2::TokenStream`."
msgstr ""
"**注意**：前述したように、この木枠は `proc_macro2` を使用しているので、 "
"`quote!` マクロは `proc-macro2::TokenStream` を返します。"

#: src/proc-macros/third-party-crates.md:48
#, fuzzy
msgid "[`syn`](https://docs.rs/syn/*/syn/)"
msgstr "(https://docs.rs/syn/*/syn/)"

#: src/proc-macros/third-party-crates.md:50
#, fuzzy
msgid ""
"The [`syn`](https://docs.rs/syn/*/syn/) crate is a parsing library for "
"parsing a stream of Rust tokens into a syntax tree of Rust source code. It "
"is a very powerful library that makes parsing proc-macro input quite a bit "
"easier, as the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate "
"itself does not expose any kind of parsing capabilities, merely the tokens. "
"As the library can be a heavy compilation dependency, it makes heavy use of "
"feature gates to allow users to cut it as small as required."
msgstr ""
"syn`](https://docs.rs/syn/*/syn/)クレートは、RustトークンのストリームをRust"
"ソースコードの構文木にパースするためのパースライブラリです。proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/) クレート自身は構文解析機能を公開せ"
"ず、単にトークンを公開するだけなので、proc-macro 入力の構文解析を非常に簡単に"
"する非常に強力なライブラリです。このライブラリはコンパイル依存性が高いので、"
"ユーザが必要な分だけ小さくできるようにフィーチャーゲートを多用しています。"

#: src/proc-macros/third-party-crates.md:54
#, fuzzy
msgid "So what does it offer? A bunch of things."
msgstr "それで、何を提供してくれるのですか？いろいろあります。"

#: src/proc-macros/third-party-crates.md:56
#, fuzzy
msgid ""
"First of all it has definitions and parsing for all standard Rust syntax "
"nodes(when the `full` feature is enabled), as well as a [`DeriveInput`]"
"(https://docs.rs/syn/1/syn/struct.DeriveInput.html) type which encapsulates "
"all the information a derive macro gets passed as an input stream as a "
"structured input(requires the `derive` feature, enabled by default). These "
"can be used right out of the box with the [`parse_macro_input!`](https://"
"docs.rs/syn/1/syn/macro.parse_macro_input.html) macro(requires the `parsing` "
"and `proc-macro` features, enabled by default) to parse token streams into "
"these types."
msgstr ""
"また、[`DeriveInput`](https://docs.rs/syn/1/syn/struct.DeriveInput.html)型"
"は、deriveマクロが入力ストリームとして渡されるすべての情報を構造化入力として"
"カプセル化します(`derive`機能が必要で、デフォルトで有効になっています)。これ"
"らの型は、[`parse_macro_input!`](https://docs.rs/syn/1/syn/macro."
"parse_macro_input.html) マクロ(`parsing` と `proc-macro` 機能が必要です。デ"
"フォルトで有効になっています)を使用して、トークン・ストリームをこれらの型に"
"パースすることができます。"

#: src/proc-macros/third-party-crates.md:58
#, fuzzy
msgid ""
"If Rust syntax doesn't cut it, and instead one wishes to parse custom non-"
"Rust syntax the crate also offers a generic [parsing API](https://docs.rs/"
"syn/1/syn/parse/index.html), mainly in the form of the [`Parse`](https://"
"docs.rs/syn/1/syn/parse/trait.Parse.html) trait(requires the `parsing` "
"feature, enabled by default)."
msgstr ""
"Rust の構文では不十分で、Rust 以外のカスタム構文をパースしたい場合、このク"
"レートは汎用的な [パース API](https://docs.rs/syn/1/syn/parse/index.html) も"
"提供します。"

#: src/proc-macros/third-party-crates.md:60
#, fuzzy
msgid ""
"Aside from this the types exposed by the library keep location information "
"and spans which allows procedural macros to emit detailed error messages "
"pointing at the macro input at the points of interest."
msgstr ""
"これとは別に、ライブラリによって公開される型は、位置情報とスパンを保持しま"
"す。これにより、手続き型マクロは、関心のあるポイントでマクロ入力を指し示す詳"
"細なエラーメッセージを発することができます。"

#: src/proc-macros/third-party-crates.md:62
#, fuzzy
msgid ""
"As this is again a library for procedural macros, it makes use of the "
"`proc_macro2` token streams and spans and as such, conversions may be "
"required."
msgstr ""
"このライブラリも手続き型マクロのライブラリなので、 `proc_macro2` トークン・ス"
"トリームとスパンを使用します。"

#: src/proc-macros/hygiene.md:3
#, fuzzy
msgid ""
"This chapter talks about procedural macro [hygiene](../syntax-extensions/"
"hygiene.md) and the type that encodes it, [`Span`](https://doc.rust-lang.org/"
"proc_macro/struct.Span.html)."
msgstr ""
"この章では、手続き型マクロ[hygiene](../syntax-extensions/hygiene.md)と、それ"
"をエンコードする型である[`Span`](https://doc.rust-lang.org/proc_macro/struct."
"Span.html)について説明します。"

#: src/proc-macros/hygiene.md:5
#, fuzzy
msgid ""
"Every token in a [`TokenStream`](https://doc.rust-lang.org/proc_macro/struct."
"TokenStream.html) has an associated `Span` holding some additional info. A "
"span, as its documentation states, is `A region of source code, along with "
"macro expansion information`. It points into a region of the original source "
"code(important for displaying diagnostics at the correct places) as well as "
"holding the kind of _hygiene_ for this location. The hygiene is relevant "
"mainly for identifiers, as it allows or forbids the identifier from "
"referencing things or being referenced by things defined outside of the "
"invocation."
msgstr ""
"TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html)内"
"のすべてのトークンは、いくつかの追加情報を保持する `Span` に関連付けられてい"
"ます。スパンとは、そのドキュメントにあるように、「マクロ展開情報とともに、"
"ソースコードの一領域」です。これは、元のソースコードの領域を指し示すだけでな"
"く(正しい場所に診断を表示するために重要です)、この場所の_hygiene_の種類を保持"
"します。hygieneは主に識別子に関係し、識別子がものを参照したり、呼び出しの外で"
"定義されたものから参照されることを許可または禁止します。"

#: src/proc-macros/hygiene.md:10
#, fuzzy
msgid ""
"There are 3 kinds of hygiene(which can be seen by the constructors of the "
"`Span` type):"
msgstr "Span`型のコンストラクタで見ることができます）："

#: src/proc-macros/hygiene.md:11
#, fuzzy
msgid ""
"[`definition site`](https://doc.rust-lang.org/proc_macro/struct.Span."
"html#method.def_site)(_**unstable**_): A span that resolves at the macro "
"definition site. Identifiers with this span will not be able to reference "
"things defined outside or be referenced by things outside of the invocation. "
"This is what one would call \"hygienic\"."
msgstr ""
"[定義サイト`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"def_site)(_**unstable***_)：マクロ定義サイトで解決するスパンです。このスパン"
"を持つ識別子は、外部で定義されたものを参照したり、呼び出しの外部で定義された"
"ものから参照されたりすることはできません。これは「衛生的」と呼ばれるもので"
"す。"

#: src/proc-macros/hygiene.md:12
#, fuzzy
msgid ""
"[`mixed site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"mixed_site): A span that has the same hygiene as `macro_rules` declarative "
"macros, that is it may resolve to definition site or call site depending on "
"the type of identifier. See [here](../decl-macros/minutiae/hygiene.md) for "
"more information."
msgstr ""
"[`mixed site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"mixed_site)：宣言型マクロ `macro_rules` と同じhygieneを持つスパンです。詳細は"
"[ここ](../decl-macros/minutiae/hygiene.md)を参照してください。"

#: src/proc-macros/hygiene.md:13
#, fuzzy
msgid ""
"[`call site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"call_site): A span that resolves to the invocation site. Identifiers in this "
"case will behave as if written directly at the call site, that is they "
"freely resolve to things defined outside of the invocation and can be "
"referenced from the outside as well. This is what one would call "
"\"unhygienic\"."
msgstr ""
"[呼び出しサイト`](https://doc.rust-lang.org/proc_macro/struct.Span."
"html#method.call_site)：呼び出しサイトを解決するスパンです。つまり、呼び出し"
"の外部で定義されたものを自由に解決し、外部からも参照することができます。これ"
"は \"非衛生的 \"と呼ばれるものです。"

#: src/glossary.md:3
#, fuzzy
msgid ""
"A place for obscure words and their descriptions. If you feel like there is "
"an important word missing here, please open an [issue](https://github.com/"
"Veykril/tlborm/issues/new) or a pull request."
msgstr ""
"曖昧な単語とその説明のための場所です。重要な単語がここにないと感じたら、"
"[issue](https://github.com/Veykril/tlborm/issues/new) または pull request を"
"開いてください。"

#: src/glossary.md:6
#, fuzzy
msgid "Function-like macro"
msgstr "関数型マクロ"

#: src/glossary.md:7
#, fuzzy
msgid ""
"A function like macro describes a syntax extension that can be invoked via "
"the form `identifier!(...)`. It is called this way due to its resemblance of "
"a function call."
msgstr ""
"マクロのような関数は、`identifier!(...)`という形式で呼び出すことができる構文"
"の拡張を記述します。関数の呼び出しに似ていることから、このように呼ばれていま"
"す。"

#: src/glossary.md:10
#, fuzzy
msgid "Syntax Extension"
msgstr "構文拡張"

#: src/glossary.md:11
#, fuzzy
msgid "The mechanism Rust's `macro_rules!` and procedural macros are built on."
msgstr ""
"Rustの `macro_rules!` と手続き型マクロは、このメカニズムに基づいています。"
