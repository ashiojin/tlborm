msgid ""
msgstr ""
"Project-Id-Version: The Little Book of Rust Macros\n"
"POT-Creation-Date: 2023-10-29T12:05:28+09:00\n"
"PO-Revision-Date: 2023-11-10 16:42+0900\n"
"Last-Translator: MORI, Yuji <ashiojin@gmail.com>\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "はじめに"

#: src/SUMMARY.md:5 src/syntax-extensions.md:1
msgid "Syntax Extensions"
msgstr "構文拡張"

#: src/SUMMARY.md:6 src/syntax-extensions/source-analysis.md:1
msgid "Source Analysis"
msgstr "ソース分析"

#: src/SUMMARY.md:7
msgid "Macros in the Ast"
msgstr "AST内のマクロ"

#: src/SUMMARY.md:8 src/syntax-extensions/expansion.md:1
msgid "Expansion"
msgstr "展開"

#: src/SUMMARY.md:9 src/SUMMARY.md:18 src/syntax-extensions/hygiene.md:1
#: src/decl-macros/minutiae/hygiene.md:1 src/decl-macros/macros2.md:56
msgid "Hygiene"
msgstr "ハイジーン"

#: src/SUMMARY.md:10 src/SUMMARY.md:20 src/syntax-extensions/debugging.md:1
#: src/decl-macros/minutiae/debugging.md:1
msgid "Debugging"
msgstr "デバッキング"

#: src/SUMMARY.md:11 src/decl-macros.md:1
msgid "Declarative Macros"
msgstr "宣言的マクロ"

#: src/SUMMARY.md:12 src/SUMMARY.md:37 src/proc-macros/methodical.md:1
msgid "A Methodical Introduction"
msgstr "方法論的イントロダクション"

#: src/SUMMARY.md:13 src/SUMMARY.md:41
msgid "A Practical Introduction"
msgstr "実践的イントロダクション"

#: src/SUMMARY.md:14 src/decl-macros/minutiae.md:1
msgid "Minutiae"
msgstr "詳細"

#: src/SUMMARY.md:15 src/decl-macros/minutiae/fragment-specifiers.md:1
msgid "Fragment Specifiers"
msgstr "フラグメント指定子"

#: src/SUMMARY.md:16 src/decl-macros/minutiae/metavar-and-expansion.md:1
msgid "Metavariables and Expansion Redux"
msgstr "メタ変数と再展開"

#: src/SUMMARY.md:17 src/decl-macros/macros-methodical.md:243
#: src/decl-macros/minutiae/metavar-expr.md:1
msgid "Metavariable Expressions"
msgstr "メタ変数式"

#: src/SUMMARY.md:19 src/decl-macros/minutiae/identifiers.md:1
msgid "Non-Identifier Identifiers"
msgstr "識別子でない識別子"

#: src/SUMMARY.md:21 src/decl-macros/minutiae/scoping.md:1
msgid "Scoping"
msgstr "スコープ"

#: src/SUMMARY.md:22 src/decl-macros/minutiae/import-export.md:1
msgid "Import and Export"
msgstr "インポートとエクスポート"

#: src/SUMMARY.md:23 src/syntax-extensions/ast.md:103
#: src/decl-macros/patterns.md:1
msgid "Patterns"
msgstr "パターン"

#: src/SUMMARY.md:24 src/decl-macros/patterns/callbacks.md:1
msgid "Callbacks"
msgstr "コールバック"

#: src/SUMMARY.md:25 src/decl-macros/patterns/tt-muncher.md:1
msgid "Incremental TT Munchers"
msgstr "漸進的TT消化器"

#: src/SUMMARY.md:26 src/decl-macros/patterns/internal-rules.md:1
msgid "Internal Rules"
msgstr "内部ルール"

#: src/SUMMARY.md:27 src/decl-macros/patterns/push-down-acc.md:1
#, fuzzy
msgid "Push-down Accumulation"
msgstr "プッシュダウン・アキュムレーション"

#: src/SUMMARY.md:28 src/decl-macros/patterns/repetition-replacement.md:1
#, fuzzy
msgid "Repetition Replacement"
msgstr "リピート交換"

#: src/SUMMARY.md:29 src/decl-macros/patterns/tt-bundling.md:1
#, fuzzy
msgid "TT Bundling"
msgstr "TTバンドル"

#: src/SUMMARY.md:30 src/decl-macros/building-blocks.md:1
#, fuzzy
msgid "Building Blocks"
msgstr "ビルディングブロック"

#: src/SUMMARY.md:31 src/decl-macros/building-blocks/ast-coercion.md:1
#, fuzzy
msgid "AST Coercion"
msgstr "ASTの強制"

#: src/SUMMARY.md:32 src/decl-macros/building-blocks/counting.md:1
#, fuzzy
msgid "Counting"
msgstr "カウント"

#: src/SUMMARY.md:33
#, fuzzy
msgid "Abacus Counting"
msgstr "そろばん数え"

#: src/SUMMARY.md:34 src/decl-macros/building-blocks/parsing.md:1
#, fuzzy
msgid "Parsing Rust"
msgstr "ラストの解析"

#: src/SUMMARY.md:35 src/decl-macros/macros2.md:1
#, fuzzy
msgid "Macros 2.0"
msgstr "マクロ2.0"

#: src/SUMMARY.md:36 src/proc-macros.md:1
#, fuzzy
msgid "Procedural Macros"
msgstr "手続き型マクロ"

#: src/SUMMARY.md:38 src/SUMMARY.md:42
#: src/proc-macros/methodical/function-like.md:1
msgid "Function-like"
msgstr "関数型"

#: src/SUMMARY.md:39 src/SUMMARY.md:43 src/proc-macros/methodical/attr.md:1
msgid "Attribute"
msgstr "アトリビュート"

#: src/SUMMARY.md:40 src/SUMMARY.md:44 src/proc-macros/methodical/derive.md:1
#, fuzzy
msgid "Derive"
msgstr "導出"

#: src/SUMMARY.md:45 src/proc-macros/third-party-crates.md:1
#, fuzzy
msgid "Third-Party Crates"
msgstr "サードパーティのクレート"

#: src/SUMMARY.md:46 src/proc-macros/hygiene.md:1
#, fuzzy
msgid "Hygiene and Spans"
msgstr "衛生とスパン"

#: src/SUMMARY.md:47
#, fuzzy
msgid "Techniques"
msgstr "テクニック"

#: src/SUMMARY.md:48
msgid "Testing"
msgstr "テスト"

#: src/SUMMARY.md:50 src/glossary.md:1
msgid "Glossary"
msgstr "用語集"

#: src/introduction.md:2
msgid "The Little Book of Rust Macros"
msgstr "The Little Book of Rust Macros"

#: src/introduction.md:4
msgid ""
"**Note**: This is a continuation of [Daniel Keep's Book](https://github.com/"
"DanielKeep/tlborm) which has not been updated since the early summer of 2016, "
"adapted to make use of [mdBook](https://github.com/rust-lang/mdBook)."
msgstr ""
"**注**: これは、2016年初夏以降更新されていない[Daniel Keep's Book](https://"
"github.com/DanielKeep/tlborm)の続編で、[mdBook](https://github.com/rust-lang/"
"mdBook)を利用するようにアレンジしたものです。"

#: src/introduction.md:6
msgid ""
"View the [rendered version here](https://veykril.github.io/tlborm/) and the "
"[repository here](https://github.com/veykril/tlborm)."
msgstr ""
"[レンダリング版はこちら](https://veykril.github.io/tlborm/)、[リポジトリはこち"
"ら](https://github.com/veykril/tlborm)です。"

#: src/introduction.md:8
msgid ""
"A chinese version of this book can be found [here](https://zjp-cn.github.io/"
"tlborm/)."
msgstr "本書の中国語版は[こちら](https://zjp-cn.github.io/tlborm/)。"

#: src/introduction.md:10
msgid ""
"This book is an attempt to distill the Rust community's collective knowledge "
"of Rust macros, the `Macros by Example` ones as well as procedural "
"macros(WIP). As such, both additions (in the form of pull requests) and "
"requests (in the form of issues) are very much welcome. If something's "
"unclear, opens up questions or is not understandable as written down, fear not "
"to make an issue asking for clarification. The goal is for this book to become "
"the best learning resource possible."
msgstr ""
"この本は、RustコミュニティのRustマクロ、すなわち「Macros by Example」と手続き型"
"マクロ(WIP)、に関する集合的な知識を抽出する試みです。そのため、（プルリクエスト"
"という形での）追加や（issueという形での）要望は大歓迎です。不明な点、疑問点、書"
"かれていることが理解できない点などがあれば、issueを作成し、説明を求めてくださ"
"い。この本が可能な限り最高の学習リソースになることが目標です。"

#: src/introduction.md:15
msgid ""
"The [original Little Book of Rust Macros](https://github.com/DanielKeep/"
"tlborm) has helped me immensely with understanding _**Macros by Example**_ "
"style macros while I was still learning the language. Unfortunately, the "
"original book hasn't been updated since April of 2016, while the Rust language "
"as well as its macro-system keeps evolving. Which is why I took up the task to "
"update the book and keep it updated as well as I can while also adding "
"newfound things to it. In hopes that it will help out all the fresh faces "
"coming to Rust understanding its macro systems, a part of the language a "
"people tend to have trouble with."
msgstr ""
"[オリジナルのLittle Book of Rust Macros](https://github.com/DanielKeep/tlborm)"
"は、私がまだ言語を学んでいる間、　_**Macros by Example**_ スタイルのマクロを理"
"解するのに非常に役立ちました。しかし残念ながら、Rust言語とマクロシステムが進化"
"し続ける中、この本は2016年4月から更新されていません。そのため、私はこの本を更新"
"し、新しい発見を加えながら、できる限り最新の状態に保つ仕事を引き受けました。こ"
"の本が、これからRustを学ぼうとする人たちが、苦戦しがちなRustのマクロシステムを"
"理解する助けになることを願っています。"

#: src/introduction.md:20
msgid ""
"This book expects you to have basic knowledge of Rust, it will not explain "
"language features or constructs that are irrelevant to macros. No prior "
"knowledge of macros is assumed. Having read and understood the first seven "
"chapters of the [Rust Book](https://doc.rust-lang.org/stable/book/) is a must, "
"though having read the majority of the book is recommended."
msgstr ""
"本書では、Rustの基本的な知識があることを前提としており、マクロに関係のない言語"
"機能や構成要素については説明しません。マクロに関する予備知識は想定していませ"
"ん。[Rust Book](https://doc.rust-lang.org/stable/book/)の最初の7章を読んで理解"
"していることは必須ですが、この本の大部分を読んでいることを推奨します。"

#: src/introduction.md:24
msgid "Thanks"
msgstr "謝辞"

#: src/introduction.md:26
msgid ""
"A big thank you to Daniel Keep for the original work as well as all the "
"contributors that added to the original which can be found [here](https://"
"github.com/DanielKeep/tlborm)."
msgstr ""
"ダニエル・キープ氏の原作([こちら](https://github.com/DanielKeep/tlborm))と、原"
"作に加筆してくれたすべての貢献者に感謝します。"

#: src/introduction.md:28
msgid "License"
msgstr "ライセンス"

#: src/introduction.md:30
msgid ""
"This work inherits the licenses of the original, hence it is licensed under "
"both the [Creative Commons Attribution-ShareAlike 4.0 International License]"
"(http://creativecommons.org/licenses/by-sa/4.0/) and the [MIT license](http://"
"opensource.org/licenses/MIT)."
msgstr ""
"この作品はオリジナルのライセンスを継承しているため、[Creative Commons "
"Attribution-ShareAlike 4.0 International License](http://creativecommons.org/"
"licenses/by-sa/4.0/)と[MIT license](http://opensource.org/licenses/MIT)の両方で"
"ライセンスされています。"

#: src/syntax-extensions.md:3
msgid ""
"Before talking about Rust's different macro systems it is worthwhile to "
"discuss the general mechanism they are built on: _syntax extensions_."
msgstr ""
"Rustのさまざまなマクロシステムについて説明する前に、それらがどのような一般的な"
"メカニズムに基づいて構築されているかについて説明する価値があります: _構文拡張_ "
"です。"

#: src/syntax-extensions.md:5
msgid ""
"To do that, we must first discuss how Rust source is processed by the "
"compiler, and the general mechanisms on which user-defined macros and proc-"
"macros are built upon."
msgstr ""
"そのためにはまず、Rustのソースコードがコンパイラによってどのように処理されるの"
"か、そしてユーザ定義マクロやprocマクロが構築される一般的なメカニズムについて説"
"明する必要があります。"

#: src/syntax-extensions.md:7
msgid ""
"**Note**: This book will use the term _syntax extension_ from now on when "
"talking about all of rust's different macro kinds in general to reduce "
"potential confusion with the upcoming [declarative macro 2.0](https://github."
"com/rust-lang/rust/issues/39412) proposal which uses the `macro` keyword."
msgstr ""
"**注**: 本書では今後、Rustのさまざまな種類のマクロ全般について話すときには、"
"`macro` キーワードを使用する、来る[declarative macro 2.0](https://github.com/"
"rust-lang/rust/issues/39412) 提案との潜在的な混同を避けるために、_構文拡張_ と"
"いう用語を使用します。"

#: src/syntax-extensions/source-analysis.md:3
msgid "Tokenization"
msgstr "トークン化"

#: src/syntax-extensions/source-analysis.md:5
msgid ""
"The first stage of compilation for a Rust program is [tokenization](https://en."
"wikipedia.org/wiki/Lexical_analysis#Tokenization). This is where the source "
"text is transformed into a sequence of tokens (_i.e._ indivisible lexical "
"units; the programming language equivalent of \"words\"). Rust has various "
"kinds of tokens, such as:"
msgstr ""
"Rustプログラムのコンパイルの最初の段階は[トークン化](https://en.wikipedia.org/"
"wiki/Lexical_analysis#Tokenization)です。これは、ソーステキストを一連のトークン"
"( _i.e._ 不可分な語彙単位。プログラミング言語の「単語」に相当)に変換する作業で"
"す。Rustには、以下のようなさまざまな種類のトークンがあります:"

#: src/syntax-extensions/source-analysis.md:9
msgid "Identifiers: `foo`, `Bambous`, `self`, `we_can_dance`, `LaCaravane`, …"
msgstr "識別子: `foo`、`Bambous`、`self`、`we_can_dance`、`LaCaravane`、..."

#: src/syntax-extensions/source-analysis.md:10
msgid "Literals: `42`, `72u32`, `0_______0`, `1.0e-40`, `\"ferris was here\"`, …"
msgstr ""
"リテラル: `42`, `72u32`, `0_______0`, `1.0e-40`, `\"ferris was here\"`, ..."

#: src/syntax-extensions/source-analysis.md:11
msgid "Keywords: `_`, `fn`, `self`, `match`, `yield`, `macro`, …"
msgstr "キーワード: `_`、`fn`、`self`、`match`、`yield`、`macro`、..."

#: src/syntax-extensions/source-analysis.md:12
msgid "Symbols: `[`, `:`, `::`, `?`, `~`, `@`[^wither-at], …"
msgstr "シンボル: `[`, `:`, `::`, `?`, `~`, `@`[^wither-at], ..."

#: src/syntax-extensions/source-analysis.md:14
msgid ""
"…among others. There are some things to note about the above: first, `self` is "
"both an identifier _and_ a keyword. In almost all cases, `self` is a keyword, "
"but it _is_ possible for it to be _treated_ as an identifier, which will come "
"up later (along with much cursing). Secondly, the list of keywords includes "
"some suspicious entries such as `yield` and `macro` that aren't _actually_ in "
"the language, but _are_ parsed by the compiler—these are [reserved](https://"
"doc.rust-lang.org/reference/keywords.html#reserved-keywords) for future use. "
"Third, the list of symbols _also_ includes entries that aren't used by the "
"language. In the case of `<-`, it is vestigial: it was removed from the "
"grammar, but not from the lexer. As a final point, note that `::` is a "
"distinct token; it is not simply two adjacent `:` tokens. The same is true of "
"all multi-character symbol tokens in Rust, as of Rust 1.2.[^two-lexers]"
msgstr ""
"... などがあります。ここにいくつか注記することがあります: 第一に、`self` は識別"
"子である _と同時に_ キーワードでもあります。ほとんどの場合、`self`はキーワード"
"ですが、識別子として _扱われる_ こともあります。これは後に（たくさんの悪口付き"
"で）お話しします。第二に、キーワードのリストには、 `yield` や `macro` のよう"
"な、言語に _実際には存在しない_ にも関わらず、コンパイラによって解析 _される_ "
"怪しい項目があります。第三に、記号のリストには、その言語で使われていない項目 _"
"も_ 含まれています。 `<-`の場合は、これは名残のようなものです: 文法からは削除さ"
"れていますが、辞書からは削除されていません。最後のポイントとして、`::` は１個の"
"トークンです。これは隣り合う２個の `: ` トークンではありません。Rust 1.2の時点"
"では、Rustのすべての複数文字シンボルトークンについて同じことが言えます[^two-"
"lexers]。"

#: src/syntax-extensions/source-analysis.md:24
msgid ""
"`@` has a purpose, though most people seem to forget about it completely: it "
"is used in patterns to bind a non-terminal part of the pattern to a name."
msgstr ""
"ほとんどの人は完全に忘れているようですが、`@` には目的があります。パターンの非"
"終端部分を名前に束縛するために、パターン内で使われます。"

#: src/syntax-extensions/source-analysis.md:27
msgid ""
"Technically rust currently(1.46) has two lexers, [`rustc_lexer`](https://"
"github.com/rust-lang/rust/tree/master/compiler/rustc_lexer) which only emits "
"single character symbols as tokens and the [lexer](https://github.com/rust-"
"lang/rust/tree/master/compiler/rustc_parse/src/lexer) in [`rustc_parse`]"
"(https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse) which "
"sees multi-character symbols as distinct tokens."
msgstr ""
"技術的には、現在(1.46)のrustには2つのレキサがあります。[`rustc_lexer`](https://"
"github.com/rust-lang/rust/tree/master/compiler/rustc_lexer)は1文字のシンボルだ"
"けをトークンとして出力し、[`rustc_parse`](https://github.com/rust-lang/rust/"
"tree/master/compiler/rustc_parse)の[lexer](https://github.com/rust-lang/rust/"
"tree/master/compiler/rustc_parse/src/lexer)は複数文字のシンボルを別個のトークン"
"として認識します。"

#: src/syntax-extensions/source-analysis.md:31
msgid ""
"As a point of comparison, it is at _this_ stage that some languages have their "
"macro layer, though Rust does _not_. For example, C/C++ macros are "
"_effectively_ processed at this point. [^lies-damn-lies-cpp] This is why the "
"following code works: [^cpp-it-seemed-like-a-good-idea-at-the-time]"
msgstr ""
"比較のポイントとして、いくつかの言語がマクロのレイヤーを持つのは _この_ 段階で"
"あるのに対し、Rustは _そうではありません_ 。例えば、C/C++のマクロはこの段階で _"
"事実上_ 処理されます。[^lies-damn-lies-cpp] これが以下のコードが動作する理由で"
"す: [^cpp-it-seemed-like-a-good-idea-the-the-time]。"

#: src/syntax-extensions/source-analysis.md:36
msgid ""
"```c\n"
"#define SUB int\n"
"#define BEGIN {\n"
"#define END }\n"
"\n"
"SUB main() BEGIN\n"
"    printf(\"Oh, the horror!\\n\");\n"
"END\n"
"```"
msgstr ""
"```c\n"
"#define SUB int\n"
"#define BEGIN {\n"
"#define END }\n"
"\n"
"SUB main() BEGIN\n"
"    printf(\"Oh, the horror!\\n\");\n"
"END\n"
"```"

#: src/syntax-extensions/source-analysis.md:46
msgid ""
"In fact, the C preprocessor uses a different lexical structure to C itself, "
"but the distinction is _broadly_ irrelevant."
msgstr ""
"実際、CプリプロセッサはCそのものとは異なる字句構造を使っていますが、この区別は "
"_大まかには_ 重要ではありません。"

#: src/syntax-extensions/source-analysis.md:49
msgid "_Whether_ it should work is an entirely _different_ question."
msgstr "それがうまくいくかどうかは、まったく _別の_ 問題です。"

#: src/syntax-extensions/source-analysis.md:52
msgid "Parsing"
msgstr "構文解析"

#: src/syntax-extensions/source-analysis.md:54
msgid ""
"The next stage is parsing, where the stream of tokens is turned into an "
"[Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) "
"(AST). This involves building up the syntactic structure of the program in "
"memory. For example, the token sequence `1 + 2` is transformed into the "
"equivalent of:"
msgstr ""
"次の段階は構文解析で、トークンのストリームを[抽象構文木](https://en.wikipedia."
"org/wiki/Abstract_syntax_tree) (Abstract Syntax Tree: AST)に変換します。これ"
"は、メモリ上にプログラムの構文構造を構築することを含みます。例えば、トークン列 "
"`1 + 2` は次のように変換されます:"

#: src/syntax-extensions/source-analysis.md:69
msgid ""
"The AST contains the structure of the _entire_ program, though it is based on "
"purely _lexical_ information. For example, although the compiler may know that "
"a particular expression is referring to a variable called `a`, at this stage, "
"it has _no way_ of knowing what `a` is, or even _where_ it comes from."
msgstr ""
"ASTはプログラム _全体の_ 構造を含んでいますが、これは純粋に _字句_ の情報に基づ"
"いたものです。例えば、コンパイラは特定の式が `a` という変数を参照していることは"
"知っていても、この段階では `a` が何なのか、あるいはそれがどこから来たものなのか"
"を知る方法は _ありません_ 。"

#: src/syntax-extensions/source-analysis.md:74
msgid ""
"It is _after_ the AST has been constructed that macros are processed. However, "
"before we can discuss that, we have to talk about token trees."
msgstr ""
"マクロが処理されるのは、ASTが構築された _後_ です。しかしながら、その話をする前"
"に、トークンツリーの話をしなければなりません。"

#: src/syntax-extensions/source-analysis.md:77
msgid "Token trees"
msgstr "トークンツリー"

#: src/syntax-extensions/source-analysis.md:79
msgid ""
"Token trees are somewhere between tokens and the AST. Firstly, _almost_ all "
"tokens are also token trees; more specifically, they are _leaves_. There is "
"one other kind of thing that can be a token tree leaf, but we will come back "
"to that later."
msgstr ""
"トークンツリーはトークンとASTの中間に位置します。まず、 _ほとんど_ すべてのトー"
"クンはトークンツリーでもあり、より具体的にはそれらは _葉_ です。トークンツリー"
"の葉になりうるものがもう1つありますが、これについては後で説明します。"

#: src/syntax-extensions/source-analysis.md:83
msgid ""
"The only basic tokens that are _not_ leaves are the \"grouping\" tokens: "
"`(...)`, `[...]`, and `{...}`. These three are the _interior nodes_ of token "
"trees, and what give them their structure. To give a concrete example, this "
"sequence of tokens:"
msgstr ""
"葉でない唯一の基本トークンは「グループ化」トークンです: `(...)`, `[...]`, "
"`{...}` 。この3つはトークンツリーの _内部ノード_ で、トークンツリーに構造を与え"
"ます。具体的な例を挙げます。次のようなトークンのシーケンス："

#: src/syntax-extensions/source-analysis.md:91
msgid "would be parsed into the following token trees:"
msgstr "は以下のトークンツリーにパースされます:"

#: src/syntax-extensions/source-analysis.md:101
msgid ""
"Note that this has _no relationship_ to the AST the expression would produce; "
"instead of a single root node, there are _seven_ token trees at the root "
"level. For reference, the AST would be:"
msgstr ""
"この式が生成するASTとは _何の関係もない_ ことに注意してください: ルートノードが"
"1つではなく、ルートレベルにトークンツリーが _7つ_ あるのです。参考までに、ASTは"
"次のようになります:"

#: src/syntax-extensions/source-analysis.md:128
msgid ""
"It is important to understand the distinction between the AST and token trees. "
"When writing macros, you have to deal with _both_ as distinct things."
msgstr ""
"ASTとトークンツリーの差異を理解することは重要です。マクロを書くときには、その _"
"両方を_ 別個のものとして扱わなければなりません。"

#: src/syntax-extensions/source-analysis.md:131
msgid ""
"One other aspect of this to note: it is _impossible_ to have an unpaired "
"parenthesis, bracket or brace; nor is it possible to have incorrectly nested "
"groups in a token tree."
msgstr ""
"もう一つ注意すべき側面があります: 対になっていない括弧や波括弧、鍵括弧を持つこ"
"とは _不可能_ です。またトークンツリーに正しく入れ子になっていないグループを持"
"つことも不可能です。"

#: src/syntax-extensions/ast.md:1
#, fuzzy
msgid "Macros in the AST"
msgstr "AST内のマクロ"

#: src/syntax-extensions/ast.md:3
msgid ""
"As previously mentioned, macro processing in Rust happens _after_ the "
"construction of the AST. As such, the syntax used to invoke a macro _must_ be "
"a proper part of the language's syntax. In fact, there are several \"syntax "
"extension\" forms which are part of Rust's syntax. Specifically, the following "
"4 forms (by way of examples):"
msgstr ""
"前述のとおり、Rust でのマクロ処理は AST の構築の後に行われます。そのため、マク"
"ロを呼び出す構文は、言語の構文の適切な一部で _なければなりません_ 。実際、Rust "
"の構文にはいくつかの「構文拡張」形式があります。具体的には、次の 4 つの形式があ"
"ります（例として）:"

#: src/syntax-extensions/ast.md:8
msgid "`# [ $arg ]`; _e.g._ `#[derive(Clone)]`, `#[no_mangle]`, …"
msgstr "`# [ $arg ]`; _e.g._ `#[derive(Clone)]`, `#[no_mangle]`, …"

#: src/syntax-extensions/ast.md:9
msgid ""
"`# ! [ $arg ]`; _e.g._ `#![allow(dead_code)]`, `#![crate_name=\"blang\"]`, …"
msgstr ""
"`# ! [ $arg ]`; _e.g._ `#![allow(dead_code)]`, `#![crate_name=\"blang\"]`, …"

#: src/syntax-extensions/ast.md:10
msgid "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"
msgstr "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"

#: src/syntax-extensions/ast.md:11
msgid "`$name ! $arg0 $arg1`; _e.g._ `macro_rules! dummy { () => {}; }`."
msgstr "`$name ! $arg0 $arg1`; _e.g._ `macro_rules! dummy { () => {}; }`."

#: src/syntax-extensions/ast.md:13
msgid ""
"The first two are [attributes](https://doc.rust-lang.org/reference/attributes."
"html) which annotate items, expressions and statements. They can be classified "
"into different kinds, [built-in attributes](https://doc.rust-lang.org/"
"reference/attributes.html#built-in-attributes-index), [proc-macro attributes]"
"(https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros) "
"and [derive attributes](https://doc.rust-lang.org/reference/procedural-macros."
"html#derive-macro-helper-attributes). [proc-macro attributes](https://doc.rust-"
"lang.org/reference/procedural-macros.html#attribute-macros) and [derive "
"attributes](https://doc.rust-lang.org/reference/procedural-macros.html#derive-"
"macro-helper-attributes) can be implemented with the second macro system that "
"Rust offers, [procedural macros](https://doc.rust-lang.org/reference/"
"procedural-macros.html). [built-in attributes](https://doc.rust-lang.org/"
"reference/attributes.html#built-in-attributes-index) on the other hand are "
"attributes implemented by the compiler."
msgstr ""
"最初の2つは[アトリビュート](https://doc.rust-lang.org/reference/attributes."
"html)で、アイテム、式、文にアノテーションを付けます。これらの属性は、[ビルトイ"
"ン属性](https://doc.rust-lang.org/reference/attributes.html#built-in-"
"attributes-index)、[procマクロ属性](https://doc.rust-lang.org/reference/"
"procedural-macros.html#attribute-macros)、[derive属性](https://doc.rust-lang."
"org/reference/procedural-macros.html#derive-macro-helper-attributes)に分類され"
"ます。[procマクロ属性](https://doc.rust-lang.org/reference/procedural-macros."
"html#attribute-macros)と[derive属性](https://doc.rust-lang.org/reference/"
"procedural-macros.html#derive-macro-helper-attributes)は、Rustが提供する2番目の"
"マクロシステムである[手続き的マクロ](https://doc.rust-lang.org/reference/"
"procedural-macros.html)で実装できます。一方、[ビルトイン属性](https://doc.rust-"
"lang.org/reference/attributes.html#built-in-attributes-index) はコンパイラに"
"よって実装される属性です。"

#: src/syntax-extensions/ast.md:19
msgid ""
"The third form `$name ! $arg` are function-like macros. It is the form "
"available for use with `macro_rules!`, `macro` and also procedural macros. "
"Note that this form is not _limited_ to `macro_rules!` macros: it is a generic "
"syntax extension form. For example, whilst [`format!`](https://doc.rust-lang."
"org/std/macro.format.html) is a `macro_rules!` macro, [`format_args!`](https://"
"doc.rust-lang.org/std/macro.format_args.html) (which is used to _implement_ "
"[`format!`](https://doc.rust-lang.org/std/macro.format.html)) is _not_ as it "
"is a compiler builtin."
msgstr ""
"第3の形式 `$name ! arg` は関数型マクロです。これは `macro_rules!`, `macro` や手"
"続き的マクロで使用できる形式です。この形式は `macro_rules!` マクロに限定された"
"ものではないことに注意してください: これは一般的な構文拡張形式です。例えば、"
"[`format!`](https://doc.rust-lang.org/std/macro.format.html) は `macro_rules!` "
"マクロですが、[`format_args!`](https://doc.rust-lang.org/std/macro.format_args."
"html) ([`format!`](https://doc.rust-lang.org/std/macro.format.html)の実装に使用"
"されます) はそうでは _なく_ 、コンパイラのビルトインです。"

#: src/syntax-extensions/ast.md:24
msgid ""
"The fourth form is essentially a variation which is _not_ available to macros. "
"In fact, the only case where this form is used _at all_ is with the "
"`macro_rules!` construct itself."
msgstr ""
"第4の形式は、基本的にマクロでは使用 _できない_ バリエーションです。実際、この形"
"式が _唯一_ 使われるのは `macro_rules!` 構文そのものだけです。"

#: src/syntax-extensions/ast.md:27
msgid ""
"So, starting with the third form, how does the Rust parser know what the "
"`$arg` in (`$name ! $arg`) looks like for every possible syntax extension? The "
"answer is that it doesn't _have to_. Instead, the argument of a syntax "
"extension invocation is a _single_ token tree. More specifically, it is a "
"single, _non-leaf_ token tree; `(...)`, `[...]`, or `{...}`. With that "
"knowledge, it should become apparent how the parser can understand all of the "
"following invocation forms:"
msgstr ""
"では、3番目の形式から始めるとして、Rustパーサは (`$name ! $arg`) の `$arg` がど"
"のような構文拡張なのかをどうやって知るのでしょうか？答えは、その _必要がない_ "
"です。代わりに、構文拡張の呼び出しの引数は _単一の_ トークンツリーです。より具"
"体的には、 `(...)` 、 `[...]` 、`{...}` のような、単一の _葉でない_ トークンツ"
"リーです。この知識があれば、以下のすべての呼び出し形式をどのようにパーサが理解"
"することが可能か、はっきりするはずです:"

#: src/syntax-extensions/ast.md:34
msgid ""
"```rust,ignore\n"
"bitflags! {\n"
"    struct Color: u8 {\n"
"        const RED    = 0b0001,\n"
"        const GREEN  = 0b0010,\n"
"        const BLUE   = 0b0100,\n"
"        const BRIGHT = 0b1000,\n"
"    }\n"
"}\n"
"\n"
"lazy_static! {\n"
"    static ref FIB_100: u32 = {\n"
"        fn fib(a: u32) -> u32 {\n"
"            match a {\n"
"                0 => 0,\n"
"                1 => 1,\n"
"                a => fib(a-1) + fib(a-2)\n"
"            }\n"
"        }\n"
"\n"
"        fib(100)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    use Color::*;\n"
"    let colors = vec![RED, GREEN, BLUE];\n"
"    println!(\"Hello, World!\");\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"bitflags! {\n"
"    struct Color: u8 {\n"
"        const RED    = 0b0001,\n"
"        const GREEN  = 0b0010,\n"
"        const BLUE   = 0b0100,\n"
"        const BRIGHT = 0b1000,\n"
"    }\n"
"}\n"
"\n"
"lazy_static! {\n"
"    static ref FIB_100: u32 = {\n"
"        fn fib(a: u32) -> u32 {\n"
"            match a {\n"
"                0 => 0,\n"
"                1 => 1,\n"
"                a => fib(a-1) + fib(a-2)\n"
"            }\n"
"        }\n"
"\n"
"        fib(100)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    use Color::*;\n"
"    let colors = vec![RED, GREEN, BLUE];\n"
"    println!(\"Hello, World!\");\n"
"}\n"
"```"

#: src/syntax-extensions/ast.md:65
msgid ""
"Although the above invocations may _look_ like they contain various kinds of "
"Rust code, the parser simply sees a collection of meaningless token trees. To "
"make this clearer, we can replace all these syntactic \"black boxes\" with ⬚, "
"leaving us with:"
msgstr ""
"上記の呼び出しは、様々な種類のRustコードを含んでいるように _見える_ かもしれま"
"せんが、パーサは単に無意味なトークンツリーの集まりと見ているにすぎません。これ"
"を明確にするために、これらの構文の「ブラックボックス」をすべて⬚に置き換えること"
"が可能です:"

#: src/syntax-extensions/ast.md:79
msgid ""
"Just to reiterate: the parser does not assume _anything_ about ⬚; it remembers "
"the tokens it contains, but doesn't try to _understand_ them. This means ⬚ can "
"be anything, even invalid Rust! As to why this is a good thing, we will come "
"back to that at a later point."
msgstr ""
"繰り返しますが、パーサは⬚について _何一つ_ 仮定していません。パーサは⬚に含まれ"
"るトークンを記憶しますが、それを _理解_ しようとはしません。つまり、⬚は無効な"
"Rustでも何でもあり得るということです！これがなぜ良いことなのかについては、また"
"後ほど説明します。"

#: src/syntax-extensions/ast.md:84
msgid ""
"So, does this also apply to `$arg` in form 1 and 2, and to the two args in "
"form 4? Kind of. The `$arg` for form 1 and 2 is a bit different in that it is "
"not directly a token tree, but a _simple path_ that is either followed by an "
"`=` token and a literal expression, or a token tree. We will explore this more "
"in-depth in the appropriate proc-macro chapter. The important part here is "
"that this form as well, makes use of token trees to describe the input. The "
"4th form in general is more special and accepts a very specific grammar that "
"also makes use of token trees though. The specifics of this form do not matter "
"at this point so we will skip them until they become relevant."
msgstr ""
"では、これは形式1と2の `$arg` と形式4の2つの引数にも適用されるのでしょうか？"
"まぁそんな感じです。形式1と2の `$arg` は少し違っていて、単なるトークンツリーで"
"はなく、 `=` トークンとリテラル式が続く _単純なパス_ か、トークンツリーです。こ"
"れについては、適切なprocマクロの章で詳しく説明します。ここで重要なのは、この形"
"式でもトークンツリーを使って入力を記述するということです。一般的な第4の形式は"
"もっと特殊で、トークンツリーの利用もする非常に特殊な文法を受け入れます。この形"
"式の詳細についてはこの時点では重要ではないので、関係するようになるまで省略しま"
"す。"

#: src/syntax-extensions/ast.md:91
msgid "The important takeaways from this are:"
msgstr "ここから得られる重要なことは:"

#: src/syntax-extensions/ast.md:93
msgid "There are multiple kinds of syntax extensions in Rust."
msgstr "Rustには複数の構文拡張があります。"

#: src/syntax-extensions/ast.md:94
msgid ""
"Just seeing something of the form `$name! $arg`, doesn't tell you what kind of "
"syntax extension it might be. It could be a `macro_rules!` macro, a `proc-"
"macro` or maybe even a builtin."
msgstr ""
"`$name! $arg` という形を見ただけでは、それがどのような構文拡張なのかはわかりま"
"せん。 `macro_rules!` マクロかもしれないし、 `proc-macro` かもしれないし、ビル"
"トインかもしれません。"

#: src/syntax-extensions/ast.md:96
msgid ""
"The input to every `!` macro invocation, that is form 3, is a single non-leaf "
"token tree."
msgstr ""
"すべての `!` マクロ呼び出しの入力、つまり形式3は、1つの、葉でないトークンツリー"
"です。"

#: src/syntax-extensions/ast.md:97
msgid "Syntax extensions are parsed as _part_ of the abstract syntax tree."
msgstr "構文拡張は抽象構文木の _一部_ として解析されます。"

#: src/syntax-extensions/ast.md:99
msgid ""
"The last point is the most important, as it has _significant_ implications. "
"Because syntax extensions are parsed into the AST, they can **only** appear in "
"positions where they are explicitly supported. Specifically syntax extensions "
"can appear in place of the following:"
msgstr ""
"_重要な_ 暗示を持つので、最後の点が最も重要です。構文拡張はASTにパースされるた"
"め、明示的にサポートされている位置に **のみ** 現れることできます。具体的には、"
"構文拡張は以下のような場所に現れます:"

#: src/syntax-extensions/ast.md:104
msgid "Statements"
msgstr "文"

#: src/syntax-extensions/ast.md:105
msgid "Expressions"
msgstr "式"

#: src/syntax-extensions/ast.md:106
msgid "Items(this includes `impl` items)"
msgstr "アイテム(これは `impl` アイテムを含みます)"

#: src/syntax-extensions/ast.md:107
msgid "Types"
msgstr "型"

#: src/syntax-extensions/ast.md:109
msgid "Some things _not_ on this list:"
msgstr "このリストに _ない_ ものもあります:"

#: src/syntax-extensions/ast.md:111
msgid "Identifiers"
msgstr "識別子"

#: src/syntax-extensions/ast.md:112
msgid "Match arms"
msgstr "マッチアーム"

#: src/syntax-extensions/ast.md:113
msgid "Struct fields"
msgstr "構造体のフィールド"

#: src/syntax-extensions/ast.md:115
msgid ""
"There is absolutely, definitely _no way_ to use syntax extensions in any "
"position _not_ on the first list."
msgstr ""
"構文拡張を最初のリスト以外の位置で使用する方法は、確実に、絶対にありません。"

#: src/syntax-extensions/expansion.md:3
msgid ""
"Expansion is a relatively simple affair. At some point _after_ the "
"construction of the AST, but before the compiler begins constructing its "
"semantic understanding of the program, it will expand all syntax extensions."
msgstr ""
"展開は比較的単純なものです。ASTの構築 _後_ 、かつコンパイラがプログラムの意味的"
"理解を構築し始める前のある時点で、すべての構文拡張を展開します。"

#: src/syntax-extensions/expansion.md:6
msgid ""
"This involves traversing the AST, locating syntax extension invocations and "
"replacing them with their expansion."
msgstr ""
"これが含むのは、ASTを横断し、構文拡張の呼び出しを見つけ、これをその展開に置き換"
"えることです。"

#: src/syntax-extensions/expansion.md:8
msgid ""
"Once the compiler has run a syntax extension, it expects the result to be "
"parsable as one of a limited set of syntax elements, based on context. For "
"example, if you invoke a syntax extension at module scope, the compiler will "
"parse the result into an AST node that represents an item. If you invoke a "
"syntax extension in expression position, the compiler will parse the result "
"into an expression AST node."
msgstr ""
"コンパイラが構文拡張を実行したならば、その結果が、コンテキストに基づいて、限ら"
"れた構文要素のセットの1つとしてパース可能になることを期待します。たとえば、モ"
"ジュールスコープで構文拡張を実行した場合、コンパイラは結果をアイテムを表すAST"
"ノードにパースします。式の位置で構文拡張を呼び出すと、コンパイラは結果を式のAST"
"ノードにパースします。"

#: src/syntax-extensions/expansion.md:12
msgid "In fact, it can turn a syntax extension result into any of the following:"
msgstr "実際、構文拡張の結果は以下のいずれかに変換されます:"

#: src/syntax-extensions/expansion.md:14
msgid "an expression,"
msgstr "1個の式、"

#: src/syntax-extensions/expansion.md:15
msgid "a pattern,"
msgstr "1個のパターン、"

#: src/syntax-extensions/expansion.md:16
msgid "a type,"
msgstr "1個の型、"

#: src/syntax-extensions/expansion.md:17
msgid "zero or more items, or"
msgstr "0個以上のアイテム、または"

#: src/syntax-extensions/expansion.md:18
msgid "zero or more statements."
msgstr "0個以上の文。"

#: src/syntax-extensions/expansion.md:20
msgid ""
"In other words, _where_ you can invoke a syntax extension determines what its "
"result will be interpreted as."
msgstr ""
"言い換えれば、構文拡張を呼び出せる _場所_ が、その結果が何に解釈されるかを決定"
"します。"

#: src/syntax-extensions/expansion.md:22
msgid ""
"The compiler will take this AST node and completely replace the syntax "
"extension's invocation node with the output node. _This is a structural "
"operation_, not a textual one!"
msgstr ""
"コンパイラはこのASTノードを受け取り、構文拡張の呼び出しノードをその出力ノードに"
"完全に置き換えます。 _これは構造上の操作であり_ 、テキスト上の操作ではありませ"
"ん！"

#: src/syntax-extensions/expansion.md:25
msgid "For example, consider the following:"
msgstr "例えば、以下を考えてみましょう:"

#: src/syntax-extensions/expansion.md:31
msgid "We can visualize this partial AST as follows:"
msgstr "この部分的なASTを視覚化すると、次のようになります:"

#: src/syntax-extensions/expansion.md:47
msgid ""
"From context, `four!()` _must_ expand to an expression (the initializer can "
"_only_ be an expression). Thus, whatever the actual expansion is, it will be "
"interpreted as a complete expression. In this case, we will assume `four!` is "
"defined such that it expands to the expression `1 + 3`. As a result, expanding "
"this invocation will result in the AST changing to:"
msgstr ""
"コンテキストから、`four!()` は式に展開されなければ _なりません_ （イニシャライ"
"ザは式でしかありえません）。したがって、実際の展開が何であれ、それは完全な式と"
"して解釈されます。ここでは `four!` を式 `1 + 3` に展開されるもように定義された"
"ものとして想定します。結果として、この呼び出しを展開するとASTは次のようになりま"
"す:"

#: src/syntax-extensions/expansion.md:69
msgid "This can be written out like so:"
msgstr "これは次のように記述できます:"

#: src/syntax-extensions/expansion.md:75
msgid ""
"Note that we added parentheses _despite_ them not being in the expansion. "
"Remember that the compiler always treats the expansion of a syntax extension "
"as a complete AST node, **not** as a mere sequence of tokens. To put it "
"another way, even if you don't explicitly wrap a complex expression in "
"parentheses, there is no way for the compiler to \"misinterpret\" the result, "
"or change the order of evaluation."
msgstr ""
"先の展開に含まれていなかった _にも関わらず_ 括弧が追加されていることに注意して"
"ください。コンパイラは常に構文拡張の展開を完全なASTノードとして扱うことを思い出"
"してください。ただのトークンの列としては扱うことは **ありません** 。別の言い方"
"をすれば、たとえ複雑な式を明示的に括弧でくくらなかったとしても、コンパイラが結"
"果を「誤解釈」したり、評価の順序を変更したりすることはありません。"

#: src/syntax-extensions/expansion.md:79
msgid ""
"It is important to understand that syntax extension expansions are treated as "
"AST nodes, as this design has two further implications:"
msgstr ""
"構文拡張の展開がASTノードとして扱われることを理解することは重要です。なぜなら、"
"この設計は２つのことを示唆します:"

#: src/syntax-extensions/expansion.md:81
msgid ""
"In addition to there being a limited number of invocation _positions_, syntax "
"extension can _only_ expand to the kind of AST node the parser _expects_ at "
"that position."
msgstr ""
"呼び出し _位置_ の数が限られていることに加えて、構文拡張は、パーサがその位置で "
"_期待_ する種類のASTノードに _しか_ 展開できません。"

#: src/syntax-extensions/expansion.md:82
msgid ""
"As a consequence of the above, syntax extension  _absolutely cannot_ expand to "
"incomplete or syntactically invalid constructs."
msgstr ""
"上記の結果、構文拡張を、不完全もしくは構文的に無効な結果に展開することは _絶対"
"にできません_ 。"

#: src/syntax-extensions/expansion.md:84
msgid ""
"There is one further thing to note about expansion: what happens when a syntax "
"extension expands to something that contains _another_ syntax extension "
"invocation. For example, consider an alternative definition of `four!`; what "
"happens if it expands to `1 + three!()`?"
msgstr ""
"展開について、もう１つ注意すべきことがあります: 構文拡張がほかの構文拡張を含む"
"形に展開されたとき何が起こるかです。例えば、別の定義の `four!` を考えてみましょ"
"う; それが `1 + three!()` に展開されるとしたらどうでしょう？"

#: src/syntax-extensions/expansion.md:91
msgid "Expands to:"
msgstr "展開すると:"

#: src/syntax-extensions/expansion.md:97
msgid ""
"This is resolved by the compiler checking the result of expansions for "
"additional syntax extension invocations, and expanding them. Thus, a second "
"expansion step turns the above into:"
msgstr ""
"この問題は、コンパイラが展開の結果をチェックして構文拡張の追加の呼び出しがない"
"かどうかを確認し、それを展開することで解決されます。したがって、2回目の展開ス"
"テップで上記から次のようになります:"

#: src/syntax-extensions/expansion.md:104
msgid ""
"The takeaway here is that expansion happens in \"passes\"; as many as is "
"needed to completely expand all invocations."
msgstr ""
"ここで重要なことは、展開は、すべての呼び出しを完全に展開するのに必要とされるだ"
"けの「パス」で行われるということです。"

#: src/syntax-extensions/expansion.md:107
msgid ""
"Well, not _quite_. In fact, the compiler imposes an upper limit on the number "
"of such recursive passes it is willing to run before giving up. This is known "
"as the syntax extension recursion limit and defaults to 128. If the 128th "
"expansion contains a syntax extension invocation, the compiler will abort with "
"an error indicating that the recursion limit was exceeded."
msgstr ""
"まぁそれだけではありません。実際のところ、コンパイラはこのような再帰パスの回数"
"に、ギブアップするまでの上限を設けています。これは構文拡張再帰制限として知ら"
"れ、デフォルトは128です。128回目の展開に構文拡張の呼び出しが含まれていると、コ"
"ンパイラは再帰制限を超えたことを示すエラーで中断します。"

#: src/syntax-extensions/expansion.md:112
msgid ""
"This limit can be raised using the `#![recursion_limit=\"…\"]` [attribute]"
"(https://doc.rust-lang.org/reference/attributes/limits.html#the-"
"recursion_limit-attribute), though it _must_ be done crate-wide. Generally, it "
"is recommended to try and keep syntax extension below this limit wherever "
"possible as it may impact compilation times."
msgstr ""
"この制限は `#![recursion_limit=\"…\"]` [アトリビュート](https://doc.rust-lang."
"org/reference/attributes/limits.html#the-recursion_limit-attribute) を使って上"
"げることができますが、クレート全体で行わなければ _なりません_ 。一般的に、コン"
"パイル時間に影響を与える可能性があるため、可能な限り構文拡張をこの制限以下に抑"
"えることが推奨されます。"

#: src/syntax-extensions/hygiene.md:3
msgid ""
"Hygiene is an important concept for macros. It describes the ability for a "
"macro to work in its own syntax context, not affecting nor being affected by "
"its surroundings. In other words this means that a syntax extension should be "
"invocable anywhere without interfering with its surrounding context."
msgstr ""
"ハイジーン（衛生的なこと）はマクロにとって重要な概念です。これは、マクロがそれ"
"自身の構文コンテキストで動作し、その周囲に影響を与えたり、周囲から影響を受けた"
"りしないことを表します。言い換えれば、これは構文拡張が周囲のコンテキストに干渉"
"することなく、どこでも呼び出せなければならないことを意味します。"

#: src/syntax-extensions/hygiene.md:7
msgid ""
"In a perfect world all syntax extensions in Rust would be fully hygienic, "
"unfortunately this isn't the case, so care should be taken to avoid writing "
"syntax extensions that aren't fully hygienic. We will go into general hygiene "
"concepts here which will be touched upon in the corresponding hygiene chapters "
"for the different syntax extensions Rust has to offer."
msgstr ""
"完璧な世界であれば、Rustのすべての構文拡張が完全にハイジーン的であるでしょう"
"が、残念ながらそうではありません。ここでは、Rustが提供するさまざまな構文拡張に"
"対応するハイジーンの章で触れる、一般的なハイジーンの概念について説明します。"

#: src/syntax-extensions/hygiene.md:10 src/decl-macros/macros-methodical.md:265
msgid " "
msgstr " "

# あとで判断
# ・最初の文の emitted は identifiers and paths と paths どちらに掛かっているか？
# →後の文からidenfifiersにもかかっているっぽい
#: src/syntax-extensions/hygiene.md:12
msgid ""
"Hygiene mainly affects identifiers and paths emitted by syntax extensions. In "
"short, if an identifier created by a syntax extension cannot be accessed by "
"the environment where the syntax extension has been invoked it is hygienic in "
"regards to that identifier. Likewise, if an identifier used in a syntax "
"extension cannot reference something defined outside of a syntax extension it "
"is considered hygienic."
msgstr ""
"ハイジーンは主に構文拡張が生成する識別子とパスに影響します。要するに、構文拡張"
"によって生成された識別子が、構文拡張が呼び出された環境からアクセスできない場"
"合、その識別子に関してはハイジーンであると言えます。同様に、構文拡張で使用され"
"る識別子が、構文拡張の外部で定義されたものを参照できない場合、それはハイジーン"
"であると考えられます。"

#: src/syntax-extensions/hygiene.md:16
msgid ""
"**Note**: The terms `create` and `use` refer to the position the identifier is "
"in. That is the `Foo` in `struct Foo {}` or the `foo` in `let foo = …;` are "
"created in the sense that they introduce something new under the name, but the "
"`Foo` in `fn foo(_: Foo) {}` or the `foo` in `foo + 3` are usages in the sense "
"that they are referring to something existing."
msgstr ""
"**注意**: `生成` と `使用` という言葉は、識別子がどの位置にあるかを表していま"
"す。つまり、`struct Foo {}` の `Foo` や `let foo = ...;` の `foo` は、その名前"
"の下に何か新しいものを導入するという意味で、create されたものです。しかし、`fn "
"foo(_: Foo) {}` の `Foo` や `foo + 3` の `foo` は、既存のものを参照しているとい"
"う意味で、使用されたものです。"

#: src/syntax-extensions/hygiene.md:20
msgid "This is best shown by example."
msgstr "これは例で示すのが一番です。"

#: src/syntax-extensions/hygiene.md:22
msgid ""
"Let's assume we have some syntax extension `make_local` that expands to `let "
"local = 0;`, that is it _creates_ the identifier `local`. Then given the "
"following snippet:"
msgstr ""
"例えば、構文拡張 `make_local` があり、これが `let local = 0;` に展開されるもの"
"とします。これは識別子 `local` を _生成_ します。そして、次のようなスニペットが"
"あるとします:"

#: src/syntax-extensions/hygiene.md:29
msgid ""
"If the `local` in `assert_eq!(local, 0);` resolves to the local defined by the "
"syntax extension, the syntax extension is not hygienic (at least in regards to "
"local names/bindings)."
msgstr ""
"`assert_eq!(local, 0);` の中の `local` が構文拡張で定義された local に解決され"
"る場合、構文拡張は (少なくともローカルの名前/束縛に関して) ハイジーンではありま"
"せん。"

#: src/syntax-extensions/hygiene.md:31
msgid ""
"Now let's assume we have some syntax extension `use_local` that expands to "
"`local = 42;`, that is it makes _use_ of the identifier `local`. Then given "
"the following snippet:"
msgstr ""
"ここで、構文拡張 `use_local` があり、これが `local = 42;` に展開されるとしま"
"す。これは識別子 `local` の _使用_ を行うものです。そして、次のようなスニペット"
"があるとします:"

#: src/syntax-extensions/hygiene.md:38
msgid ""
"If the `local` inside of the syntax extension for the given invocation "
"resolves to the local defined before its invocation, the syntax extension is "
"not hygienic either."
msgstr ""
"呼び出された構文拡張の中の `local` が、その呼び出しの前に定義されている local "
"に解決される場合、この構文拡張もハイジーンではありません。"

#: src/syntax-extensions/hygiene.md:40
msgid ""
"This is a rather short introduction to the general concept of hygiene. It will "
"be explained in more depth in the corresponding [`macro_rules!` `hygiene`](../"
"decl-macros/minutiae/hygiene.md) and [proc-macro `hygiene`](../proc-macros/"
"hygiene.md) chapters, with their specific peculiarities."
msgstr ""
"これはハイジーンの一般的な概念についてのやや短い紹介です。これは、対応する"
"[`macro_rules!` `ハイジーン`](../decl-macros/minutiae/hygiene.md)と[proc-macro "
"`ハイジーン`](../proc-macros/hygiene.md)の章において、それら特有の特徴ととも"
"に、より深く説明します。"

#: src/syntax-extensions/debugging.md:3
msgid ""
"`rustc` provides a number of tools to debug general syntax extensions, as well "
"as some more specific ones tailored towards declarative and procedural macros "
"respectively."
msgstr ""
"`rustc` は、一般的な構文拡張をデバッグするためのツールや、宣言型マクロや手続き"
"型マクロに特化したツールを提供しています。"

#: src/syntax-extensions/debugging.md:6
msgid ""
"Sometimes, it is what the extension _expands to_ that proves problematic as "
"you do not usually see the expanded code. Fortunately `rustc` offers the "
"ability to look at the expanded code via the unstable `-Zunpretty=expanded` "
"argument. Given the following code:"
msgstr ""
"ときに、構文拡張が何に展開されたのか、が問題になります。展開されたコードをみる"
"ことができないためです。幸いなことに `rustc` は展開されたコードを見ることを可能"
"にする機能を、不安定バージョンの `-Zunpretty=expanded` 引数を使えば、提供してい"
"ます。次のようなコードがあるとします:"

#: src/syntax-extensions/debugging.md:10
msgid ""
"```rust,ignore\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S {\n"
"    ($e:expr) => {String::from($e)};\n"
"}\n"
"\n"
"fn main() {\n"
"    let world = S!(\"World\");\n"
"    println!(\"Hello, {}!\", world);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// `String` 初期化の省略記法\n"
"macro_rules! S {\n"
"    ($e:expr) => {String::from($e)};\n"
"}\n"
"\n"
"fn main() {\n"
"    let world = S!(\"World\");\n"
"    println!(\"Hello, {}!\", world);\n"
"}\n"
"```"

#: src/syntax-extensions/debugging.md:22
msgid "compiled with the following command:"
msgstr "以下のコマンドでコンパイルされます:"

#: src/syntax-extensions/debugging.md:28
msgid "produces the following output (modified for formatting):"
msgstr "次のような出力を生成します（フォーマットを修正したものです）:"

#: src/syntax-extensions/debugging.md:30
msgid ""
"```rust,ignore\n"
"#![feature(prelude_import)]\n"
"#[prelude_import]\n"
"use std::prelude::rust_2018::*;\n"
"#[macro_use]\n"
"extern crate std;\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S { ($e : expr) => { String :: from($e) } ; }\n"
"\n"
"fn main() {\n"
"    let world = String::from(\"World\");\n"
"    {\n"
"        ::std::io::_print(\n"
"            ::core::fmt::Arguments::new_v1(\n"
"                &[\"Hello, \", \"!\\n\"],\n"
"                &match (&world,) {\n"
"                    (arg0,) => [\n"
"                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::"
"Display::fmt)\n"
"                    ],\n"
"                }\n"
"            )\n"
"        );\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#![feature(prelude_import)]\n"
"#[prelude_import]\n"
"use std::prelude::rust_2018::*;\n"
"#[macro_use]\n"
"extern crate std;\n"
"// `String` 初期化の省略記法\n"
"macro_rules! S { ($e : expr) => { String :: from($e) } ; }\n"
"\n"
"fn main() {\n"
"    let world = String::from(\"World\");\n"
"    {\n"
"        ::std::io::_print(\n"
"            ::core::fmt::Arguments::new_v1(\n"
"                &[\"Hello, \", \"!\\n\"],\n"
"                &match (&world,) {\n"
"                    (arg0,) => [\n"
"                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::"
"Display::fmt)\n"
"                    ],\n"
"                }\n"
"            )\n"
"        );\n"
"    };\n"
"}\n"
"```"

#: src/syntax-extensions/debugging.md:56
msgid ""
"But not just `rustc` exposes means to aid in debugging syntax extensions. For "
"the aforementioned `-Zunpretty=expanded` option, there exists a nice `cargo` "
"plugin called [`cargo-expand`](https://github.com/dtolnay/cargo-expand) made "
"by [`dtolnay`](https://github.com/dtolnay) which is basically just a wrapper "
"around it."
msgstr ""
"しかし、構文拡張のデバッグを支援する手段を公開しているのは `rustc` だけではあり"
"ません。前述の `-Zunpretty=expanded` オプションについては、[`dtolnay`](https://"
"github.com/dtolnay) によって作られた [`cargo-expand`](https://github.com/"
"dtolnay/cargo-expand) という素晴らしい `cargo` プラグインがあります。これは基本"
"的には単純なラッパーです。"

#: src/syntax-extensions/debugging.md:59
msgid ""
"You can also use the [playground](https://play.rust-lang.org/), clicking on "
"its `TOOLS` button in the top right gives you the option to expand syntax "
"extensions as well!"
msgstr ""
"また、[playground](https://play.rust-lang.org/)を使うこともできます。右上の "
"`TOOLS` ボタンをクリックすると、構文拡張を展開するオプションが表示されます！"

#: src/decl-macros.md:3
msgid ""
"This chapter will introduce Rust's declarative macro system: [`macro_rules!`]"
"(https://doc.rust-lang.org/reference/macros-by-example.html)."
msgstr ""
"この章ではRustの宣言型マクロシステム: [`macro_rules!`](https://doc.rust-lang."
"org/reference/macros-by-example.html) を紹介します。"

#: src/decl-macros.md:5
msgid ""
"There are two different introductions in this chapter, a [methodical](./decl-"
"macros/macros-methodical.md) and a [practical](./decl-macros/macros-practical."
"md)."
msgstr ""
"この章では、[方法論的](./decl-macros/macros-methodical.md)と[実践的](./decl-"
"macros/macros-practical.md)の2種類のイントロダクションがあります。"

#: src/decl-macros.md:7
msgid ""
"The former will attempt to give you a complete and thorough explanation of "
"_how_ the system works, while the latter one will cover more practical "
"examples. As such, the [methodical introduction](./decl-macros/macros-"
"methodical.md) is intended for people who just want the system as a whole "
"explained, while the [practical introduction](./decl-macros/macros-practical."
"md) guides one through the implementation of a single macro."
msgstr ""
"前者は、このシステムが _どのように_ 動作するのかを完全かつ徹底的に説明しようと"
"するもので、後者はより実践的な例を扱います。このように、[方法論的イントロダク"
"ション](./decl-macros/macros-methodical.md)はシステム全体の説明が欲しい人向け"
"で、[実践的イントロダクション](./decl-macros/macros-practical.md)は1つのマクロ"
"の実装をガイドするものです。"

#: src/decl-macros.md:10
msgid ""
"Following up the two introductions it offers some generally very useful "
"[patterns](./decl-macros/patterns.md) and [building blocks](./decl-macros/"
"building-blocks.md) for creating feature-rich macros."
msgstr ""
"2つのイントロダクションに続いて、機能豊富なマクロを作成するための、一般的に非常"
"に便利な[パターン](./decl-macros/patterns.md)と[ビルディングブロック](./decl-"
"macros/building-blocks.md)を提供しています。"

#: src/decl-macros.md:12
msgid ""
"Other resources about declarative macros include the [Macros chapter of the "
"Rust Book](https://doc.rust-lang.org/book/ch19-06-macros.html) which is a more "
"approachable, high-level explanation as well as the reference [chapter]"
"(https://doc.rust-lang.org/reference/macros-by-example.html) which goes more "
"into the precise details of things."
msgstr ""
"宣言型マクロに関する他のリソースとしては、[Rust Bookの Macros chapter](https://"
"doc.rust-lang.org/book/ch19-06-macros.html)があり、より親しみやすくハイレベルな"
"説明になっています。また、リファレンスの [chapter](https://doc.rust-lang.org/"
"reference/macros-by-example.html)では、より詳細な内容まで言及しています。"

#: src/decl-macros.md:14
msgid ""
"**Note**: This book will usually use the term _mbe_(**M**acro-**B**y-"
"**E**xample), _mbe macro_ or `macro_rules!` macro when talking about "
"`macro_rules!` macros."
msgstr ""
"**注**: 本書では`macro_rules` マクロについて述べるときに、通常 mbe(**M**acro-"
"**B**y-**E**xample)、 _mbe macro_ または `macro_rules!` マクロという用語を使い"
"ます。"

#: src/decl-macros/macros-methodical.md:1
msgid "Macros, A Methodical Introduction"
msgstr "マクロ、方法論的イントロダクション"

#: src/decl-macros/macros-methodical.md:3
msgid ""
"This chapter will introduce Rust's declarative [Macro-By-Example](https://doc."
"rust-lang.org/reference/macros-by-example.html) system by explaining the "
"system as a whole. It will do so by first going into the construct's syntax "
"and its key parts and then following it up with more general information that "
"one should at least be aware of."
msgstr ""
"この章では、Rust の宣言型 [Macro-By-Example](https://doc.rust-lang.org/"
"reference/macros-by-example.html) システムを、システム全体を説明する形で、紹介"
"します。まず、構成要素の構文とその主要な部分について説明し、その後に、少なくと"
"も知っておくべき一般的な情報を説明します。"

#: src/decl-macros/macros-methodical.md:9
msgid "`macro_rules!`"
msgstr "`macro_rules!`"

#: src/decl-macros/macros-methodical.md:11
msgid ""
"With all that in mind, we can introduce `macro_rules!` itself. As noted "
"previously, `macro_rules!` is _itself_ a syntax extension, meaning it is "
"_technically_ not part of the Rust syntax. It uses the following forms:"
msgstr ""
"これを踏まえて、 `macro_rules!` そのものを紹介します。前述したように、"
"`macro_rules!`は _それ自身_ 構文拡張であり、技術的にはRustの構文の一部ではあり"
"ません。これは以下の形式を使用します:"

#: src/decl-macros/macros-methodical.md:15
msgid ""
"```rust,ignore\n"
"macro_rules! $name {\n"
"    $rule0 ;\n"
"    $rule1 ;\n"
"    // …\n"
"    $ruleN ;\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"macro_rules! $name {\n"
"    $rule0 ;\n"
"    $rule1 ;\n"
"    // …\n"
"    $ruleN ;\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:24
msgid ""
"There must be _at least_ one rule, and you can omit the semicolon after the "
"last rule. You can use brackets(`[]`), parentheses(`()`) or braces(`{}`)."
msgstr ""
"ルールは _最低_ 1つ必要で、最後のルールの後のセミコロンは省略できます。角括弧"
"(`[]`)、丸括弧(`()`)、または波括弧(`{}`)を使うことができます。"

#: src/decl-macros/macros-methodical.md:27
msgid "Each _\"rule\"_ looks like the following:"
msgstr "それぞれの_「ルール」_ は以下のようなものです:"

#: src/decl-macros/macros-methodical.md:33
msgid ""
"Like before, the types of parentheses used can be any kind, but parentheses "
"around the matcher and braces around the expansion are somewhat conventional. "
"The expansion part of a rule is also called its _transcriber_."
msgstr ""
"先ほどと同様、使用する括弧の種類は何でもかまいませんが、 マッチャー（matcher） "
"を括弧で囲み、展開部を中括弧で囲むのが慣習的なようです。ルールの展開部分は、"
"_transcriber_ とも呼ばれます。"

#: src/decl-macros/macros-methodical.md:36
msgid ""
"Note that the choice of the parentheses does not matter in regards to how the "
"mbe macro may be invoked. In fact, function-like macros can be invoked with "
"any kind of parentheses as well, but invocations with `{ .. }` and `( ... );`, "
"notice the trailing semicolon, are special in that their expansion will "
"_always_ be parsed as an _item_."
msgstr ""
"括弧の選択は mbe マクロの呼び出し方に関して重要でないことに注意してください。実"
"際、関数型マクロはどのような括弧でも呼び出すことができますが、 `{ ... }` と "
"`( ... );` （最後にセミコロンがあることに注意）を使った呼び出しは例外的で、その"
"展開が常にアイテムとして解析されます。"

#: src/decl-macros/macros-methodical.md:39
msgid ""
"If you are wondering, the `macro_rules!` invocation expands to... _nothing_. "
"At least, nothing that appears in the AST; rather, it manipulates compiler-"
"internal structures to register the mbe macro. As such, you can _technically_ "
"use `macro_rules!` in any position where an empty expansion is valid."
msgstr ""
"不思議に思うかもしれませんが、`macro_rules!` の呼び出しは ... _無_ に展開されま"
"す。少なくとも、ASTには何も現れません; mbeマクロを登録するためにコンパイラ内部"
"の構造を操作します。そのため、`macro_rules!` は _技術的には_ 空の式が有効なあら"
"ゆる場所にて使用できます。"

#: src/decl-macros/macros-methodical.md:43
msgid "Matching"
msgstr "マッチング"

#: src/decl-macros/macros-methodical.md:45
msgid ""
"When a `macro_rules!` macro is invoked, the `macro_rules!` interpreter goes "
"through the rules one by one, in declaration order. For each rule, it tries to "
"match the contents of the input token tree against that rule's `matcher`. A "
"matcher must match the _entirety_ of the input to be considered a match."
msgstr ""
"`macro_rules!` マクロが呼び出されると、 `macro_rules!` インタプリタは、宣言順に"
"１つ１つルールを調査します。各ルールに対し、ルールの `matcher` と、入力トークン"
"ツリーの内容がマッチするか試します。マッチャーは入力の _全体_ とマッチしなけれ"
"ば、マッチしたものと考えられません。"

#: src/decl-macros/macros-methodical.md:49
msgid ""
"If the input matches the matcher, the invocation is replaced by the "
"`expansion`; otherwise, the next rule is tried. If all rules fail to match, "
"the expansion fails with an error."
msgstr ""
"入力がマッチャーにマッチした場合、その呼び出しは `expansion` に置き換えられま"
"す。そうでなければ次のルールが試行されます。すべてのルールがマッチしなかった場"
"合、展開に失敗してエラーになります。"

#: src/decl-macros/macros-methodical.md:52
msgid "The simplest example is of an empty matcher:"
msgstr "最も単純な例は空のマッチャーです:"

#: src/decl-macros/macros-methodical.md:60
msgid ""
"This matches if and only if the input is also empty (_i.e._ `four!()`, `four!"
"[]` or `four!{}`)."
msgstr ""
"これは入力も空である場合(つまり `four!()`、`four![]`、`four!{}`)にのみマッチし"
"ます。"

#: src/decl-macros/macros-methodical.md:62
msgid ""
"Note that the specific grouping tokens you use when you invoke the function-"
"like macro _are not_ matched, they are in fact not passed to the invocation at "
"all. That is, you can invoke the above macro as `four![]` and it will still "
"match. Only the _contents_ of the input token tree are considered."
msgstr ""
"関数型マクロを呼び出すときに使用するグループ化トークンはマッチ _せず_ 、実際呼"
"び出しには一切渡されないことに注意してください。つまり、上記のマクロを `four!"
"[]` として呼び出し可能で、これはマッチしています。入力トークンツリーの _内容_ "
"だけが考慮されます。"

#: src/decl-macros/macros-methodical.md:66
msgid ""
"Matchers can also contain literal token trees, which must be matched exactly. "
"This is done by simply writing the token trees normally. For example, to match "
"the sequence `4 fn ['spang \"whammo\"] @_@`, you would write:"
msgstr ""
"マッチャーはリテラルトークンツリーを含めることもでき、ぴったりとマッチする必要"
"があります。これは、単純にトークンツリーを通常通り書くことで表現されます。例え"
"ば、`4 fn ['spang \"whammo\"] @_@` というシーケンスにマッチさせるには、次のよう"
"に書きます:"

#: src/decl-macros/macros-methodical.md:70
msgid ""
"```rust,ignore\n"
"macro_rules! gibberish {\n"
"    (4 fn ['spang \"whammo\"] @_@) => {...};\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"macro_rules! gibberish {\n"
"    (4 fn ['spang \"whammo\"] @_@) => {...};\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:76
msgid "You can use any token tree that you can write."
msgstr "あなたが書くことができる任意のトークンツリーが使用可能です。"

#: src/decl-macros/macros-methodical.md:78
msgid "Metavariables"
msgstr "メタ変数"

#: src/decl-macros/macros-methodical.md:80
msgid ""
"Matchers can also contain captures. These allow input to be matched based on "
"some general grammar category, with the result captured to a metavariable "
"which can then be substituted into the output."
msgstr ""
"マッチャーはキャプチャを含むこともできます。これにより、一般的な文法カテゴリに"
"基づいて入力をマッチングし、その結果をメタ変数にキャプチャして出力に代入するこ"
"とができます。"

#: src/decl-macros/macros-methodical.md:83
msgid ""
"Captures are written as a dollar (`$`) followed by an identifier, a colon (`:"
"`), and finally the kind of capture which is also called the fragment-"
"specifier, which must be one of the following:"
msgstr ""
"キャプチャはドル記号(`$`)に続けて識別子、コロン(`:`)、最後にフラグメント指定子"
"とも呼ばれるキャプチャの種類を書きます。フラグメント式月氏は以下のいずれか一つ"
"である必要があります:"

#: src/decl-macros/macros-methodical.md:85
msgid ""
"[`block`](./minutiae/fragment-specifiers.md#block): a block (i.e. a block of "
"statements and/or an expression, surrounded by braces)"
msgstr ""
"[`block`](./minutiae/fragment-specifiers.md#block): ブロック (つまり、波括弧で"
"囲まれたステートメントや式のブロック)"

#: src/decl-macros/macros-methodical.md:86
msgid "[`expr`](./minutiae/fragment-specifiers.md#expr): an expression"
msgstr "[`expr`](./minutiae/fragment-specifiers.md#expr): 式"

#: src/decl-macros/macros-methodical.md:87
msgid ""
"[`ident`](./minutiae/fragment-specifiers.md#ident): an identifier (this "
"includes keywords)"
msgstr ""
"[`ident`](./minutiae/fragment-specifiers.md#ident): 識別子 (キーワードも含む)"

#: src/decl-macros/macros-methodical.md:88
msgid ""
"[`item`](./minutiae/fragment-specifiers.md#item): an item, like a function, "
"struct, module, impl, etc."
msgstr ""
"[`item`](./minutiae/fragment-specifiers.md#item): 関数、構造体、モジュール、"
"implのようなアイテム。"

#: src/decl-macros/macros-methodical.md:89
msgid ""
"[`lifetime`](./minutiae/fragment-specifiers.md#lifetime): a lifetime (e.g. "
"`'foo`, `'static`, ...)"
msgstr ""
"[`lifetime`](./minutiae/fragment-specifiers.md#lifetime): ライフタイム (例 "
"`'foo`、`'static`、...)"

#: src/decl-macros/macros-methodical.md:90
msgid ""
"[`literal`](./minutiae/fragment-specifiers.md#literal): a literal (e.g. "
"`\"Hello World!\"`, `3.14`, `'🦀'`, ...)"
msgstr ""
"[`literal`](./minutiae/fragment-specifiers.md#literal): リテラル (例 `\"Hello "
"World!\"`, `3.14`, `'🦀'`, ...)"

#: src/decl-macros/macros-methodical.md:91
msgid ""
"[`meta`](./minutiae/fragment-specifiers.md#meta): a meta item; the things that "
"go inside the `#[...]` and `#![...]` attributes"
msgstr ""
"[`meta`](./minutiae/fragment-specifiers.md#meta): メタアイテム; `#[...]` や `#!"
"[...]` アトリビュートの中に入るもの"

#: src/decl-macros/macros-methodical.md:92
msgid "[`pat`](./minutiae/fragment-specifiers.md#pat): a pattern"
msgstr "[`pat`](./minutiae/fragment-specifiers.md#pat): パターン"

#: src/decl-macros/macros-methodical.md:93
msgid ""
"[`path`](./minutiae/fragment-specifiers.md#path): a path (e.g. `foo`, `::std::"
"mem::replace`, `transmute::<_, int>`, …)"
msgstr ""
"[`path`](./minutiae/fragment-specifiers.md#path): パス (例: `foo`, `::std::"
"mem::replace`, `transmute::<_, int>`, ...)"

#: src/decl-macros/macros-methodical.md:94
msgid "[`stmt`](./minutiae/fragment-specifiers.md#stmt): a statement"
msgstr "[`stmt`](./minutiae/fragment-specifiers.md#stmt): 文"

#: src/decl-macros/macros-methodical.md:95
msgid "[`tt`](./minutiae/fragment-specifiers.md#tt): a single token tree"
msgstr "[`tt`](./minutiae/fragment-specifiers.md#tt): 単一のトークンツリー"

#: src/decl-macros/macros-methodical.md:96
msgid "[`ty`](./minutiae/fragment-specifiers.md#ty): a type"
msgstr "[`ty`](./minutiae/fragment-specifiers.md#ty): 型"

#: src/decl-macros/macros-methodical.md:97
msgid ""
"[`vis`](./minutiae/fragment-specifiers.md#vis): a possible empty visibility "
"qualifier (e.g. `pub`, `pub(in crate)`, ...)"
msgstr ""
"[`vis`](./minutiae/fragment-specifiers.md#vis): 空を含む可視性修飾子 (例:"
"`pub`, `pub(in crate)`, ...)"

#: src/decl-macros/macros-methodical.md:99
msgid ""
"For more in-depth description of the fragment specifiers, check out the "
"[Fragment Specifiers](./minutiae/fragment-specifiers.md) chapter."
msgstr ""
"フラグメント指定子についての詳しい説明は、[フラグメント指定子](./minutiae/"
"fragment-specifiers.md)の章を参照してください。"

#: src/decl-macros/macros-methodical.md:101
msgid ""
"For example, here is a `macro_rules!` macro which captures its input as an "
"expression under the metavariable `$e`:"
msgstr ""
"例えば、`macro_rules!`マクロは入力をメタ変数 `$e` に式として取り込みます:"

#: src/decl-macros/macros-methodical.md:109
msgid ""
"These metavariables leverage the Rust compiler's parser, ensuring that they "
"are always \"correct\". An `expr` metavariables will _always_ capture a "
"complete, valid expression for the version of Rust being compiled."
msgstr ""
"これらのメタ変数は Rust コンパイラのパーサを活用し、それらが常に「正しい」こと"
"を保証します。メタ変数 `expr` は、コンパイルされている Rust のバージョンにとっ"
"て、 _常に_ 完全で有効な式をキャプチャします。"

#: src/decl-macros/macros-methodical.md:112
msgid ""
"You can mix literal token trees and metavariables, within limits (explained in "
"[Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md))."
msgstr ""
"リテラルトークンツリーとメタ変数は、制限の範囲内で混在させることができます"
"（[Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md)で説"
"明しています）。"

#: src/decl-macros/macros-methodical.md:114
msgid ""
"To refer to a metavariable you simply write `$name`, as the type of the "
"variable is already specified in the matcher. For example:"
msgstr ""
"メタ変数を参照するには、変数の型はマッチャーにすでに指定されていますから、単に "
"`$name` と書きます。例えば:"

#: src/decl-macros/macros-methodical.md:122
msgid ""
"Much like macro expansion, metavariables are substituted as complete AST "
"nodes. This means that no matter what sequence of tokens is captured by `$e`, "
"it will be interpreted as a single, complete expression."
msgstr ""
"マクロ展開と同様に、メタ変数は完全な AST ノードとして代入されます。つまり、`$e`"
"がどのようなトークンの並びであっても、それは1つの完全な式として解釈されます。"

#: src/decl-macros/macros-methodical.md:125
msgid "You can also have multiple metavariables in a single matcher:"
msgstr "1つのマッチャーに複数のメタ変数を指定することもできます:"

#: src/decl-macros/macros-methodical.md:133
msgid "And use them as often as you like in the expansion:"
msgstr "そして、その展開を好きなだけ行えます:"

#: src/decl-macros/macros-methodical.md:144
msgid ""
"There is also a special metavariable called [`$crate`](./minutiae/hygiene."
"md#crate) which can be used to refer to the current crate."
msgstr ""
"また、[`$crate`](./minutiae/hygiene.md#crate)という特別なメタ変数があり、現在の"
"クレートを参照するために使用できます。"

#: src/decl-macros/macros-methodical.md:149
msgid "Repetitions"
msgstr "反復"

#: src/decl-macros/macros-methodical.md:151
msgid ""
"Matchers can contain repetitions. These allow a sequence of tokens to be "
"matched. These have the general form `$ ( ... ) sep rep`."
msgstr ""
"マッチャーには反復を含めることができます。これらは一連のトークンにマッチさせる"
"ことができます。これは一般的な形式 `$ ( ... ) sep rep` を持ちます。"

#: src/decl-macros/macros-methodical.md:154
msgid "`$` is a literal dollar token."
msgstr "`$` はリテラルのドル記号トークンです。"

#: src/decl-macros/macros-methodical.md:155
msgid "`( ... )` is the paren-grouped matcher being repeated."
msgstr "`( ... )` は括弧でグループ化された反復対象のマッチャーです。"

#: src/decl-macros/macros-methodical.md:156
msgid ""
"`sep` is an _optional_ separator token. It may not be a delimiter or one of "
"the repetition operators. Common examples are `,` and `;`."
msgstr ""
"`sep` は _オプションの_ セパレータトークンです。区切り文字や反復演算子ではあり"
"ません。一般的な例は `,` と `;` です。"

#: src/decl-macros/macros-methodical.md:158
msgid "`rep` is the _required_ repeat operator. Currently, this can be:"
msgstr "`rep` は _必須の_ 反復演算子です。現在、これは:"

#: src/decl-macros/macros-methodical.md:159
msgid "`?`: indicating at most one repetition"
msgstr "`?`: 最大1回の反復を示します"

#: src/decl-macros/macros-methodical.md:160
msgid "`*`: indicating zero or more repetitions"
msgstr "`*`: は0回以上の反復を示します"

#: src/decl-macros/macros-methodical.md:161
msgid "`+`: indicating one or more repetitions"
msgstr "`+`: 1回以上の反復を示します"

#: src/decl-macros/macros-methodical.md:163
msgid ""
"Since `?` represents at most one occurrence, it cannot be used with a "
"separator."
msgstr "`?` は最大1回の出現を表すため、セパレータと一緒に使うことはできません。"

#: src/decl-macros/macros-methodical.md:165
msgid ""
"Repetitions can contain any other valid matcher, including literal token "
"trees, metavariables, and other repetitions allowing arbitrary nesting."
msgstr ""
"反復には、リテラルトークンツリー、メタ変数、任意の入れ子が可能な他の反復など、"
"他の有効なマッチャーを含めることができます。"

#: src/decl-macros/macros-methodical.md:167
msgid ""
"Repetitions use the same syntax in the expansion and repeated metavariables "
"can only be accessed inside of repetitions in the expansion."
msgstr ""
"反復は展開の中で同じ構文を使用し、反復されたメタ変数は展開の中の反復の中でしか"
"アクセスできません。"

#: src/decl-macros/macros-methodical.md:169
msgid ""
"For example, below is a mbe macro which formats each element as a string. It "
"matches zero or more comma-separated expressions and expands to an expression "
"that constructs a vector."
msgstr ""
"例えば、以下は各要素を文字列としてフォーマットするmbeマクロです。カンマで区切ら"
"れた0個以上の式にマッチし、ベクタを構築する式に展開されます。"

#: src/decl-macros/macros-methodical.md:172
msgid ""
"```rust\n"
"macro_rules! vec_strs {\n"
"    (\n"
"        // Start a repetition:\n"
"        $(\n"
"            // Each repeat must contain an expression...\n"
"            $element:expr\n"
"        )\n"
"        // ...separated by commas...\n"
"        ,\n"
"        // ...zero or more times.\n"
"        *\n"
"    ) => {\n"
"        // Enclose the expansion in a block so that we can use\n"
"        // multiple statements.\n"
"        {\n"
"            let mut v = Vec::new();\n"
"\n"
"            // Start a repetition:\n"
"            $(\n"
"                // Each repeat will contain the following statement, with\n"
"                // $element replaced with the corresponding expression.\n"
"                v.push(format!(\"{}\", $element));\n"
"            )*\n"
"\n"
"            v\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let s = vec_strs![1, \"a\", true, 3.14159f32];\n"
"    assert_eq!(s, &[\"1\", \"a\", \"true\", \"3.14159\"]);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! vec_strs {\n"
"    (\n"
"        // 反復の開始:\n"
"        $(\n"
"            // 各反復は式を含み...\n"
"            $element:expr\n"
"        )\n"
"        // ...カンマで区切られ...\n"
"        ,\n"
"        // ...0回以上のもの。\n"
"        *\n"
"    ) => {\n"
"        // 複数の文を使用可能にするため、展開をブロックで囲みます\n"
"        {\n"
"            let mut v = Vec::new();\n"
"\n"
"            // 繰り返しの開始:\n"
"            $(\n"
"                //各反復は以下の文を含み、\n"
"                // その $element は対応する式に置き換えられます\n"
"                v.push(format!(\"{}\", $element));\n"
"            )*\n"
"\n"
"            v\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let s = vec_strs![1, \"a\", true, 3.14159f32];\n"
"    assert_eq!(s, &[\"1\", \"a\", \"true\", \"3.14159\"]);\n"
"}\n"
"```"

#: src/decl-macros/macros-methodical.md:208
msgid ""
"You can repeat multiple metavariables in a single repetition as long as all "
"metavariables repeat equally often. So this invocation of the following macro "
"works:"
msgstr ""
"すべてのメタ変数が同回数だけ反復される限り、1つの反復内にて複数のメタ変数を反復"
"することが可能です。よって、次のマクロの呼び出しは機能します:"

#: src/decl-macros/macros-methodical.md:221
msgid "But this does not:"
msgstr "対して、以下は機能しません:"

#: src/decl-macros/macros-methodical.md:233
msgid "failing with the following error"
msgstr "以下のエラーで失敗します"

#: src/decl-macros/macros-methodical.md:245
#: src/decl-macros/minutiae/metavar-expr.md:3
msgid ""
"_RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-"
"macro-metavar-expr.md)  \n"
"_Tracking Issue_: [rust#83527](https://github.com/rust-lang/rust/"
"issues/83527)  \n"
"_Feature_: `#![feature(macro_metavar_expr)]`"
msgstr ""
"_RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-"
"macro-metavar-expr.md)  \n"
"_Tracking Issue_: [rust#83527](https://github.com/rust-lang/rust/"
"issues/83527)  \n"
"_Feature_: `#![feature(macro_metavar_expr)]`"

#: src/decl-macros/macros-methodical.md:249
msgid ""
"Transcriber can contain what is called metavariable expressions. Metavariable "
"expressions provide transcribers with information about metavariables that are "
"otherwise not easily obtainable. With the exception of the `$$` expression, "
"these have the general form `$ { op(...) }`. Currently all metavariable "
"expressions but `$$` deal with repetitions."
msgstr ""
"transcriber には、メタ変数式と呼ばれるものを含めることができます。メタ変数式"
"は、他の方法では簡単には得られないメタ変数に関する情報を transcriber に提供しま"
"す。 `$$` 式を除いて、これらは一般的な形式 `$ { op(...) }` を持っています。現"
"在、`$$`以外のすべてのメタ変数式は反復を扱います。"

#: src/decl-macros/macros-methodical.md:254
msgid ""
"The following expressions are available with `ident` being the name of a bound "
"metavariable and `depth` being an integer literal:"
msgstr ""
"以下の式が、`ident` を束縛されたメタ変数の名前、`depth` を整数リテラルとして、"
"利用可能です:"

#: src/decl-macros/macros-methodical.md:256
msgid ""
"`${count(ident)}`: The number of times `$ident` repeats in the inner-most "
"repetition in total. This is equivalent to `${count(ident, 0)}`."
msgstr ""
"`${count(ident)}`: 一番内側の反復で `$ident` が反復される合計回数。これは "
"`${count(ident, 0)}` と同じです。"

#: src/decl-macros/macros-methodical.md:257
msgid ""
"`${count(ident, depth)}`: The number of times `$ident` repeats in the "
"repetition at `depth`."
msgstr "`${count(ident, depth)}`: `$ident` が深さ `depth` で反復される回数。"

#: src/decl-macros/macros-methodical.md:258
msgid ""
"`${index()}`: The current repetition index of the inner-most repetition. This "
"is equivalent to `${index(0)}`."
msgstr ""
"`${index()}`: 最も内側の反復の現在の反復インデックス。これは `${index(0)}` と同"
"じです。"

#: src/decl-macros/macros-methodical.md:259
msgid ""
"`${index(depth)}`: The current index of the repetition at `depth`, counting "
"outwards."
msgstr "`${index(depth)}`: 外側へ数えて `depth` の反復の現在のインデックス。"

#: src/decl-macros/macros-methodical.md:260
msgid ""
"`${length()}`: The number of times the inner-most repetition will repeat for. "
"This is equivalent to `${length(0)}`."
msgstr ""
"`${length()}`: 一番内側の最終的な反復回数。これは `${length(0)}` と同じです。"

#: src/decl-macros/macros-methodical.md:261
msgid ""
"`${length(depth)}`: The number of times the repetition at `depth` will repeat "
"for, counting outwards."
msgstr "`${length(depth)}`: 外側へ数えて `depth` の反復での反復回数。"

#: src/decl-macros/macros-methodical.md:262
msgid ""
"`${ignore(ident)}`: Binds `$ident` for repetition, while expanding to nothing."
msgstr ""
"`${ignore(ident)}`: 反復のために `$ident` を束縛しますが、何にも展開されませ"
"ん。"

#: src/decl-macros/macros-methodical.md:263
msgid ""
"`$$`:\tExpands to a single `$`, effectively escaping the `$` token so it won't "
"be transcribed."
msgstr ""
"`$$`: 1つの `$` に展開されます。`$` トークンを事実上エスケープして変換されない"
"ようにします。"

#: src/decl-macros/macros-methodical.md:267
msgid ""
"For the complete grammar definition you may want to consult the [Macros By "
"Example](https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-"
"example) chapter of the Rust reference."
msgstr ""
"完全な文法定義については、Rustリファレンスの[Macros By Example](https://doc."
"rust-lang.org/reference/macros-by-example.html#macros-by-example)の章を参照して"
"ください。"

#: src/decl-macros/macros-practical.md:1
msgid "Macros, A Practical Introduction"
msgstr "マクロ、実践的イントロダクション"

#: src/decl-macros/macros-practical.md:3
msgid ""
"This chapter will introduce Rust's declarative [Macro-By-Example](https://doc."
"rust-lang.org/reference/macros-by-example.html) system using a relatively "
"simple, practical example. It does _not_ attempt to explain all of the "
"intricacies of the system; its goal is to get you comfortable with how and why "
"macros are written."
msgstr ""
"この章では、Rust の宣言型 [Macro-By-Example](https://doc.rust-lang.org/"
"reference/macros-by-example.html) システムを、比較的シンプルで実用的な例を使っ"
"て紹介します。この章はこのシステムの複雑なものすべてを説明しようとするもの _で"
"はありません_ ; この章のゴールは、マクロがどのように、またなぜ書かれるのかを理"
"解することです。"

#: src/decl-macros/macros-practical.md:6
msgid ""
"There is also the [Macros chapter of the Rust Book](https://doc.rust-lang.org/"
"book/ch19-06-macros.html) which is another high-level explanation, and the "
"[methodical introduction](../decl-macros.md) chapter of this book, which "
"explains the macro system in detail."
msgstr ""
"[Rust Bookのマクロの章](https://doc.rust-lang.org/book/ch19-06-macros.html)にも"
"ハイレベルな説明があります。また、本書の[方法論的イントロダクション](../decl-"
"macros.md)の章もマクロシステムを詳しく説明しています。"

#: src/decl-macros/macros-practical.md:8
msgid "A Little Context"
msgstr "ちょっとした背景"

#: src/decl-macros/macros-practical.md:10
msgid ""
"**Note**: don't panic! What follows is the only math that will be talked "
"about. You can quite safely skip this section if you just want to get to the "
"meat of the article."
msgstr ""
"**注**: どうか慌てずに！ただの数学についてこれから話します。記事の本題に入りた"
"いだけなら、このセクションは読み飛ばしてかまいません。"

#: src/decl-macros/macros-practical.md:13
msgid ""
"If you aren't familiar, a recurrence relation is a sequence where each value "
"is defined in terms of one or more _previous_ values, with one or more initial "
"values to get the whole thing started. For example, the [Fibonacci sequence]"
"(https://en.wikipedia.org/wiki/Fibonacci_number) can be defined by the "
"relation:"
msgstr ""
"ご存じないかもしれませんが、漸化式とは、各値が1つまたは複数の _前の_ 値で定義さ"
"れ、全体を開始するための1つまたは複数の初期値を持つ数列のことです。例えば、"
"[フィボナッチ数列](https://en.wikipedia.org/wiki/Fibonacci_number) は、この式で"
"定義できます:"

#: src/decl-macros/macros-practical.md:16
msgid "\\\\\\[F\\_{n} = 0, 1, ..., F\\_{n-2} + F\\_{n-1}\\\\\\]"
msgstr "\\\\\\[F\\_{n} = 0, 1, ..., F\\_{n-2} + F\\_{n-1}\\\\\\]"

#: src/decl-macros/macros-practical.md:18
msgid ""
"Thus, the first two numbers in the sequence are 0 and 1, with the third being "
"\\\\( F\\_{0} + F\\_{1} = 0 + 1 = 1\\\\), the fourth \\\\( F\\_{1} + F\\_{2} = "
"1 + 1 = 2\\\\), and so on forever."
msgstr ""
"このように、数列の最初の2つは0と1で、3番目は \\\\( F\\_{0} + F\\_{1} = 0 + 1 = "
"1\\\\) 、4番目は \\\\( F\\_{1} + F\\_{2} = 1 + 1 = 2\\\\) というように永遠に続"
"きます。"

#: src/decl-macros/macros-practical.md:20
msgid ""
"Now, _because_ such a sequence can go on forever, that makes defining a "
"`fibonacci` function a little tricky, since you obviously don't want to try "
"returning a complete vector. What you _want_ is to return something which will "
"lazily compute elements of the sequence as needed."
msgstr ""
"さて、このような数列は永遠に続くこと _から_ 、フィボナッチ関数を定義するのは少"
"し厄介です。なぜなら、明らかにベクタ全体を返すことを試みたくないからです。数列"
"の要素を必要に応じて後から計算する何か、を _返したい_ はずです。"

#: src/decl-macros/macros-practical.md:23
msgid ""
"In Rust, that means producing an [`Iterator`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html). This is not especially _hard_, but there is a fair "
"amount of boilerplate involved: you need to define a custom type, work out "
"what state needs to be stored in it, then implement the [`Iterator`](https://"
"doc.rust-lang.org/std/iter/trait.Iterator.html) trait for it."
msgstr ""
"Rustでは、これは[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html)を生成することを意味します。これは特別 _難しい_ ことではありませんが、かな"
"りのボイラーテンプレートを要します: カスタム型を定義し、どのような状態を格納す"
"る必要があるのかを調べ、[`Iterator`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html) を実装する必要があります。"

#: src/decl-macros/macros-practical.md:26
msgid ""
"However, recurrence relations are simple enough that almost all of these "
"details can be abstracted out with a little `macro_rules!` macro-based code "
"generation."
msgstr ""
"しかし、漸化式は十分単純なため、 `macro_rules!` マクロベースのコード生成にて、"
"これら詳細をほとんどすべて抽象化できます。"

#: src/decl-macros/macros-practical.md:28
msgid "So, with all that having been said, let's get started."
msgstr "さて、以上のことを踏まえて、始めましょう。"

#: src/decl-macros/macros-practical.md:32
msgid "Construction"
msgstr "構築"

#: src/decl-macros/macros-practical.md:34
msgid ""
"Usually, when working on a new `macro_rules!` macro, the first thing I do is "
"decide what the invocation should look like. In this specific case, my first "
"attempt looked like this:"
msgstr ""
"通常、新しい `macro_rules!` マクロを作成するとき、最初に行うことは呼び出しの形"
"を決めることです。この場合、私の最初の試みは次のようなものでした:"

#: src/decl-macros/macros-practical.md:37
msgid ""
"```rust,ignore\n"
"let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"```rust,ignore\n"
"let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"

#: src/decl-macros/macros-practical.md:43
msgid ""
"From that, we can take a stab at how the `macro_rules!` macro should be "
"defined, even if we aren't sure of the actual expansion. This is useful "
"because if you can't figure out how to parse the input syntax, then _maybe_ "
"you need to change it."
msgstr ""
"ここから、実際の展開がよくわからなくても、`macro_rules!` マクロをどのように定義"
"すべきかがわかります。入力された構文を解析する方法がわからない場合は、構文を変"
"更する必要がある _かもしれない_ ため、これは有用です。"

#: src/decl-macros/macros-practical.md:53
msgid ""
"Assuming you aren't familiar with the syntax, allow me to elucidate. This is "
"defining a syntax extension, using the [`macro_rules!`](./macros-methodical."
"md) system, called `recurrence!`. This `macro_rules!` macro has a single "
"parsing rule. That rule says the input to the invocation must match:"
msgstr ""
"あなたが構文に詳しくないことを前提に、説明させてください。これは、"
"[`macro_rules!`](./macros-methodical.md)システムを使って、`recurrence!` という"
"構文拡張を定義しています。この `macro_rules!` マクロには構文解析ルールが 1 つあ"
"ります。そのルールは、呼び出しの入力が以下に一致しなければならないというもので"
"す:"

#: src/decl-macros/macros-practical.md:58
msgid "the literal token sequence `a` `[` `n` `]` `=`,"
msgstr "リテラルトークンのシーケンス `a` `[` `n` `]` `=` 、"

#: src/decl-macros/macros-practical.md:59
msgid ""
"a [repeating](./macros-methodical.md#repetitions) (the `$( ... )`) sequence, "
"using `,` as a separator, and one or more (`+`) repeats of:"
msgstr ""
"[反復](./macros-methodical.md#repetitions) (`$( ... )`) シーケンス、区切り文字"
"として `,` を使用し、1度以上 (`+`) 反復される:"

#: src/decl-macros/macros-practical.md:60
msgid ""
"a valid _expression_ captured into the [metavariable](./macros-methodical."
"md#metavariables) `inits` (`$inits:expr`)"
msgstr ""
"[メタ変数](./macros-methodical.md#metavariables) `inits` (`$inits:expr`) にキャ"
"プチャされた有効な _式_ 。"

#: src/decl-macros/macros-practical.md:61
msgid "the literal token sequence `,` `...` `,`,"
msgstr "リテラルトークンのシーケンス `,` `...` `,` 、"

#: src/decl-macros/macros-practical.md:62
msgid ""
"a valid _expression_ captured into the [metavariable](./macros-methodical."
"md#metavariables) `recur` (`$recur:expr`)."
msgstr ""
"[メタ変数](./macros-methodical.md#metavariables) `recur` (`$recur:expr`) にキャ"
"プチャされた有効な _式_ 。"

#: src/decl-macros/macros-practical.md:67
msgid ""
"Finally, the rule says that _if_ the input matches this rule, then the "
"invocation should be replaced by the token sequence `/* ... */`."
msgstr ""
"最後に、入力がこのルールにマッチする場合、その呼び出しはトークン列 `/* .... */"
"` に置き換えられると定義されています。"

#: src/decl-macros/macros-practical.md:69
msgid ""
"It's worth noting that `inits`, as implied by the name, actually contains "
"_all_ the expressions that match in this position, not just the first or last. "
"What's more, it captures them _as a sequence_ as opposed to, say, irreversibly "
"pasting them all together. Also note that you can do \"zero or more\" with a "
"repetition by using `*` instead of `+` and even optional, \"zero or one\" with "
"`?`."
msgstr ""
"注目すべき点として、`inits` は、この位置でマッチした式を最初や最後だけでなく、"
"その名前から想像されるように実際に _すべて_ 含めます。さらにそれらを、例えば不"
"可逆的にまとめて貼り付けるといった形ではなく、 _シーケンスとして_ キャプチャし"
"ます。また、`+`の代わりに`*`を使用することで、繰り返しを「0以上」にすることがで"
"きます。 `?` を使用すれば「0か1」となります。"

#: src/decl-macros/macros-practical.md:73
msgid ""
"As an exercise, let's take the proposed input and feed it through the rule, to "
"see how it is processed. The \"Position\" column will show which part of the "
"syntax pattern needs to be matched against next, denoted by a \"⌂\". Note that "
"in some cases, there might be more than one possible \"next\" element to match "
"against. \"Input\" will contain all of the tokens that have _not_ been "
"consumed yet. `inits` and `recur` will contain the contents of those bindings."
msgstr ""
"練習として、検討した入力にルールを適用して、それがどのように処理されるかを見て"
"みましょう。「Position」列は、構文パターンのどの部分と次にマッチする必要がある"
"かを「⌂」によって示します。場合によっては、マッチする「次」要素が複数あるかもし"
"れないことに注意してください。「Input」 には、まだ消費されて _いない_ すべての"
"トークンが含まれます。 `inits` と `recur` にはそれらのバインディングの内容が格"
"納されます。"

#: src/decl-macros/macros-practical.md:265
msgid ""
"The key take-away from this is that the macro system will _try_ to "
"incrementally match the tokens provided as input to the macro against the "
"provided rules. We'll come back to the \"try\" part."
msgstr ""
"ここから得られる重要な点は、マクロシステムが、マクロへの入力として提供された"
"トークンを、提供されたルールに対してインクリメンタルにマッチさせようと _試みる"
"_ ということです。「試みる」の部分については、また後で説明します。"

#: src/decl-macros/macros-practical.md:268
msgid ""
"Now, let's begin writing the final, fully expanded form. For this expansion, I "
"was looking for something like:"
msgstr ""
"では、最終的で完全な展開後の形を書き始めましょう。この展開のために、私は次のよ"
"うなものを探索しました:"

#: src/decl-macros/macros-practical.md:279
msgid ""
"This will be the actual iterator type. `mem` will be the memo buffer to hold "
"the last few values so the recurrence can be computed. `pos` is to keep track "
"of the value of `n`."
msgstr ""
"これが実際のイテレータ型になります。 `mem` はメモバッファで、再帰を計算できるよ"
"うに直近のいくつかの値を保持します。`pos` は `n` の値を保持します。"

#: src/decl-macros/macros-practical.md:283
msgid ""
"**Aside**: I've chosen `u64` as a \"sufficiently large\" type for the elements "
"of this sequence. Don't worry about how this will work out for _other_ "
"sequences; we'll come to it."
msgstr ""
"**余談**: 配列の要素には「十分に大きい」型として `u64` を選びました。これが他の"
"_配列でどう作用するかについては心配しないでください; 後で考えましょう。"

#: src/decl-macros/macros-practical.md:297
msgid ""
"We need a branch to yield the initial values of the sequence; nothing tricky."
msgstr "シーケンスの初期値を返す分岐が必要です; 難しいことはないですね。"

#: src/decl-macros/macros-practical.md:314
msgid ""
"This is a bit harder; we'll come back and look at _how_ exactly to define `a`. "
"Also, `TODO_shuffle_down_and_append` is another placeholder; I want something "
"that places `next_val` on the end of the array, shuffling the rest down by one "
"space, dropping the 0th element."
msgstr ""
"これは少し難しいです; `a`を _どのように_ 正確に定義するかについては、また後で説"
"明します。また、`TODO_shuffle_down_and_append` もプレースホルダです。"
"`next_val` を配列の末尾に配置し、残りの要素を1つ下にシャッフルして、0番目の要素"
"を削除するものが必要です。"

#: src/decl-macros/macros-practical.md:318
msgid ""
"```rust,ignore\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"

#: src/decl-macros/macros-practical.md:326
msgid ""
"Lastly, return an instance of our new structure, which can then be iterated "
"over. To summarize, the complete expansion is:"
msgstr ""
"最後に、イテレーション可能な新しい構造体のインスタンスを返します。要約すると、"
"完全な展開は次のようになります:"

#: src/decl-macros/macros-practical.md:329
msgid ""
"```rust,ignore\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem: [u64; 2],\n"
"        pos: usize,\n"
"    }\n"
"\n"
"    impl Iterator for Recurrence {\n"
"        type Item = u64;\n"
"\n"
"        fn next(&mut self) -> Option<u64> {\n"
"            if self.pos < 2 {\n"
"                let next_val = self.mem[self.pos];\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            } else {\n"
"                let a = /* something */;\n"
"                let n = self.pos;\n"
"                let next_val = (a[n-2] + a[n-1]);\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val.clone());\n"
"\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""
"```rust,ignore\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem: [u64; 2],\n"
"        pos: usize,\n"
"    }\n"
"\n"
"    impl Iterator for Recurrence {\n"
"        type Item = u64;\n"
"\n"
"        fn next(&mut self) -> Option<u64> {\n"
"            if self.pos < 2 {\n"
"                let next_val = self.mem[self.pos];\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            } else {\n"
"                let a = /* something */;\n"
"                let n = self.pos;\n"
"                let next_val = (a[n-2] + a[n-1]);\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val.clone());\n"
"\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"

#: src/decl-macros/macros-practical.md:363
msgid ""
"**Aside**: Yes, this _does_ mean we're defining a different `Recurrence` "
"struct and its implementation for each invocation. Most of this will optimise "
"away in the final binary."
msgstr ""
"**余談**: そうですね、これは呼び出しごとに異なる `Recurrence` 構造体とその実装"
"を _定義している_ ことを意味します。このほとんどは最終的なバイナリで最適化され"
"ます。"

#: src/decl-macros/macros-practical.md:366
msgid ""
"It's also useful to check your expansion as you're writing it. If you see "
"anything in the expansion that needs to vary with the invocation, but _isn't_ "
"in the actual accepted syntax of our macro, you should work out where to "
"introduce it. In this case, we've added `u64`, but that's not necessarily what "
"the user wants, nor is it in the macro syntax. So let's fix that."
msgstr ""
"書きながら展開をチェックするのも便利です。展開の中に、マクロの呼び出しによって"
"変化する必要があり、それでいてマクロの実際の構文には _ない_ ものがあれば、それ"
"をどこに導入すればよいかを検討する必要があります。この場合、`u64` を追加しまし"
"たが、これは必ずしもユーザーが望むものではありませんし、マクロ構文にもありませ"
"ん。ですから、それを修正しましょう。"

#: src/decl-macros/macros-practical.md:370
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"/*\n"
"let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"*/\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"/*\n"
"let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"*/\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/macros-practical.md:383
msgid "Here, I've added a new metavariable: `sty` which should be a type."
msgstr "ここでは、新しいメタ変数を追加しました: `sty` は型である必要があります。"

#: src/decl-macros/macros-practical.md:385
msgid ""
"**Aside**: if you're wondering, the bit after the colon in a metavariable can "
"be one of several kinds of syntax matchers. The most common ones are `item`, "
"`expr`, and `ty`. A complete explanation can be found in [Macros, A Methodical "
"Introduction; `macro_rules!` (Matchers)](./macros-methodical.md#metavariables)."
msgstr ""
"**余談**: 気になっているかも知れませんが、メタ変数のコロンの後のビットはいくつ"
"かの構文マッチャーのうちの1つになります。最も一般的なものは `item`、`expr`、"
"`ty` です。完全な説明は [Macros, A Methodical Introduction; `macro_rules!` "
"(Matchers)](./macros-methodical.md#metavariables) にあります。"

#: src/decl-macros/macros-practical.md:389
msgid ""
"There's one other thing to be aware of: in the interests of future-proofing "
"the language, the compiler restricts what tokens you're allowed to put _after_ "
"a matcher, depending on what kind it is. Typically, this comes up when trying "
"to match expressions or statements; those can _only_ be followed by one of "
"`=>`, `,`, and `;`."
msgstr ""
"もう1つ注意しなければならないことがあります: コンパイラは将来的な言語の安全性を"
"確保するために、マッチャーの後にどのようなトークンを置くことができるかを、"
"matcher の種類に応じて制限しています。一般的に、式や文にマッチさせようとすると"
"きに現れるものです; これらは `=>` と `,` および `;` のうち1つ _しか_ 後に置くこ"
"とができません。"

#: src/decl-macros/macros-practical.md:393
#, fuzzy
msgid ""
"A complete list can be found in [Macros, A Methodical Introduction; Minutiae; "
"Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md)."
msgstr ""
"完全なリストは[Macros, A Methodical Introduction; Minutiae; Metavariables and "
"Expansion Redux](./minutiae/metavar-and-expansion.md)にあります。"

#: src/decl-macros/macros-practical.md:395
msgid "Indexing and Shuffling"
msgstr "インデックスとシャッフル"

#: src/decl-macros/macros-practical.md:397
msgid ""
"I will skim a bit over this part, since it's effectively tangential to the "
"macro-related stuff. We want to make it so that the user can access previous "
"values in the sequence by indexing `a`; we want it to act as a sliding window "
"keeping the last few (in this case, 2) elements of the sequence."
msgstr ""
"この部分はマクロ関連から事実上逸れる話なので、かいつまんで説明します。私たちが"
"ここで行いたいのは、ユーザが `a` にインデックスすることで、シーケンスの前の値に"
"アクセスできるようにすることです。`a' をシーケンスの最後の数個（この場合は2個）"
"の要素を保持するスライディングウィンドウとして動作させたいのです。"

#: src/decl-macros/macros-practical.md:401
msgid "We can do this pretty easily with a wrapper type:"
msgstr "これはラッパー型を使えば簡単に行えます:"

#: src/decl-macros/macros-practical.md:425
msgid ""
"**Aside**: since lifetimes come up _a lot_ with people new to Rust, a quick "
"explanation: `'a` and `'b` are lifetime parameters that are used to track "
"where a reference (_i.e._ a borrowed pointer to some data) is valid. In this "
"case, `IndexOffset` borrows a reference to our iterator's data, so it needs to "
"keep track of how long it's allowed to hold that reference for, using `'a`."
msgstr ""
"**余談**: ライフタイムが _よく_ 出てくるので、Rust 初心者のために、簡単に説明し"
"ます: `'a` と `'b` はライフタイムパラメータです。これは参照 (つまり、あるデータ"
"への借用ポインタ) が有効な範囲を追跡するために使用します。例の場合、 "
"`IndexOffset` はイテレータのデータへの参照を借用しています。よって `'a` を使用"
"して、いつまでその参照を保持できるか追跡する必要があります。"

#: src/decl-macros/macros-practical.md:428
msgid ""
"`'b` is used because the `Index::index` function (which is how subscript "
"syntax is actually implemented) is _also_ parameterized on a lifetime, on "
"account of returning a borrowed reference. `'a` and `'b` are not necessarily "
"the same thing in all cases. The borrow checker will make sure that even "
"though we don't explicitly relate `'a` and `'b` to one another, we don't "
"accidentally violate memory safety."
msgstr ""
"`'b` が使用される理由は、`Index::index` 関数（添え字構文が実際の実装方法）も _"
"また_ 、借用された参照を返すために、ライフタイムにてパラメタ化されているからで"
"す。すべての状況にて `'a` と `'b` が同じものである必要はありません。借用チェッ"
"カーは、たとえ私たちが明示的に `'a` と `'b` を互いに関連付けていなくても、誤っ"
"てメモリ安全に違反しないようにしてくれます。"

#: src/decl-macros/macros-practical.md:432
msgid "This changes the definition of `a` to:"
msgstr "これは `a` の定義を次のように変更します:"

#: src/decl-macros/macros-practical.md:438
msgid ""
"The only remaining question is what to do about "
"`TODO_shuffle_down_and_append`. I wasn't able to find a method in the standard "
"library with exactly the semantics I wanted, but it isn't hard to do by hand."
msgstr ""
"唯一残っている問題は、`TODO_shuffle_down_and_append`についてどうするかというこ"
"とです。標準ライブラリには、私が望んでいるセマンティクスを正確に備えたメソッド"
"を見つけることはできませんでしたが、自作するのは難しくありません。"

#: src/decl-macros/macros-practical.md:452
msgid ""
"This swaps the new value into the end of the array, swapping the other "
"elements down one space."
msgstr ""
"これは、他の要素を1つ下のスペースに置き替え、新しい値を配列の末尾に入れます。"

#: src/decl-macros/macros-practical.md:454
msgid ""
"**Aside**: doing it this way means that this code will work for non-copyable "
"types, as well."
msgstr ""
"**余談**: このようにすることで、このコードはコピー不可能な型でも動作することに"
"なります。"

#: src/decl-macros/macros-practical.md:456
msgid "The working code thus far now looks like this:"
msgstr "これまでのコードは以下のようなものです:"

#: src/decl-macros/macros-practical.md:458
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"fn main() {\n"
"    /*\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"    */\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"\n"
"        struct Recurrence {\n"
"            mem: [u64; 2],\n"
"            pos: usize,\n"
"        }\n"
"\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; 2],\n"
"            offset: usize,\n"
"        }\n"
"\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(2);\n"
"\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < 2 {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset { slice: &self.mem, offset: n };\n"
"                        a[n-2] + a[n-1]\n"
"                    };\n"
"\n"
"                    {\n"
"                        use std::mem::swap;\n"
"\n"
"                        let mut swap_tmp = next_val;\n"
"                        for i in [1,0] {\n"
"                            swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                        }\n"
"                    }\n"
"\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Recurrence { mem: [0, 1], pos: 0 }\n"
"    };\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... "
"*/ };\n"
"}\n"
"\n"
"fn main() {\n"
"    /*\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"    */\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"\n"
"        struct Recurrence {\n"
"            mem: [u64; 2],\n"
"            pos: usize,\n"
"        }\n"
"\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; 2],\n"
"            offset: usize,\n"
"        }\n"
"\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(2);\n"
"\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < 2 {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset { slice: &self.mem, offset: n };\n"
"                        a[n-2] + a[n-1]\n"
"                    };\n"
"\n"
"                    {\n"
"                        use std::mem::swap;\n"
"\n"
"                        let mut swap_tmp = next_val;\n"
"                        for i in [1,0] {\n"
"                            swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                        }\n"
"                    }\n"
"\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Recurrence { mem: [0, 1], pos: 0 }\n"
"    };\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:536
msgid ""
"Note that I've changed the order of the declarations of `n` and `a`, as well "
"as wrapped them(along with the recurrence expression) in a block. The reason "
"for the first should be obvious(`n` needs to be defined first so I can use it "
"for `a`). The reason for the second is that the borrowed reference `&self.mem` "
"will prevent the swaps later on from happening (you cannot mutate something "
"that is aliased elsewhere). The block ensures that the `&self.mem` borrow "
"expires before then."
msgstr ""
"`n` と `a` の宣言の順番を変更し、(漸化式も含めて) ブロックでラップしていること"
"に注意してください。1つめの理由は明らかでしょう（`a`で使用するために`n`を最初に"
"定義する必要がある）。2つめの理由は、借用参照 `&self.mem` が、後のスワップを妨"
"害するためです（別の場所でエイリアスされているものを変更することはできませ"
"ん）。このブロックは、`&self.mem` の借用がそれまでに期限切れになるようにしま"
"す。"

#: src/decl-macros/macros-practical.md:540
msgid ""
"Incidentally, the only reason the code that does the `mem` swaps is in a block "
"is to narrow the scope in which `std::mem::swap` is available, for the sake of "
"being tidy."
msgstr ""
"ちなみに、`mem`スワップを行うコードがブロック内にある唯一の理由は、整頓のため、"
"`std::mem::swap` が利用できる範囲を狭めるためです。"

#: src/decl-macros/macros-practical.md:542
msgid "If we take this code and run it, we get:"
msgstr "このコードを実行すると、次のようになります:"

#: src/decl-macros/macros-practical.md:557
msgid ""
"Success! Now, let's copy & paste this into the macro expansion, and replace "
"the expanded code with an invocation. This gives us:"
msgstr ""
"成功です！では、これをマクロの展開にコピー＆ペーストし、また展開していたコード"
"を呼び出しに置き換えてみましょう。これで次のようになります:"

#: src/decl-macros/macros-practical.md:561
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => {\n"
"        {\n"
"            /*\n"
"                What follows here is *literally* the code from before,\n"
"                cut and pasted into a new position. No other changes\n"
"                have been made.\n"
"            */\n"
"\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [u64; 2],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [u64; 2],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = u64;\n"
"\n"
"                fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = u64;\n"
"\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < 2 {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..2).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => {\n"
"        {\n"
"            /*\n"
"                ここに続くのは、 *文字通り* 前のコードを\n"
"                切り貼りしたものです。それ以外の変更はありません。\n"
"            */\n"
"\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [u64; 2],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [u64; 2],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = u64;\n"
"\n"
"                fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = u64;\n"
"\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < 2 {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset:"
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..2).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:640
msgid ""
"Obviously, we aren't _using_ the metavariables yet, but we can change that "
"fairly easily. However, if we try to compile this, `rustc` aborts, telling us:"
msgstr ""
"見ての通り、まだメタ変数を使っていません（すぐにこの点は変更します）。しかしな"
"がら、これをコンパイルしようとすると、`rustc` は以下のように中断してしまいます:"

#: src/decl-macros/macros-practical.md:651
msgid ""
"Here, we've run into a limitation of the `macro_rules` system. The problem is "
"that second comma. When it sees it during expansion, `macro_rules` can't "
"decide if it's supposed to parse _another_ expression for `inits`, or `...`. "
"Sadly, it isn't quite clever enough to realise that `...` isn't a valid "
"expression, so it gives up. Theoretically, this _should_ work as desired, but "
"currently doesn't."
msgstr ""
"ここで、`macro_rules`システムの制限に遭遇しました。問題は2つ目のコンマです。 "
"`macro_rules` は展開中にこれを見たとき、 `inits` の式を解析するのか、それとも "
"`...` を解析するのか判断できません。悲しいことに、`...` が有効な式ではないこと"
"に気づくほど賢くないので、諦めてしまいます。理論的には、これは望んだとおりに動"
"作する _はず_ なのですが、現状ではそうなっていません。"

#: src/decl-macros/macros-practical.md:657
msgid ""
"**Aside**: I _did_ fib a little about how our rule would be interpreted by the "
"macro system. In general, it _should_ work as described, but doesn't in this "
"case. The `macro_rules` machinery, as it stands, has its foibles, and its "
"worthwhile remembering that on occasion, you'll need to contort a little to "
"get it to work."
msgstr ""
"**余談**: 私は、私たちのルールがマクロシステムによってどのように解釈されるかに"
"ついて、少し嘘をつきました。一般的には、説明したように動作する _はず_ ですが、"
"今回はそうではありません。 `macro_rules` の仕組みは、現状では欠点があり、時には"
"それを機能させるために少し歪める必要があることを覚えておく価値があります。"

#: src/decl-macros/macros-practical.md:661
msgid ""
"In this _particular_ case, there are two issues. First, the macro system "
"doesn't know what does and does not constitute the various grammar elements "
"(_e.g._ an expression); that's the parser's job. As such, it doesn't know that "
"`...` isn't an expression. Secondly, it has no way of trying to capture a "
"compound grammar element (like an expression) without 100% committing to that "
"capture."
msgstr ""
"この _特定の_ ケースでは、2 つの問題があります。第一にマクロシステムは、何かが"
"各種文法要素（式など）を構成するか否かを知りません。それはパーサの仕事です。そ"
"のため、`...` が式でないことを知りません。次に、(式のような)複合文法要素のキャ"
"プチャを試みるに際し、そのキャプチャに 100% コミットせずに行う方法がありませ"
"ん。"

#: src/decl-macros/macros-practical.md:666
msgid ""
"In other words, it can ask the parser to try and parse some input as an "
"expression, but the parser will respond to any problems by aborting. The only "
"way the macro system can currently deal with this is to just try to forbid "
"situations where this could be a problem."
msgstr ""
"別の言葉で言えば、ある入力を式として解析するようにパーサに要求できますが、パー"
"サはなにか問題があれば中断として対応します。現在のところ、マクロシステムがこれ"
"に対処できるようにする唯一の方法は、このような問題が発生する可能性のある状況を"
"禁止することです。"

#: src/decl-macros/macros-practical.md:669
msgid ""
"On the bright side, this is a state of affairs that exactly _no one_ is "
"enthusiastic about. The `macro` keyword has already been reserved for a more "
"rigorously-defined future [macro system](https://github.com/rust-lang/rust/"
"issues/39412). Until then, needs must."
msgstr ""
"明るい話をするなら、これはまさに _誰も_ 望んでいない状態であることです。 "
"`macro` キーワードが、より厳密に定義された将来の[マクロシステム](https://"
"github.com/rust-lang/rust/issues/39412)のため、すでに予約されています。それまで"
"の間は、必要があります。"

#: src/decl-macros/macros-practical.md:673
msgid ""
"Thankfully, the fix is relatively simple: we remove the comma from the syntax. "
"To keep things balanced, we'll remove _both_ commas around `...`:"
msgstr ""
"ありがたいことに、修正は比較的簡単です: 構文からカンマを取り除くのです。バラン"
"スを保つために、`...` を囲むカンマの両方を削除します:"

#: src/decl-macros/macros-practical.md:676
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) => {\n"
"//                                     ^~~ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];\n"
"//                                         ^~~ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) => {\n"
"//                                     ^~~ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];\n"
"//                                         ^~~ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:694
msgid ""
"Success! ... or so we thought. Turns out this is being rejected by the "
"compiler nowadays, while it was fine back when this was written. The reason "
"for this is that the compiler now recognizes the `...` as a token, and as we "
"know we may only use `=>`, `,` or `;` after an expression fragment. So "
"unfortunately we are now out of luck as our dreamed up syntax will not work "
"out this way, so let us just choose one that looks the most befitting that we "
"are allowed to use instead, I'd say replacing `,` with `;` works."
msgstr ""
"成功！かと思いきや・・・。これが書かれた当時は問題なかったのですが、最近はコン"
"パイラに拒否されていることがわかりました。その理由は、コンパイラが `...` をトー"
"クンとして認識するようになったことと、またご存知のように、式の断片の後には "
"`=>`, `,` または `;` しか使えまないことです。よって残念ながら私たちが夢見た構文"
"はこの方法ではうまくいきません。ですから、私たちが使うことが許されているものの"
"中で、最も適切と思われるものを選びましょう。 `,` を `;` に置き換えればうまくい"
"きそうです。"

#: src/decl-macros/macros-practical.md:699
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"//                                     ^~~~~~^ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"//                                        ^~~~~^ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"//                                     ^~~~~~^ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"//                                        ^~~~~^ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:717
msgid "Success! But for real this time."
msgstr "成功！今回は本当に。"

#: src/decl-macros/macros-practical.md:720
msgid "Substitution"
msgstr "代入"

#: src/decl-macros/macros-practical.md:722
msgid ""
"Substituting something you've captured in a macro is quite simple; you can "
"insert the contents of a metavariable `$sty:ty` by using `$sty`. So, let's go "
"through and fix the `u64`s:"
msgstr ""
"マクロにてキャプチャしたものを代入するのはとても簡単です。`$sty`を使ってメタ変"
"数 `$sty:ty`の内容を挿入できます。それでは、`u64` を修正しましょう:"

#: src/decl-macros/macros-practical.md:725
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; 2],\n"
"//                    ^~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; 2],\n"
"//                          ^~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"//                            ^~~~ changed\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"//                                                          ^~~~ changed\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"//                          ^~~~ changed\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"//                                           ^~~~ changed\n"
"                    /* ... */\n"
"#                     if self.pos < 2 {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let n = self.pos;\n"
"#                             let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"#                             (a[n-2] + a[n-1])\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..2).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; 2],\n"
"//                    ^~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; 2],\n"
"//                          ^~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"//                            ^~~~ changed\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"//                                                          ^~~~ changed\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"//                          ^~~~ changed\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"//                                           ^~~~ changed\n"
"                    /* ... */\n"
"#                     if self.pos < 2 {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let n = self.pos;\n"
"#                             let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"#                             (a[n-2] + a[n-1])\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..2).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:807
msgid ""
"Let's tackle a harder one: how to turn `inits` into both the array literal "
"`[0, 1]` _and_ the array type, `[$sty; 2]`. The first one we can do like so:"
msgstr ""
"より難しいものに挑戦してみましょう: `inits` を配列リテラル `[0, 1]` _と_ 配列の"
"型 `[$sty; 2]` の両方に変換する方法です。最初のものは次のようにします:"

#: src/decl-macros/macros-practical.md:810
msgid ""
"```rust,ignore\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"//                             ^~~~~~~~~~~ changed\n"
"```"
msgstr ""
"```rust,ignore\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"//                             ^~~~~~~~~~~ changed\n"
"```"

#: src/decl-macros/macros-practical.md:815
msgid ""
"This effectively does the opposite of the capture: repeat `inits` one or more "
"times, separating each with a comma. This expands to the expected sequence of "
"tokens: `0, 1`."
msgstr ""
"これは実質的にキャプチャの逆を行います。`inits` を1回以上繰り返し、これをカンマ"
"で区切ります。これは期待されるトークンの並びである `0, 1` に展開されます。"

#: src/decl-macros/macros-practical.md:818
msgid ""
"Somehow turning `inits` into a literal `2` is a little trickier. It turns out "
"that there's no direct way to do this, but we _can_ do it by using a second "
"`macro_rules!` macro. Let's take this one step at a time."
msgstr ""
"どうにかして `inits` をリテラルの `2` にするのは少し厄介です。これを行う直接的"
"な方法はありませんが、2つ目の `macro_rules!` マクロを使用することで _行えます"
"_ 。一歩ずつやってみましょう。"

#: src/decl-macros/macros-practical.md:830
msgid ""
"The obvious case is: given zero expressions, you would expect `count_exprs` to "
"expand to a literal `0`."
msgstr ""
"明らかなケースがあります。0個の式が与えられた場合、 `count_exprs` がリテラル "
"`0` に展開されることが期待されます。"

#: src/decl-macros/macros-practical.md:833
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"//  ^~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     assert_eq!(_0, 0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"//  ^~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     assert_eq!(_0, 0);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:844
msgid ""
"**Aside**: You may have noticed I used parentheses here instead of curly "
"braces for the expansion. `macro_rules` really doesn't care _what_ you use, so "
"long as it's one of the \"matcher\" pairs: `( )`, `{ }` or `[ ]`. In fact, you "
"can switch out the matchers on the macro itself(_i.e._ the matchers right "
"after the macro name), the matchers around the syntax rule, and the matchers "
"around the corresponding expansion."
msgstr ""
"**余談**: 波括弧の代わりに括弧を使っていることにお気づきでしょうか。 "
"`macro_rules` は、`( )`, `{ }`, `[ ]` という「括弧」のペアのどれかであれば、 _"
"何を_ 使っても気にしません。実際、マクロ自体の括弧(マクロ名の直後の括弧)、構文"
"規則の周りの括弧、展開の周りの括弧を変更できます。"

#: src/decl-macros/macros-practical.md:848
msgid ""
"You can also switch out the matchers used when you _invoke_ a macro, but in a "
"more limited fashion: a macro invoked as `{ ... }` or `( ... );` will _always_ "
"be parsed as an _item_ (_i.e._ like a `struct` or `fn` declaration). This is "
"important when using macros in a function body; it helps disambiguate between "
"\"parse like an expression\" and \"parse like a statement\"."
msgstr ""
"マクロを呼び出すときに使用する括弧を変更することもできますが、より限定的な形に"
"なります。`{ ... }` または `( ... );` として呼び出されたマクロは、 _常に_ _アイ"
"テム_ （即ち `struct` や `fn` 宣言など）として解析されます。これは、関数内でマ"
"クロを使用する場合に重要です。「式のようにパースする」と「文のようにパースす"
"る」の区別を明確にすることに役立ちます。"

#: src/decl-macros/macros-practical.md:851
msgid "What if you have _one_ expression? That should be a literal `1`."
msgstr "もし_1つ_ 式があったら？それはリテラルの `1` であるべきです。"

#: src/decl-macros/macros-practical.md:854
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"//  ^~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"//  ^~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:868
msgid "Two?"
msgstr "2つ？"

#: src/decl-macros/macros-practical.md:870
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (2);\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (2);\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:887
msgid ""
"We can \"simplify\" this a little by re-expressing the case of two expressions "
"recursively."
msgstr ""
"2つの式の場合を再帰的に記述することで、これを少し「単純化」することができます。"

#: src/decl-macros/macros-practical.md:889
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"//                           ^~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"//                           ^~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:906
msgid ""
"This is fine since Rust can fold `1 + 1` into a constant value. What if we "
"have three expressions?"
msgstr ""
"Rust は `1 + 1` を定数値に折りたたむことができるので、これは問題ありません。3つ"
"の式がある場合はどうでしょうか？"

#: src/decl-macros/macros-practical.md:909
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"    ($e0:expr, $e1:expr, $e2:expr) => (1 + count_exprs!($e1, $e2));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"    ($e0:expr, $e1:expr, $e2:expr) => (1 + count_exprs!($e1, $e2));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:929
msgid ""
"**Aside**: You might be wondering if we could reverse the order of these "
"rules. In this particular case, _yes_, but the macro system can sometimes be "
"picky about what it is and is not willing to recover from. If you ever find "
"yourself with a multi-rule macro that you _swear_ should work, but gives you "
"errors about unexpected tokens, try changing the order of the rules."
msgstr ""
"**余談**: これらのルールの順番を逆にできないかと思うかもしれません。この特定の"
"ケースでは _Yes_ です。しかし、マクロのシステムは時々、復元するか否かえり好みす"
"ることがあります。もし、複数のルールがあるマクロが確かに動作する _はず_ なの"
"に、予期せぬトークンに関するエラーが発生する場合があれば、ルールの順序を変更し"
"てみてください。"

#: src/decl-macros/macros-practical.md:933
msgid ""
"Hopefully, you can see the pattern here. We can always reduce the list of "
"expressions by matching one expression, followed by zero or more expressions, "
"expanding that into 1 + a count."
msgstr ""
"ここでパターンを見出せると素晴らしいですね。1つの式とその後に0個以上の式が続く"
"ものにマッチした場合は常に、それを1＋カウントに展開することで、式のリストを減ら"
"せます。"

#: src/decl-macros/macros-practical.md:936
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid "**"
msgstr "**"

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid "JFTE"
msgstr "JFTE"

#: src/decl-macros/macros-practical.md:955
msgid ""
"**: this is not the _only_, or even the _best_ way of counting things. You may "
"wish to peruse the [Counting](./building-blocks/counting.md) section later for "
"a more efficient way."
msgstr ""
"**: これが _唯一_ の、あるいは最良の数え方というわけではありません。より効率的"
"な方法については、後で[Counting](./building-blocks/counting.md)のセクションを熟"
"読してください。"

#: src/decl-macros/macros-practical.md:958
msgid ""
"With this, we can now modify `recurrence` to determine the necessary size of "
"`mem`."
msgstr "これで、 `recurrence` を修正し、必要な `mem` のサイズを決定できます。"

#: src/decl-macros/macros-practical.md:960
msgid ""
"```rust\n"
"// added:\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"//                          ^~~~~~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"//                                ^~~~~~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"//                                        ^~~~~~~~ changed\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"//                                ^~~~~~~~ changed\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"//                                       ^~~~~~~~ changed\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"/* ... */\n"
"#\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"#\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"// added:\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"//                          ^~~~~~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"//                                ^~~~~~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"//                                        ^~~~~~~~ changed\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"//                                ^~~~~~~~ changed\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"//                                       ^~~~~~~~ changed\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"/* ... */\n"
"#\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"#\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1051
msgid ""
"With that done, we can now substitute the last thing: the `recur` expression."
msgstr "これにより、最後の代入を処理できます。 式 `recur` です。"

#: src/decl-macros/macros-practical.md:1053
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr $(, $tail:expr)*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"# macro_rules! recurrence {\n"
"#     ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#             impl Iterator for Recurrence {\n"
"#               type Item = $sty;\n"
"/* ... */\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            $recur\n"
"//                          ^~~~~~ changed\n"
"                        };\n"
"                        {\n"
"                            use std::mem::swap;\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"/* ... */\n"
"#             }\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr $(, $tail:expr)*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"# macro_rules! recurrence {\n"
"#     ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#             impl Iterator for Recurrence {\n"
"#               type Item = $sty;\n"
"/* ... */\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            $recur\n"
"//                          ^~~~~~ changed\n"
"                        };\n"
"                        {\n"
"                            use std::mem::swap;\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"/* ... */\n"
"#             }\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1126
msgid "And, when we compile our finished `macro_rules!` macro..."
msgstr "そして、完成した `macro_rules!` マクロをコンパイルすると..."

#: src/decl-macros/macros-practical.md:1154
msgid ""
"... wait, what? That can't be right... let's check what the macro is expanding "
"to."
msgstr ""
"...ちょっと待って、えぇ？そんなはずはありません... マクロが何に展開されたかを確"
"認してみましょう。"

#: src/decl-macros/macros-practical.md:1161
msgid ""
"The `-Zunpretty=expanded` argument tells `rustc` to perform macro expansion, "
"then turn the resulting AST back into source code. The output (after cleaning "
"up some formatting) is shown below; in particular, note the place in the code "
"where `$recur` was substituted:"
msgstr ""
"引数の `-Zunpretty=expanded` は `rustc` にマクロ展開を実行させ、その結果の AST "
"をソースコードに戻させます。その出力（フォーマットを修正後のもの）は以下通りで"
"す。特に、`$recur` が代入された箇所に注意してください:"

#: src/decl-macros/macros-practical.md:1165
msgid ""
"```rust,ignore\n"
"#![feature(no_std)]\n"
"#![no_std]\n"
"#[prelude_import]\n"
"use std::prelude::v1::*;\n"
"#[macro_use]\n"
"extern crate std as std;\n"
"fn main() {\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"        const MEM_SIZE: usize = 1 + 1;\n"
"        struct Recurrence {\n"
"            mem: [u64; MEM_SIZE],\n"
"            pos: usize,\n"
"        }\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; MEM_SIZE],\n"
"            offset: usize,\n"
"        }\n"
"        impl <'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(MEM_SIZE);\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < MEM_SIZE {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset{slice: &self.mem, offset: n,};\n"
"                        a[n - 1] + a[n - 2]\n"
"                    };\n"
"                    {\n"
"                        use std::mem::swap;\n"
"                        let mut swap_tmp = next_val;\n"
"                        {\n"
"                            let result =\n"
"                                match ::std::iter::IntoIterator::into_iter((0.."
"MEM_SIZE).rev()) {\n"
"                                    mut iter => loop {\n"
"                                        match ::std::iter::Iterator::next(&mut "
"iter) {\n"
"                                            ::std::option::Option::Some(i) => "
"{\n"
"                                                swap(&mut swap_tmp, &mut self."
"mem[i]);\n"
"                                            }\n"
"                                            ::std::option::Option::None => "
"break,\n"
"                                        }\n"
"                                    },\n"
"                                };\n"
"                            result\n"
"                        }\n"
"                    }\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"        Recurrence{mem: [0, 1], pos: 0,}\n"
"    };\n"
"    {\n"
"        let result =\n"
"            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {\n"
"                mut iter => loop {\n"
"                    match ::std::iter::Iterator::next(&mut iter) {\n"
"                        ::std::option::Option::Some(e) => {\n"
"                            ::std::io::_print(::std::fmt::Arguments::new_v1(\n"
"                                {\n"
"                                    static __STATIC_FMTSTR: &'static [&'static "
"str] = &[\"\", \"\\n\"];\n"
"                                    __STATIC_FMTSTR\n"
"                                },\n"
"                                &match (&e,) {\n"
"                                    (__arg0,) => [::std::fmt::ArgumentV1::"
"new(__arg0, ::std::fmt::Display::fmt)],\n"
"                                }\n"
"                            ))\n"
"                        }\n"
"                        ::std::option::Option::None => break,\n"
"                    }\n"
"                },\n"
"            };\n"
"        result\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#![feature(no_std)]\n"
"#![no_std]\n"
"#[prelude_import]\n"
"use std::prelude::v1::*;\n"
"#[macro_use]\n"
"extern crate std as std;\n"
"fn main() {\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"        const MEM_SIZE: usize = 1 + 1;\n"
"        struct Recurrence {\n"
"            mem: [u64; MEM_SIZE],\n"
"            pos: usize,\n"
"        }\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; MEM_SIZE],\n"
"            offset: usize,\n"
"        }\n"
"        impl <'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(MEM_SIZE);\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < MEM_SIZE {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset{slice: &self.mem, offset: n,};\n"
"                        a[n - 1] + a[n - 2]\n"
"                    };\n"
"                    {\n"
"                        use std::mem::swap;\n"
"                        let mut swap_tmp = next_val;\n"
"                        {\n"
"                            let result =\n"
"                                match ::std::iter::IntoIterator::into_iter((0.."
"MEM_SIZE).rev()) {\n"
"                                    mut iter => loop {\n"
"                                        match ::std::iter::Iterator::next(&mut "
"iter) {\n"
"                                            ::std::option::Option::Some(i) => "
"{\n"
"                                                swap(&mut swap_tmp, &mut self."
"mem[i]);\n"
"                                            }\n"
"                                            ::std::option::Option::None => "
"break,\n"
"                                        }\n"
"                                    },\n"
"                                };\n"
"                            result\n"
"                        }\n"
"                    }\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"        Recurrence{mem: [0, 1], pos: 0,}\n"
"    };\n"
"    {\n"
"        let result =\n"
"            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {\n"
"                mut iter => loop {\n"
"                    match ::std::iter::Iterator::next(&mut iter) {\n"
"                        ::std::option::Option::Some(e) => {\n"
"                            ::std::io::_print(::std::fmt::Arguments::new_v1(\n"
"                                {\n"
"                                    static __STATIC_FMTSTR: &'static [&'static "
"str] = &[\"\", \"\\n\"];\n"
"                                    __STATIC_FMTSTR\n"
"                                },\n"
"                                &match (&e,) {\n"
"                                    (__arg0,) => [::std::fmt::ArgumentV1::"
"new(__arg0, ::std::fmt::Display::fmt)],\n"
"                                }\n"
"                            ))\n"
"                        }\n"
"                        ::std::option::Option::None => break,\n"
"                    }\n"
"                },\n"
"            };\n"
"        result\n"
"    }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:1260
msgid ""
"But that looks fine! If we add a few missing `#![feature(...)]` attributes and "
"feed it to a nightly build of `rustc`, it even compiles!  ... _what?!_"
msgstr ""
"ですが、これは問題なさそうです！いくつか欠けている `#![feature(...)]` アトリ"
"ビュートを追加して `rustc` のナイトリービルドに渡すと、コンパイルもできま"
"す！ ... _えっ！？_"

#: src/decl-macros/macros-practical.md:1263
msgid ""
"**Aside**: You can't compile the above with a non-nightly build of `rustc`. "
"This is because the expansion of the `println!` macro depends on internal "
"compiler details which are _not_ publicly stabilized."
msgstr ""
"**余談**: `rustc`のnightlyでないビルドでは上記をコンパイルできません。これは "
"`println!` マクロの展開がコンパイラ内部の、公式に安定して _いない_ 詳細に依存し"
"ているためです。。"

#: src/decl-macros/macros-practical.md:1266
msgid "Being Hygienic"
msgstr "ハイジーンであること"

#: src/decl-macros/macros-practical.md:1268
msgid ""
"The issue here is that identifiers in Rust syntax extensions are _hygienic_. "
"That is, identifiers from two different contexts _cannot_ collide. To show the "
"difference, let's take a simpler example."
msgstr ""
"ここで問題になるのは、Rustの構文拡張の識別子は _ハイジーン_ であるということで"
"す。つまり、2つの異なるコンテキストの識別子が衝突することはありません。この違い"
"を示すために、もっと簡単な例を見てみましょう。"

#: src/decl-macros/macros-practical.md:1286
msgid ""
"This macro simply takes an expression, then wraps it in a block with a "
"variable `a` defined. We then use this as a round-about way of computing `4`. "
"There are actually _two_ syntax contexts involved in this example, but they're "
"invisible. So, to help with this, let's give each context a different colour. "
"Let's start with the unexpanded code, where there is only a single context:"
msgstr ""
"このマクロは単に、式を受け取り、これを変数 `a` の定義とともにブロックで囲みま"
"す。そして、このマクロを `4` を計算する遠回りな方法として使用しています。この例"
"には実際には _2つ_ の構文コンテキストがありますが、それらは見た目にわかりませ"
"ん。そこで、参考のため、それぞれのコンテキスト毎に色をつけてみましょう。まず、"
"展開前のコードから始めましょう。ここではコンテキストは1つだけです:"

#: src/decl-macros/macros-practical.md:1294
msgid "Now, let's expand the invocation."
msgstr "では、呼び出しを展開してみましょう。"

#: src/decl-macros/macros-practical.md:1298
msgid ""
"As you can see, the `a` that's defined by the macro invocation is in a "
"different context to the `a` we provided in our invocation. As such, the "
"compiler treats them as completely different identifiers, _even though they "
"have the same lexical appearance_."
msgstr ""
"ご覧のように、 マクロ呼び出しによって定義された `a` は、呼び出しに提供した `a` "
"とは異なるコンテキストにあります。そのため、コンパイラはこれらを、 _文字列上は"
"同一の記述であるにも関わらず_ 、完全に異なる識別子として扱います。"

#: src/decl-macros/macros-practical.md:1301
msgid ""
"This is something to be _really_ careful of when working on `macro_rules!` "
"macros, syntax extensions in general even: they can produce ASTs which will "
"not compile, but which _will_ compile if written out by hand, or dumped using "
"`-Zunpretty=expanded`."
msgstr ""
"これは、`macro_rules!`マクロ、あるいは拡張構文全般を扱うときに _本当に_ 注意し"
"なければならないことです: これらが生成するASTはコンパイルできず、それでいてコー"
"ドをハンドコーディングしたり `-Zunpretty=expanded` にてダンプしたり _するとコン"
"パイルできてしまう_ 、ということがありえます。"

#: src/decl-macros/macros-practical.md:1304
msgid ""
"The solution to this is to capture the identifier _with the appropriate syntax "
"context_. To do that, we need to again adjust our macro syntax. To continue "
"with our simpler example:"
msgstr ""
"これを解決するには、識別子を適切な構文コンテキストでキャプチャします。そのため"
"には、マクロ構文を調整する必要があります。例にて続けてみましょう:"

#: src/decl-macros/macros-practical.md:1310
msgid "This now expands to:"
msgstr "次のように展開されるようになります:"

#: src/decl-macros/macros-practical.md:1314
msgid ""
"Now, the contexts match, and the code will compile. We can make this "
"adjustment to our `recurrence!` macro by explicitly capturing `a` and `n`. "
"After making the necessary changes, we have:"
msgstr ""
"これでコンテキストは一致し、コードはコンパイルされるようになります。私たちの "
"`recurrence!` マクロは、 `a` と `n` を明示的にキャプチャすることで、調整可能で"
"す。必要な変更を行うと、次のようになります:"

#: src/decl-macros/macros-practical.md:1318
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"//    ^~~~~~~~~~   ^~~~~~~~~~ changed\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let $ind = self.pos;\n"
"//                              ^~~~ changed\n"
"                            let $seq = IndexOffset { slice: &self.mem, offset: "
"$ind };\n"
"//                              ^~~~ changed\n"
"                            $recur\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"//    ^~~~~~~~~~   ^~~~~~~~~~ changed\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let $ind = self.pos;\n"
"//                              ^~~~ changed\n"
"                            let $seq = IndexOffset { slice: &self.mem, offset: "
"$ind };\n"
"//                              ^~~~ changed\n"
"                            $recur\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"

#: src/decl-macros/macros-practical.md:1404
msgid "And it compiles! Now, let's try with a different sequence."
msgstr "これでコンパイルされます！では、別のシーケンスを試してみましょう。"

#: src/decl-macros/macros-practical.md:1407
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr) => (1);\n"
"#     ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"#\n"
"# macro_rules! recurrence {\n"
"#     ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             impl Iterator for Recurrence {\n"
"#                 type Item = $sty;\n"
"#\n"
"#                 #[inline]\n"
"#                 fn next(&mut self) -> Option<$sty> {\n"
"#                     if self.pos < MEM_SIZE {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let $ind = self.pos;\n"
"#                             let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"#                             $recur\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..MEM_SIZE).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"#\n"
"# fn main() {\n"
"for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {\n"
"    println!(\"{}\", e)\n"
"}\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr) => (1);\n"
"#     ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"#\n"
"# macro_rules! recurrence {\n"
"#     ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:"
"expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             impl Iterator for Recurrence {\n"
"#                 type Item = $sty;\n"
"#\n"
"#                 #[inline]\n"
"#                 fn next(&mut self) -> Option<$sty> {\n"
"#                     if self.pos < MEM_SIZE {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let $ind = self.pos;\n"
"#                             let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"#                             $recur\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..MEM_SIZE).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"#\n"
"# fn main() {\n"
"for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {\n"
"    println!(\"{}\", e)\n"
"}\n"
"# }\n"
"```"

#: src/decl-macros/macros-practical.md:1490
msgid "Which gives us:"
msgstr "この結果は次の通りです:"

#: src/decl-macros/macros-practical.md:1505
msgid "Success!"
msgstr "成功です！"

#: src/decl-macros/minutiae.md:3
msgid ""
"This section goes through some of the finer details of the `macro_rules!` "
"system. At a minimum, you should try to be at least _aware_ of these details "
"and issues."
msgstr ""
"この章では `macro_rules!` システムのさらに詳細なことについて説明します。 少なく"
"とも、これらの詳細や問題点について認識だけでもしておくべきです。"

#: src/decl-macros/minutiae/fragment-specifiers.md:3
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md) "
"chapter, Rust, as of 1.60, has 14 fragment specifiers. This section will go a "
"bit more into detail for some of them and shows a few example inputs of what "
"each matcher matches."
msgstr ""
"[`方法論的イントロダクション`](../macros-methodical.md)の章で述べたように、"
"Rust 1.60には14個のフラグメント指定子があります。このセクションでは、そのうちの"
"いくつかについてもう少し詳しく説明し、各マッチャーがマッチする入力例をいくつか"
"示します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:6
msgid ""
"**Note**: Capturing with anything but the `ident`, `lifetime` and `tt` "
"fragments will render the captured AST opaque, making it impossible to further "
"match it with other fragment specifiers in future macro invocations."
msgstr ""
"**注意**: `ident`、`lifetime`、`tt`以外のフラグメントでキャプチャすると、キャプ"
"チャされた AST が不透明になり、以降のマクロを呼び出し時に他のフラグメント指定子"
"とマッチさせることができなくなります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:8
msgid "[`block`](#block)"
msgstr "[`block`](#block)"

#: src/decl-macros/minutiae/fragment-specifiers.md:9
msgid "[`expr`](#expr)"
msgstr "[`expr`](#expr)"

#: src/decl-macros/minutiae/fragment-specifiers.md:10
msgid "[`ident`](#ident)"
msgstr "[`ident`](#ident)"

#: src/decl-macros/minutiae/fragment-specifiers.md:11
msgid "[`item`](#item)"
msgstr "[`item`](#item)"

#: src/decl-macros/minutiae/fragment-specifiers.md:12
msgid "[`lifetime`](#lifetime)"
msgstr "[`lifetime`](#lifetime)"

#: src/decl-macros/minutiae/fragment-specifiers.md:13
msgid "[`literal`](#literal)"
msgstr "[`literal`](#literal)"

#: src/decl-macros/minutiae/fragment-specifiers.md:14
msgid "[`meta`](#meta)"
msgstr "[`meta`](#meta)"

#: src/decl-macros/minutiae/fragment-specifiers.md:15
msgid "[`pat`](#pat)"
msgstr "[`pat`](#pat)"

#: src/decl-macros/minutiae/fragment-specifiers.md:16
msgid "[`pat_param`](#pat_param)"
msgstr "[`pat_param`](#pat_param)"

#: src/decl-macros/minutiae/fragment-specifiers.md:17
msgid "[`path`](#path)"
msgstr "[`path`](#path)"

#: src/decl-macros/minutiae/fragment-specifiers.md:18
msgid "[`stmt`](#stmt)"
msgstr "[`stmt`](#stmt)"

#: src/decl-macros/minutiae/fragment-specifiers.md:19
msgid "[`tt`](#tt)"
msgstr "[`tt`](#tt)"

#: src/decl-macros/minutiae/fragment-specifiers.md:20
msgid "[`ty`](#ty)"
msgstr "[`ty`](#ty)"

#: src/decl-macros/minutiae/fragment-specifiers.md:21
msgid "[`vis`](#vis)"
msgstr "[`vis`](#vis)"

#: src/decl-macros/minutiae/fragment-specifiers.md:23
msgid "`block`"
msgstr "`block`"

#: src/decl-macros/minutiae/fragment-specifiers.md:25
msgid ""
"The `block` fragment solely matches a [block expression](https://doc.rust-lang."
"org/reference/expressions/block-expr.html), which consists of an opening `{` "
"brace, followed by any number of statements and finally followed by a closing "
"`}` brace."
msgstr ""
"`block` フラグメントは[ブロック式](https://doc.rust-lang.org/reference/"
"expressions/block-expr.html)にのみマッチします。ブロック式は開き括弧 `{` で始ま"
"り、任意の数のステートメントが続き、最後に閉じ括弧 `}` で終わります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:42
msgid "`expr`"
msgstr "`expr`"

#: src/decl-macros/minutiae/fragment-specifiers.md:44
msgid ""
"The `expr` fragment matches any kind of [expression](https://doc.rust-lang.org/"
"reference/expressions.html) (Rust has a lot of them, given it _is_ an "
"expression orientated language)."
msgstr ""
"`expr` フラグメントはあらゆる種類の[式](https://doc.rust-lang.org/reference/"
"expressions.html)（Rustは式指向言語であるため、多様な式を持ちます）にマッチしま"
"す。"

#: src/decl-macros/minutiae/fragment-specifiers.md:46
msgid ""
"```rust\n"
"macro_rules! expressions {\n"
"    ($($expr:expr)*) => ();\n"
"}\n"
"\n"
"expressions! {\n"
"    \"literal\"\n"
"    funcall()\n"
"    future.await\n"
"    break 'foo bar\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! expressions {\n"
"    ($($expr:expr)*) => ();\n"
"}\n"
"\n"
"expressions! {\n"
"    \"literal\"\n"
"    funcall()\n"
"    future.await\n"
"    break 'foo bar\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:60
msgid "`ident`"
msgstr "ident`"

#: src/decl-macros/minutiae/fragment-specifiers.md:62
msgid ""
"The `ident` fragment matches an [identifier](https://doc.rust-lang.org/"
"reference/identifiers.html) or _keyword_."
msgstr ""
"`ident` フラグメントは [識別子](https://doc.rust-lang.org/reference/"
"identifiers.html) または _キーワード_ にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:64
msgid ""
"```rust\n"
"macro_rules! idents {\n"
"    ($($ident:ident)*) => ();\n"
"}\n"
"\n"
"idents! {\n"
"    // _ <- This is not an ident, it is a pattern\n"
"    foo\n"
"    async\n"
"    O_________O\n"
"    _____O_____\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! idents {\n"
"    ($($ident:ident)*) => ();\n"
"}\n"
"\n"
"idents! {\n"
"    // _ <- This is not an ident, it is a pattern\n"
"    foo\n"
"    async\n"
"    O_________O\n"
"    _____O_____\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:79
msgid "`item`"
msgstr "`item`"

#: src/decl-macros/minutiae/fragment-specifiers.md:81
msgid ""
"The `item` fragment simply matches any of Rust's [item](https://doc.rust-lang."
"org/reference/items.html) _definitions_, not identifiers that refer to items. "
"This includes visibility modifiers."
msgstr ""
"`item` フラグメントは単に、Rustのあらゆる[アイテム](https://doc.rust-lang.org/"
"reference/items.html) _定義_ にマッチします。アイテムを参照する識別子にはマッチ"
"しません。これには可視性修飾子も含まれます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:101
msgid "`lifetime`"
msgstr "`lifetime`"

#: src/decl-macros/minutiae/fragment-specifiers.md:103
msgid ""
"The `lifetime` fragment matches a [lifetime or label](https://doc.rust-lang."
"org/reference/tokens.html#lifetimes-and-loop-labels). It's quite similar to "
"[`ident`](#ident) but with a prepended `'`."
msgstr ""
"`lifetime` フラグメントは[ライフタイムまたはラベル](https://doc.rust-lang.org/"
"reference/tokens.html#lifetimes-and-loop-labels)にマッチします。これは[`ident`]"
"(#ident)とよく似ていますが、先頭に `'` が付きます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:119
msgid "`literal`"
msgstr "`literal`"

#: src/decl-macros/minutiae/fragment-specifiers.md:121
msgid ""
"The `literal` fragment matches any [literal expression](https://doc.rust-lang."
"org/reference/expressions/literal-expr.html)."
msgstr ""
"`literal` フラグメントはあらゆる[リテラル式](https://doc.rust-lang.org/"
"reference/expressions/literal-expr.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:123
msgid ""
"```rust\n"
"macro_rules! literals {\n"
"    ($($literal:literal)*) => ();\n"
"}\n"
"\n"
"literals! {\n"
"    -1\n"
"    \"hello world\"\n"
"    2.3\n"
"    b'b'\n"
"    true\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! literals {\n"
"    ($($literal:literal)*) => ();\n"
"}\n"
"\n"
"literals! {\n"
"    -1\n"
"    \"hello world\"\n"
"    2.3\n"
"    b'b'\n"
"    true\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:138
msgid "`meta`"
msgstr "`meta`"

#: src/decl-macros/minutiae/fragment-specifiers.md:140
msgid ""
"The `meta` fragment matches the contents of an [attribute](https://doc.rust-"
"lang.org/reference/attributes.html). That is, it will match a simple path, one "
"without generic arguments followed by a delimited token tree or an `=` "
"followed by a literal expression."
msgstr ""
"`meta` フラグメントは [アトリビュート](https://doc.rust-lang.org/reference/"
"attributes.html) の内容にマッチします。つまり、単純なパス、すなわち、ジェネリッ"
"ク引数のないパスに続き、区切られたトークンツリーまたは `=` の後にリテラル式があ"
"るものにマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:143
msgid ""
"**Note**: You will usually see this fragment being used in a matcher like "
"`#[$meta:meta]` or `#![$meta:meta]` to actually capture an attribute."
msgstr ""
"**注意**: このフラグメントは通常、実際にアトリビュートをキャプチャするために "
"`#[$meta:meta]` や `#![$meta:meta]` のようなマッチャーで使用されます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:145
msgid ""
"```rust\n"
"macro_rules! metas {\n"
"    ($($meta:meta)*) => ();\n"
"}\n"
"\n"
"metas! {\n"
"    ASimplePath\n"
"    super::man\n"
"    path = \"home\"\n"
"    foo(bar)\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! metas {\n"
"    ($($meta:meta)*) => ();\n"
"}\n"
"\n"
"metas! {\n"
"    ASimplePath\n"
"    super::man\n"
"    path = \"home\"\n"
"    foo(bar)\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:159
msgid ""
"**Doc-Comment Fact**: Doc-Comments like `/// ...` and `//! ...` are actually "
"syntax sugar for attributes! They desugar to `#[doc=\"...\"]` and `#![doc=\"..."
"\"]` respectively, meaning you can match on them like with attributes!"
msgstr ""
"**docコメント の真実**: docコメント の `/// ...` や `//! ...` は実はアトリ"
"ビュートのためのシンタックスシュガーです！これらはそれぞれ `#[doc=\"...\"]` と "
"`#![doc=\"...\"]` に脱糖されるため、アトリビュートのようにマッチさせられます！"

#: src/decl-macros/minutiae/fragment-specifiers.md:161
msgid "`pat`"
msgstr "`pat`"

#: src/decl-macros/minutiae/fragment-specifiers.md:163
msgid ""
"The `pat` fragment matches any kind of [pattern](https://doc.rust-lang.org/"
"reference/patterns.html), including or-patterns starting with the 2021 edition."
msgstr ""
"`pat` フラグメントは、2021年版から始まるorパターンを含む、あらゆる種類の[パター"
"ン](https://doc.rust-lang.org/reference/patterns.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:165
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($($pat:pat)*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($($pat:pat)*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:180
msgid "`pat_param`"
msgstr "`pat_param`"

#: src/decl-macros/minutiae/fragment-specifiers.md:182
msgid ""
"In the 2021 edition, the behavior for the `pat` fragment type has been changed "
"to allow or-patterns to be parsed. This changes the follow list of the "
"fragment, preventing such fragment from being followed by a `|` token. To "
"avoid this problem or to get the old fragment behavior back one can use the "
"`pat_param` fragment which allows `|` to follow it, as it disallows top level "
"or-patterns."
msgstr ""
"2021年版では、`pat` フラグメント型の動作が変更され、orパターンをパースできるよ"
"うになりました。これにより、フラグメントの後ろに `|` トークンが続かないように、"
"フラグメントの後続リストが変更されます。この問題を回避する、または以前のフラグ"
"メントの挙動に戻すには、 `pat_param` フラグメントを使用します。これは `|` が後"
"続することを許容し、トップレベルのorパターンを拒否します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:186
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($( $( $pat:pat_param )|+ )*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($( $( $pat:pat_param )|+ )*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:201
msgid "`path`"
msgstr "`path`"

#: src/decl-macros/minutiae/fragment-specifiers.md:203
msgid ""
"The `path` fragment matches a so called [TypePath](https://doc.rust-lang.org/"
"reference/paths.html#paths-in-types) style path. This includes the function "
"style trait forms, `Fn() -> ()`."
msgstr ""
"`path` フラグメントはいわゆる[TypePath](https://doc.rust-lang.org/reference/"
"paths.html#paths-in-types)スタイルのパスにマッチします。これには関数スタイルの"
"トレイト形式である `Fn() -> ()` が含まれます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:220
msgid "`stmt`"
msgstr "`stmt`"

#: src/decl-macros/minutiae/fragment-specifiers.md:222
msgid ""
"The `statement` fragment solely matches a [statement](https://doc.rust-lang."
"org/reference/statements.html) without its trailing semicolon, unless it is an "
"item statement that requires one (such as a Unit-Struct)."
msgstr ""
"`statement` フラグメントは、[文](https://doc.rust-lang.org/reference/"
"statements.html)の最後のセミコロンを除いたものにのみマッチします。ただし、セミ"
"コロンを必要とするアイテム文(Unit-Structなど)は除きます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:224
msgid ""
"Let's use a simple example to show exactly what is meant with this. We use a "
"macro that merely emits what it captures:"
msgstr ""
"これが何を意味するのか、簡単な例で説明しましょう。単にキャプチャしたものを出力"
"するだけのマクロを使います:"

#: src/decl-macros/minutiae/fragment-specifiers.md:247
msgid ""
"Expanding this, via the [playground](https://play.rust-lang.org/) for "
"example[^debugging], gives us roughly the following:"
msgstr ""
"これを、例えば[playground](https://play.rust-lang.org/)を使って展開[^debugging]"
"すると、おおよそ次のようになります:"

#: src/decl-macros/minutiae/fragment-specifiers.md:266
msgid "From this we can tell a few things."
msgstr "ここからいくつかのことがわかります。"

#: src/decl-macros/minutiae/fragment-specifiers.md:268
msgid ""
"The first you should be able to see immediately is that while the `stmt` "
"fragment doesn't capture trailing semicolons, it still emits them when "
"required, even if the statement is already followed by one. The simple reason "
"for that is that semicolons on their own are already valid statements which "
"the fragment captures eagerly. So our macro isn't capturing 8 times, but 10! "
"This can be important when doing multiples repetitions and expanding these in "
"one repetition expansion, as the repetition numbers have to match in those "
"cases."
msgstr ""
"最初にすぐにわかることは、`stmt` フラグメントは末尾のセミコロンを捕捉しません"
"が、ステートメントにすでにセミコロンが続いていたとしても、必要なときにセミコロ"
"ンを出力することです。その単純な理由は、セミコロンはそれ自体がすでに有効なス"
"テートメントであり、フラグメントはそれを捕捉するからです。よって、マクロは8回で"
"はなく、10回キャプチャします！これは、複数の繰り返しを扱い、それらを1つの繰り返"
"しの展開の中で展開する場合に重要になりえます。この状況では繰り返し回数が一致し"
"なければならないためです。"

#: src/decl-macros/minutiae/fragment-specifiers.md:273
msgid ""
"Another thing you should be able to notice here is that the trailing semicolon "
"of the `struct Foo;` item statement is being matched, otherwise we would've "
"seen an extra one like in the other cases. This makes sense as we already "
"said, that for item statements that require one, the trailing semicolon will "
"be matched with."
msgstr ""
"ここでもうひとつ注目してほしいのは、`struct Foo;` というアイテム文の末尾のセミ"
"コロンがマッチしていることです。すでに述べたように、セミコロンが必要な項目文で"
"は、末尾のセミコロンがマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:276
msgid ""
"A last observation is that expressions get emitted back with a trailing "
"semicolon, unless the expression solely consists of only a block expression or "
"control flow expression."
msgstr ""
"最後の注目点は、式がブロック式や制御フロー式だけで構成されていない限り、式はセ"
"ミコロンを末尾に付けて返されるということです。"

#: src/decl-macros/minutiae/fragment-specifiers.md:278
msgid ""
"The fine details of what was just mentioned here can be looked up in the "
"[reference](https://doc.rust-lang.org/reference/statements.html)."
msgstr ""
"ここで述べたことの詳細は、[リファレンス](https://doc.rust-lang.org/reference/"
"statements.html)で調べることができます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:280
msgid ""
"Fortunately, these fine details here are usually not of importance whatsoever, "
"with the small exception that was mentioned earlier in regards to repetitions "
"which by itself shouldn't be a common problem to run into."
msgstr ""
"幸いなことに、このような詳細は通常全く重要ではありません。繰り返しに関して先に"
"述べた小さな例外がありますが、それ自体はよくある問題ではありません。"

#: src/decl-macros/minutiae/fragment-specifiers.md:282
msgid "See the [debugging chapter](./debugging.md) for tips on how to do this."
msgstr "やり方は、[デバッグの章](./debugging.md)を参照してください。"

#: src/decl-macros/minutiae/fragment-specifiers.md:284
msgid "`tt`"
msgstr "`tt`"

#: src/decl-macros/minutiae/fragment-specifiers.md:286
msgid ""
"The `tt` fragment matches a TokenTree. If you need a refresher on what exactly "
"a TokenTree was you may want to revisit the [TokenTree chapter](../../syntax-"
"extensions/source-analysis.md#token-trees) of this book. The `tt` fragment is "
"one of the most powerful fragments, as it can match nearly anything while "
"still allowing you to inspect the contents of it at a later state in the macro."
msgstr ""
"`tt` フラグメントはトークンツリーにマッチします。もしトークンツリーが何なのか再"
"確認したい場合は、この本の[トークンツリーの章](../../syntax-extensions/source-"
"analysis.md#token-trees)をもう一度読んでみてください。 `tt` フラグメントは最も"
"強力なフラグメントの1つで、ほぼすべてのものにマッチすることができ、マクロの後段"
"にてその内容を調査することもできます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:290
msgid ""
"This allows one to make use of very powerful patterns like the [tt-muncher](../"
"patterns/tt-muncher.md) or the [push-down-accumulator](../patterns/push-down-"
"acc.md)."
msgstr ""
"これにより、[tt消化器](../patterns/tt-muncher.md)や[プッシュダウンアキュムレー"
"ター](../patterns/push-down-acc.md)のような非常に強力なパターンを利用することが"
"できます。"

#: src/decl-macros/minutiae/fragment-specifiers.md:292
msgid "`ty`"
msgstr "`ty`"

#: src/decl-macros/minutiae/fragment-specifiers.md:294
msgid ""
"The `ty` fragment matches any kind of [type expression](https://doc.rust-lang."
"org/reference/types.html#type-expressions)."
msgstr ""
"`ty` フラグメントはあらゆる種類の[型式](https://doc.rust-lang.org/reference/"
"types.html#type-expressions)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:310
msgid "`vis`"
msgstr "`vis`"

#: src/decl-macros/minutiae/fragment-specifiers.md:312
msgid ""
"The `vis` fragment matches a _possibly empty_ [Visibility qualifier](https://"
"doc.rust-lang.org/reference/visibility-and-privacy.html)."
msgstr ""
"`vis`フラグメントは _空を含めた_ [可視性修飾子](https://doc.rust-lang.org/"
"reference/visibility-and-privacy.html)にマッチします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:314
msgid ""
"```rust\n"
"macro_rules! visibilities {\n"
"    //         ∨~~Note this comma, since we cannot repeat a `vis` fragment on "
"its own\n"
"    ($($vis:vis,)*) => ();\n"
"}\n"
"\n"
"visibilities! {\n"
"    , // no vis is fine, due to the implicit `?`\n"
"    pub,\n"
"    pub(crate),\n"
"    pub(in super),\n"
"    pub(in some_path),\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! visibilities {\n"
"    //         ∨~~カンマに注意。 `vis` フラグメントのみを繰り返すことは不可能で"
"す。\n"
"    ($($vis:vis,)*) => ();\n"
"}\n"
"\n"
"visibilities! {\n"
"    , // 暗黙の `?` によって、 vis なしはOK\n"
"    pub,\n"
"    pub(crate),\n"
"    pub(in super),\n"
"    pub(in some_path),\n"
"}\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:329
msgid ""
"While able to match empty sequences of tokens, the fragment specifier still "
"acts quite different from [optional repetitions](../macros-methodical."
"md#repetitions) which is described in the following:"
msgstr ""
"このフラグメント指定子は、空のトークンのシーケンスにマッチしますが、以下で説明"
"する[任意の反復](../macros-methodical.md#repetitions)とは全く異なる動作をしま"
"す:"

#: src/decl-macros/minutiae/fragment-specifiers.md:331
msgid ""
"If it is being matched against no left over tokens the entire macro matching "
"fails."
msgstr "もし残っているトークンがない場合、マクロのマッチ自体が失敗します。"

#: src/decl-macros/minutiae/fragment-specifiers.md:332
msgid ""
"```rust\n"
"macro_rules! non_optional_vis {\n"
"    ($vis:vis) => ();\n"
"}\n"
"non_optional_vis!();\n"
"// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! non_optional_vis {\n"
"    ($vis:vis) => ();\n"
"}\n"
"non_optional_vis!();\n"
"// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:340
msgid ""
"`$vis:vis $ident:ident` matches fine, unlike `$(pub)? $ident:ident` which is "
"ambiguous, as `pub` denotes a valid identifier."
msgstr ""
"`$vis:vis $ident:ident` はマッチします。対して `$(pub)? $ident:ident` は曖昧で"
"す。`pub` は有効な識別子を表すためです。"

#: src/decl-macros/minutiae/fragment-specifiers.md:341
msgid ""
"```rust\n"
"macro_rules! vis_ident {\n"
"    ($vis:vis $ident:ident) => ();\n"
"}\n"
"vis_ident!(pub foo); // this works fine\n"
"\n"
"macro_rules! pub_ident {\n"
"    ($(pub)? $ident:ident) => ();\n"
"}\n"
"pub_ident!(pub foo);\n"
"        // ^^^ error: local ambiguity when calling macro `pub_ident`: multiple "
"parsing options: built-in NTs ident ('ident') or 1 other option.\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! vis_ident {\n"
"    ($vis:vis $ident:ident) => ();\n"
"}\n"
"vis_ident!(pub foo); // これは動作します\n"
"\n"
"macro_rules! pub_ident {\n"
"    ($(pub)? $ident:ident) => ();\n"
"}\n"
"pub_ident!(pub foo);\n"
"        // ^^^ error: local ambiguity when calling macro `pub_ident`: multiple "
"parsing options: built-in NTs ident ('ident') or 1 other option.\n"
"```"

#: src/decl-macros/minutiae/fragment-specifiers.md:354
msgid ""
"Being a fragment that matches the empty token sequence also gives it a very "
"interesting quirk in combination with `tt` fragments and recursive expansions."
msgstr ""
"空のトークン列にマッチするフラグメントであることは、 `tt` フラグメントや再帰的"
"展開と組み合わせたとき、非常に興味深い奇妙な動作を引き起こします。"

#: src/decl-macros/minutiae/fragment-specifiers.md:356
msgid ""
"When matching the empty token sequence, the metavariable will still count as a "
"capture and since it is not a `tt`, `ident` or `lifetime` fragment it will "
"become opaque to further expansions. This means if this capture is passed onto "
"another macro invocation that captures it as a `tt` you effectively end up "
"with token tree that contains nothing!"
msgstr ""
"空のトークンシーケンスにマッチする場合、メタ変数はキャプチャに含まれつつ、これ"
"は `tt`、`ident`、`lifetime` フラグメントではないために、更なる展開には不透明に"
"なります。つまり、このキャプチャを `tt` としてキャプチャする別のマクロに渡す"
"と、何も含まないトークンツリーになってしまいます！"

#: src/decl-macros/minutiae/fragment-specifiers.md:359
msgid ""
"```rust\n"
"macro_rules! it_is_opaque {\n"
"    (()) => { \"()\" };\n"
"    (($tt:tt)) => { concat!(\"$tt is \", stringify!($tt)) };\n"
"    ($vis:vis ,) => { it_is_opaque!( ($vis) ); }\n"
"}\n"
"fn main() {\n"
"    // this prints \"$tt is \", as the recursive calls hits the second branch "
"with\n"
"    // an empty tt, opposed to matching with the first branch!\n"
"    println!(\"{}\", it_is_opaque!(,));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! it_is_opaque {\n"
"    (()) => { \"()\" };\n"
"    (($tt:tt)) => { concat!(\"$tt is \", stringify!($tt)) };\n"
"    ($vis:vis ,) => { it_is_opaque!( ($vis) ); }\n"
"}\n"
"fn main() {\n"
"    // これは \"$tt is \" を出力します。再帰呼び出しにて１つめのブランチにマッ"
"チせず、\n"
"    // ２つめのブランチに空の tt としてヒットするためです！\n"
"    println!(\"{}\", it_is_opaque!(,));\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:3
msgid ""
"Once the parser begins consuming tokens for a metavariable, _it cannot stop or "
"backtrack_. This means that the second rule of the following macro _cannot "
"ever match_, no matter what input is provided:"
msgstr ""
"いったんパーサがメタ変数のトークンを消費し始めると、 _中断したりバックトラック"
"することはできません_ 。これは、次のマクロの2番目のルールは、どのような入力が与"
"えられたとしても _決してマッチしない_ 、ということです:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:13
msgid ""
"Consider what happens if this macro is invoked as `dead_rule!(x+)`. The "
"interpreter will start at the first rule, and attempt to parse the input as an "
"expression. The first token `x` is valid as an expression. The second token is "
"_also_ valid in an expression, forming a binary addition node."
msgstr ""
"このマクロを `dead_rule!(x+)` として呼び出したらどうなるか考えてみましょう。イ"
"ンタープリタは最初のルールから開始し、入力を式として解析しようとします。最初の"
"トークン `x` は式として有効です。2番目のトークンも式の中にて有効であり、2項加算"
"のノードを構成します。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:18
msgid ""
"At this point, given that there is no right-hand side of the addition, you "
"might expect the parser to give up and try the next rule. Instead, the parser "
"will panic and abort the entire compilation, citing a syntax error."
msgstr ""
"さてここで、加算の右辺がないことを考えると、パーサはあきらめて次のルールを試す"
"と期待しているかもしれません。しかしそうではなく、パーサはパニックを起こし、コ"
"ンパイル全体を中断し、構文エラーを提示します。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:21
msgid ""
"As such, it is important in general that you write macro rules from most-"
"specific to least-specific."
msgstr ""
"そのため、一般的には、最も特殊なものから特殊でないものへと順にマクロルールを記"
"述することが重要です。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:23
msgid ""
"To defend against future syntax changes altering the interpretation of macro "
"input, `macro_rules!` restricts what can follow various metavariables. The "
"complete list, showing what may follow what fragment specifier, as of Rust "
"1.46 is as follows:"
msgstr ""
"将来的な構文の変更によってマクロの入力の解釈が変わってしまうのを防ぐために、 "
"`macro_rules!` はいくつかのメタ変数について後続可能なものを制限しています。"
"Rust 1.46時点での、どのフラグメント指定子に何が後続可能かについて、完全なリスト"
"は以下の通りです:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:27
msgid ""
"[`stmt`](./fragment-specifiers.md#stmt) and [`expr`](./fragment-specifiers."
"md#expr): `=>`, `,`, or `;`"
msgstr ""
"[`stmt`](./fragment-specifiers.md#stmt) と [`expr`](./fragment-specifiers."
"md#expr): `=>` 、 `,`または`;`"

#: src/decl-macros/minutiae/metavar-and-expansion.md:28
msgid ""
"[`pat`](./fragment-specifiers.md#pat): `=>`, `,`, `=`, `if`, `in`[^pat-edition]"
msgstr ""
"[`pat`](./fragment-specifiers.md#pat): `=>`、 `,`、 `=`、 `if`、 `in`[^pat-"
"edition]."

#: src/decl-macros/minutiae/metavar-and-expansion.md:29
msgid ""
"[`pat_param`](./fragment-specifiers.md#pat_param): `=>`, `,`, `=`, `|`, `if`, "
"`in`"
msgstr ""
"[`pat_param`](./fragment-specifiers.md#pat_param): `=>`、 `,`、 `=`、 `|`、 "
"`if`、 `in`"

#: src/decl-macros/minutiae/metavar-and-expansion.md:30
msgid ""
"[`path`](./fragment-specifiers.md#path) and [`ty`](./fragment-specifiers."
"md#ty):`=>`, `,`, `=`, `|`, `;`, `:`, `>`, `>>`, `[`, `{`, `as`, `where`, or a "
"macro variable of the [`block`](./fragment-specifiers.md#block) fragment "
"specifier."
msgstr ""
"[`path`](./fragment-specifiers.md#path) と [`ty`](./fragment-specifiers.md#ty):"
"`=>`、 `,`、 `=`、 `|`、 `;`、 `:`、 `>`、 `>>`、 `[`、 `{`、 `as`、 `where`、"
"または [`block`](./fragment-specifiers.md#block) フラグメント指定子のマクロ変"
"数。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:32
msgid ""
"[`vis`](./fragment-specifiers.md#vis): `,`, an identifier other than a non-raw "
"`priv`, any token that can begin a type or a metavariable with an [`ident`](./"
"fragment-specifiers.md#ident), [`ty`](./fragment-specifiers.md#ty), or [`path`]"
"(./fragment-specifiers.md#path) fragment specifier."
msgstr ""
"[`vis`](./fragment-specifiers.md#vis): `,`、生でない `priv` 以外の識別子、"
"[`ident`](./fragment-specifiers.md#ident) か [`ty`](./fragment-specifiers."
"md#ty) または [`path`](./fragment-specifiers.md#path) フラグメント指定子で型ま"
"たはメタ変数を開始できるトークン。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:34
msgid "All other fragment specifiers have no restrictions."
msgstr "その他のフラグメント指定子には制限がありません。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:36
msgid ""
"**Edition Differences**: Before the 2021 edition, `pat` may also be followed "
"by `|`."
msgstr ""
"**エディションの差異**: 2021年版以前では、`pat` の後に `|` が続くこともありま"
"す。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:38
msgid ""
"Repetitions also adhere to these restrictions, meaning if a repetition can "
"repeat multiple times(`*` or `+`), then the contents must be able to follow "
"themselves. If a repetition can repeat zero times (`?` or `*`) then what comes "
"after the repetition must be able to follow what comes before."
msgstr ""
"繰り返しもまた、それらの制約を遵守します。つまり、もしある繰り返しが複数回(`*`"
"または `+`)繰り返されるのであれば、その内容はそれ自体が後続可能である必要があり"
"ます。繰り返しが0回(`?`または`*`)繰り返されるのであれば、繰り返しの次に来るもの"
"は繰り返しの前のものに後続可能である必要があります。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:41
msgid ""
"The parser also does not perform any kind of lookahead. That means if the "
"compiler cannot unambiguously determine how to parse the macro invocation one "
"token at a time, it will abort with an ambiguity error. A simple example that "
"triggers this:"
msgstr ""
"また、パーサーはあらゆる種類の先読みを行いません。つまりコンパイラが、マクロ呼"
"び出しを1 トークンずつパースする方法を明確に決定できない場合、曖昧であるという"
"エラーにより中断します。これを引き起こす簡単な例を示します:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:45
msgid ""
"```rust\n"
"macro_rules! ambiguity {\n"
"    ($($i:ident)* $i2:ident) => { };\n"
"}\n"
"\n"
"// error:\n"
"//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or "
"ident ('i2').\n"
"ambiguity!(an_identifier);\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! ambiguity {\n"
"    ($($i:ident)* $i2:ident) => { };\n"
"}\n"
"\n"
"// error:\n"
"//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or "
"ident ('i2').\n"
"ambiguity!(an_identifier);\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:55
msgid ""
"The parser does not look ahead past the identifier to see if the following "
"token is a `)`, which would allow it to parse properly."
msgstr ""
"パーサーは、正しくパース可能にするために、識別子を越えて次のトークンが `)` であ"
"るかどうかを調べません。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:57
msgid ""
"One aspect of substitution that often surprises people is that substitution is "
"_not_ token-based, despite very much _looking_ like it."
msgstr ""
"代入についての、しばしば人々を驚かせる1つの側面は、代入がいかにもトークンベース"
"であるように _見える_ にもかかわらず、 _そうでない_ ということです。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:59
msgid "Consider the following:"
msgstr "以下を考えてみましょう:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:61
msgid ""
"```rust\n"
"macro_rules! capture_then_match_tokens {\n"
"    ($e:expr) => {match_tokens!($e)};\n"
"}\n"
"\n"
"macro_rules! match_tokens {\n"
"    ($a:tt + $b:tt) => {\"got an addition\"};\n"
"    (($i:ident)) => {\"got an identifier\"};\n"
"    ($($other:tt)*) => {\"got something else\"};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\\n{}\\n{}\\n\",\n"
"        match_tokens!((caravan)),\n"
"        match_tokens!(3 + 6),\n"
"        match_tokens!(5));\n"
"    println!(\"{}\\n{}\\n{}\",\n"
"        capture_then_match_tokens!((caravan)),\n"
"        capture_then_match_tokens!(3 + 6),\n"
"        capture_then_match_tokens!(5));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! capture_then_match_tokens {\n"
"    ($e:expr) => {match_tokens!($e)};\n"
"}\n"
"\n"
"macro_rules! match_tokens {\n"
"    ($a:tt + $b:tt) => {\"got an addition\"};\n"
"    (($i:ident)) => {\"got an identifier\"};\n"
"    ($($other:tt)*) => {\"got something else\"};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\\n{}\\n{}\\n\",\n"
"        match_tokens!((caravan)),\n"
"        match_tokens!(3 + 6),\n"
"        match_tokens!(5));\n"
"    println!(\"{}\\n{}\\n{}\",\n"
"        capture_then_match_tokens!((caravan)),\n"
"        capture_then_match_tokens!(3 + 6),\n"
"        capture_then_match_tokens!(5));\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:84
#: src/decl-macros/minutiae/metavar-and-expansion.md:123
#: src/decl-macros/minutiae/debugging.md:26
msgid "The output is:"
msgstr "この出力は:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:96
msgid ""
"By parsing the input into an AST node, the substituted result becomes _un-"
"destructible_; _i.e._ you cannot examine the contents or match against it ever "
"again."
msgstr ""
"入力をASTノードにパースすることによって、代入された結果は _破壊不可能_ になりま"
"す。 すなわち、二度とその内容を調べたり、マッチさせたりすることができません。"

#: src/decl-macros/minutiae/metavar-and-expansion.md:99
msgid "Here is _another_ example which can be particularly confusing:"
msgstr "_もう一つ_ 特に混乱しやすい例を挙げましょう:"

#: src/decl-macros/minutiae/metavar-and-expansion.md:101
msgid ""
"```rust\n"
"macro_rules! capture_then_what_is {\n"
"    (#[$m:meta]) => {what_is!(#[$m])};\n"
"}\n"
"\n"
"macro_rules! what_is {\n"
"    (#[no_mangle]) => {\"no_mangle attribute\"};\n"
"    (#[inline]) => {\"inline attribute\"};\n"
"    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), "
"\")\")};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\n"
"        \"{}\\n{}\\n{}\\n{}\",\n"
"        what_is!(#[no_mangle]),\n"
"        what_is!(#[inline]),\n"
"        capture_then_what_is!(#[no_mangle]),\n"
"        capture_then_what_is!(#[inline]),\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! capture_then_what_is {\n"
"    (#[$m:meta]) => {what_is!(#[$m])};\n"
"}\n"
"\n"
"macro_rules! what_is {\n"
"    (#[no_mangle]) => {\"no_mangle attribute\"};\n"
"    (#[inline]) => {\"inline attribute\"};\n"
"    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), "
"\")\")};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\n"
"        \"{}\\n{}\\n{}\\n{}\",\n"
"        what_is!(#[no_mangle]),\n"
"        what_is!(#[inline]),\n"
"        capture_then_what_is!(#[no_mangle]),\n"
"        capture_then_what_is!(#[inline]),\n"
"    );\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-and-expansion.md:132
msgid ""
"The only way to avoid this is to capture using the [`tt`](./fragment-"
"specifiers.md#tt), [`ident`](./fragment-specifiers.md#ident) or [`lifetime`](./"
"fragment-specifiers.md#lifetime) kinds. Once you capture with anything else, "
"the only thing you can do with the result from then on is substitute it "
"directly into the output."
msgstr ""
"これを避ける唯一の方法は、[`tt`](./fragment-specifiers.md#tt)、[`ident`](./"
"fragment-specifiers.md#ident)、[`lifetime`](./fragment-specifiers.md#lifetime)"
"のいずれかの種類を使ってキャプチャすることです。これら以外としてキャプチャした"
"ならば、以降可能なことは、その結果を直接出力に代入することのみです。"

#: src/decl-macros/minutiae/metavar-expr.md:7
msgid ""
"Note: The example code snippets are very bare bones, trying to show off how "
"they work. If you think you got small snippets with proper isolated usage of "
"these expression please submit them!"
msgstr ""
"注意: 例示のコードスニペットは、どのように動作するかを示すための、ごく簡素なも"
"のです。もし、これらの式の適切で分離された使用法の小さなスニペットが思いついた"
"ら、それを提供してください！"

#: src/decl-macros/minutiae/metavar-expr.md:9
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md), Rust "
"has special expressions that can be used by macro transcribers to obtain "
"information about metavariables that are otherwise difficult or even "
"impossible to get. This chapter will introduce them more in-depth together "
"with usage examples."
msgstr ""
"[方法論的イントロダクション](../macros-methodical.md) で述べたように、マクロの"
"トランスクライバーが、他の方法では取得が困難か不可能な、メタ変数に関する情報を"
"取得するために使用可能な、特別な式がRustにはあります。この章では、使用例ととも"
"に、それらをより詳しく紹介します。"

#: src/decl-macros/minutiae/metavar-expr.md:12
msgid "[`$$`](#dollar-dollar-)"
msgstr "[`$$`](#dollar-dollar-)"

#: src/decl-macros/minutiae/metavar-expr.md:13
msgid "[`${count(ident, depth)}`](#countident-depth)"
msgstr "[`${count(ident, depth)}`](#countident-depth)"

#: src/decl-macros/minutiae/metavar-expr.md:14
msgid "[`${index(depth)}`](#indexdepth)"
msgstr "[`${index(depth)}`](#indexdepth)"

#: src/decl-macros/minutiae/metavar-expr.md:15
msgid "[`${length(depth)}`](#lengthdepth)"
msgstr "[`${length(depth)}`](#lengthdepth)"

#: src/decl-macros/minutiae/metavar-expr.md:16
msgid "[`${ignore(ident)}`](#ignoreident)"
msgstr "[`${ignore(ident)}`](#ignoreident)"

#: src/decl-macros/minutiae/metavar-expr.md:18
msgid "Dollar Dollar (`$$`)"
msgstr "ドル記号 ドル記号 (`$$`)"

#: src/decl-macros/minutiae/metavar-expr.md:20
msgid ""
"The `$$` expression expands to a single `$`, making it effectively an escaped "
"`$`. This enables the ability in writing macros emitting new macros as the "
"former macro won't transcribe metavariables, repetitions and metavariable "
"expressions that have an escaped `$`."
msgstr ""
"式 `$$` は1つの `$` に展開されます。実質的にエスケープされた `$` になります。こ"
"れは、別のマクロを生成するマクロを書く際に有用です。生成する側のマクロは `$` を"
"エスケープしたメタ変数や繰り返し、メタ変数式を展開しないためです。"

#: src/decl-macros/minutiae/metavar-expr.md:23
msgid "We can see the problem without using `$$` in the following snippet:"
msgstr "以下のスニペットは、`$$`を使用しないときに発生する問題を示しています:"

#: src/decl-macros/minutiae/metavar-expr.md:24
msgid ""
"```rust\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro_rules! bar {\n"
"            ( $( $any:tt )* ) => { $( $any )* };\n"
"            // ^^^^^^^^^^^ error: attempted to repeat an expression containing "
"no syntax variables matched as repeating at this depth\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!();\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro_rules! bar {\n"
"            ( $( $any:tt )* ) => { $( $any )* };\n"
"            // ^^^^^^^^^^^ error: attempted to repeat an expression containing "
"no syntax variables matched as repeating at this depth\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!();\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:38
msgid ""
"The problem is obvious, the transcriber of foo sees a repetition and tries to "
"repeat it when transcribing, but there is no `$any` metavariable in its scope "
"causing it to fail. With `$$` we can get around this as the transcriber of "
"`foo` will no longer try to do the repetition.[^tt-$]"
msgstr ""
"この問題は明らかです。fooの展開部は繰り返しを発見し、展開時に繰り返しを行おうと"
"します。しかし、そのスコープに `$any` メタ変数がないため失敗します。`$$` によ"
"り、 `foo` が繰り返しを展開しないようにすることで、これを回避できます。"

#: src/decl-macros/minutiae/metavar-expr.md:57
msgid ""
"Before `$$` occurs, users must resort to a tricky and not so well-known hack "
"to declare nested macros with repetitions [via using `$tt` like this](https://"
"play.rust-lang.org/?"
"version=nightly&mode=debug&edition=2021&gist=9ce18fc79ce17c77d20e74f3c46ee13c)."
msgstr ""
"`$$` の存在以前は、ネストされ、また繰り返しを含むマクロを宣言するのに、[このよ"
"うに `$tt` を使用する](https://play.rust-lang.org/?"
"version=nightly&mode=debug&edition=2021&gist=9ce18fc79ce17c77d20e74f3c46ee13c) "
"トリッキーであまり知られていないハックに頼らざるを得ません。"

#: src/decl-macros/minutiae/metavar-expr.md:60
msgid "`count(ident, depth)`"
msgstr "`count(ident, depth)`"

#: src/decl-macros/minutiae/metavar-expr.md:62
msgid ""
"The `count` metavariable expression expands to the repetition count of the "
"metavariable `$ident` up to the given repetition depth."
msgstr ""
"メタ変数式 `count` は、与えられた繰り返しの深さまでの、メタ変数 `$ident` の繰り"
"返し回数に展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:64
#: src/decl-macros/minutiae/metavar-expr.md:167
msgid ""
"The `ident` argument must be a declared metavariable in the scope of the rule."
msgstr ""
"引数 `ident` はルールのスコープ内で宣言されたメタ変数でなければなりません。"

#: src/decl-macros/minutiae/metavar-expr.md:65
msgid ""
"The `depth` argument must be an integer literal of value less or equal to the "
"maximum repetition depth that the `$ident` metavariable appears in."
msgstr ""
"引数 `depth` は、メタ変数 `$ident` が現れる繰り返しの、深さの最大以下の整数リテ"
"ラルでなければなりません。"

#: src/decl-macros/minutiae/metavar-expr.md:66
#: src/decl-macros/minutiae/metavar-expr.md:96
#: src/decl-macros/minutiae/metavar-expr.md:132
msgid "The expression expands to an unsuffixed integer literal token."
msgstr "式は接尾子のない整数リテラルトークンに展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:68
msgid ""
"The `count(ident)` expression defaults `depth` to the maximum valid depth, "
"making it count the total repetitions for the given metavariable."
msgstr ""
"式 `count(ident)` は、 `depth` に有効な最大の深さが指定されたものとして、指定さ"
"れたメタ変数の繰り返し回数をカウントします。"

#: src/decl-macros/minutiae/metavar-expr.md:70
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! foo {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        println!(\"count(outer, 0): $outer repeats {} times\", "
"${count(outer)});\n"
"        println!(\"count(inner, 0): The $inner repetition repeats {} times in "
"the outer repetition\", ${count(inner, 0)});\n"
"        println!(\"count(inner, 1): $inner repeats {} times in the inner "
"repetitions\", ${count(inner, 1)});\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    foo! {\n"
"        outer () ;\n"
"        outer ( inner , inner ) ;\n"
"        outer () ;\n"
"        outer ( inner ) ;\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! foo {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        println!(\"count(outer, 0): $outer repeats {} times\", "
"${count(outer)});\n"
"        println!(\"count(inner, 0): The $inner repetition repeats {} times in "
"the outer repetition\", ${count(inner, 0)});\n"
"        println!(\"count(inner, 1): $inner repeats {} times in the inner "
"repetitions\", ${count(inner, 1)});\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    foo! {\n"
"        outer () ;\n"
"        outer ( inner , inner ) ;\n"
"        outer () ;\n"
"        outer ( inner ) ;\n"
"    };\n"
"    // 出力：\n"
"    // count(outer, 0): $outer repeats 4 times\n"
"    // count(inner, 0): The $inner repetition repeats 4 times in the outer "
"repetition\n"
"    // count(inner, 1): $inner repeats 3 times in the inner repetitions\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:91
msgid "`index(depth)`"
msgstr "`index(depth)`"

#: src/decl-macros/minutiae/metavar-expr.md:93
msgid ""
"The `index(depth)` metavariable expression expands to the current iteration "
"index of the repetition at the given depth."
msgstr ""
"メタ変数式 `index(depth)` は、与えられた深さの繰り返しでの、現在の繰り返しのイ"
"ンデックスに展開されます。"

#: src/decl-macros/minutiae/metavar-expr.md:95
#: src/decl-macros/minutiae/metavar-expr.md:131
msgid ""
"The `depth` argument targets the repetition at `depth` counting outwards from "
"the inner-most repetition where the expression is invoked."
msgstr ""
"引数 `depth` は、その式が呼び出される一番内側の繰り返しから外側へ数えて、 "
"`depth` 番目の繰り返しを対象とします。"

#: src/decl-macros/minutiae/metavar-expr.md:98
msgid ""
"The `index()` expression defaults `depth` to `0`, making it a shorthand for "
"`index(0)`."
msgstr "式 `index()` は `depth` を `0` とします。 `index(0)` の省略形です。"

#: src/decl-macros/minutiae/metavar-expr.md:100
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! attach_iteration_counts {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ( $(\n"
"            $((\n"
"                stringify!($inner),\n"
"                ${index(1)}, // this targets the outer repetition\n"
"                ${index()}  // and this, being an alias for `index(0)` targets "
"the inner repetition\n"
"            ),)*\n"
"        )* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let v = attach_iteration_counts! {\n"
"        ( hello ) ;\n"
"        ( indices , of ) ;\n"
"        () ;\n"
"        ( these, repetitions ) ;\n"
"    };\n"
"    println!(\"{v:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! attach_iteration_counts {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ( $(\n"
"            $((\n"
"                stringify!($inner),\n"
"                ${index(1)}, // これは外側の繰り返しを対象とします。\n"
"                ${index()}  // これは `index(0)` のエイリアスで、内側の繰り返し"
"を対象とします。\n"
"            ),)*\n"
"        )* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let v = attach_iteration_counts! {\n"
"        ( hello ) ;\n"
"        ( indices , of ) ;\n"
"        () ;\n"
"        ( these, repetitions ) ;\n"
"    };\n"
"    println!(\"{v:?}\");\n"
"    // 出力：\n"
"    // ((\"hello\", 0, 0), (\"indices\", 1, 0), (\"of\", 1, 1), (\"these\", 3, "
"0), (\"repetitions\", 3, 1))\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:127
msgid "`length(depth)`"
msgstr "`length(depth)`"

#: src/decl-macros/minutiae/metavar-expr.md:129
msgid ""
"The `length(depth)` metavariable expression expands to the iteration count of "
"the repetition at the given depth."
msgstr ""
"メタ変数式 `length(depth)` は、与えられた深さでの繰り返しの反復回数に展開されま"
"す。"

#: src/decl-macros/minutiae/metavar-expr.md:134
msgid ""
"The `length()` expression defaults `depth` to `0`, making it a shorthand for "
"`length(0)`."
msgstr "式 `length()` は `depth` を `0` とします。`length(0)` の省略形です。"

#: src/decl-macros/minutiae/metavar-expr.md:137
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! lets_count {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        $(\n"
"            $(\n"
"                println!(\n"
"                    \"'{}' in inner iteration {}/{} with '{}' in outer "
"iteration {}/{} \",\n"
"                    stringify!($inner), ${index()}, ${length()},\n"
"                    stringify!($outer), ${index(1)}, ${length(1)},\n"
"                );\n"
"            )*\n"
"        )*\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    lets_count!(\n"
"        many (small , things) ;\n"
"        none () ;\n"
"        exactly ( one ) ;\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! lets_count {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        $(\n"
"            $(\n"
"                println!(\n"
"                    \"'{}' in inner iteration {}/{} with '{}' in outer "
"iteration {}/{} \",\n"
"                    stringify!($inner), ${index()}, ${length()},\n"
"                    stringify!($outer), ${index(1)}, ${length(1)},\n"
"                );\n"
"            )*\n"
"        )*\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    lets_count!(\n"
"        many (small , things) ;\n"
"        none () ;\n"
"        exactly ( one ) ;\n"
"    );\n"
"    // 出力：\n"
"    // 'small' in inner iteration 0/2 with 'many' in outer iteration 0/3 \n"
"    // 'things' in inner iteration 1/2 with 'many' in outer iteration 0/3 \n"
"    // 'one' in inner iteration 0/1 with 'exactly' in outer iteration 2/3\n"
"}\n"
"```"

#: src/decl-macros/minutiae/metavar-expr.md:163
msgid "`ignore(ident)`"
msgstr "`ignore(ident)`"

#: src/decl-macros/minutiae/metavar-expr.md:165
msgid ""
"The `ignore(ident)` metavariable expression expands to nothing, making it "
"possible to expand something as often as a metavariable repeats without "
"expanding the metavariable."
msgstr ""
"メタ変数式 `ignore(ident)` は空に展開されます。メタ変数を展開せずに、メタ変数が"
"繰り返されるたびに何かを展開することができます。"

#: src/decl-macros/minutiae/metavar-expr.md:169
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! repetition_tuples {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ($(\n"
"            $(\n"
"                (\n"
"                    ${index()},\n"
"                    ${index(1)}\n"
"                    ${ignore(inner)} // without this metavariable expression, "
"compilation would fail\n"
"                ),\n"
"            )*\n"
"        )*)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let tuple = repetition_tuples!(\n"
"        ( one, two ) ;\n"
"        () ;\n"
"        ( one ) ;\n"
"        ( one, two, three ) ;\n"
"    );\n"
"    println!(\"{tuple:?}\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! repetition_tuples {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ($(\n"
"            $(\n"
"                (\n"
"                    ${index()},\n"
"                    ${index(1)}\n"
"                    ${ignore(inner)} // このメタ変数式が無いと、コンパイルに失"
"敗します\n"
"                ),\n"
"            )*\n"
"        )*)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let tuple = repetition_tuples!(\n"
"        ( one, two ) ;\n"
"        () ;\n"
"        ( one ) ;\n"
"        ( one, two, three ) ;\n"
"    );\n"
"    println!(\"{tuple:?}\");\n"
"}\n"
"```"

#: src/decl-macros/minutiae/hygiene.md:3
msgid ""
"`macro_rules!` macros in Rust are _partially_ hygienic, also called mixed "
"hygiene. Specifically, they are hygienic when it comes to _local variables_, "
"_labels_ and `$crate`, but nothing else."
msgstr ""
"Rust の `macro_rules!` マクロは _部分的に_ ハイジーン（衛生的）です。混合的なハ"
"イジーンとも言われます。具体的には、_ローカル変数_, _ラベル_, `$crate` に関して"
"はハイジーンですが、それ以外に関してはそうではありません。"

#: src/decl-macros/minutiae/hygiene.md:6
msgid ""
"Hygiene works by attaching an invisible \"syntax context\" value to all "
"identifiers. When two identifiers are compared, _both_ the identifiers' "
"textual names _and_ syntax contexts must be identical for the two to be "
"considered equal."
msgstr ""
"ハイジーンは、すべての識別子に目に見えない「構文コンテキスト」値を付けることで"
"機能します。2つの識別子が比較されるとき、それらが等しいとみなされるためには、識"
"別子のテキスト名称と構文コンテキストの _両方が_ 同じでなければなりません。"

#: src/decl-macros/minutiae/hygiene.md:9
msgid "To illustrate this, consider the following code:"
msgstr "これを説明するために、次のコードを考えてみましょう:"

#: src/decl-macros/minutiae/hygiene.md:13
msgid ""
"We will use the background colour to denote the syntax context. Now, let's "
"expand the macro invocation:"
msgstr ""
"構文コンテキストを表すために背景色を使用します。では、マクロを展開してみましょ"
"う:"

#: src/decl-macros/minutiae/hygiene.md:18
msgid ""
"First, recall that `macro_rules!` invocations effectively _disappear_ during "
"expansion."
msgstr ""
"まず、 `macro_rules!` 呼び出しは展開中に事実上 _消える_ ことを思い出してくださ"
"い。"

#: src/decl-macros/minutiae/hygiene.md:20
msgid ""
"Second, if you attempt to compile this code, the compiler will respond with "
"something along the following lines:"
msgstr ""
"次に、このコードをコンパイルしようとすると、コンパイラーは次のような返答をしま"
"す:"

#: src/decl-macros/minutiae/hygiene.md:30
msgid ""
"Note that the background colour (_i.e._ syntax context) for the expanded macro "
"_changes_ as part of expansion. Each `macro_rules!` macro expansion is given a "
"new, unique syntax context for its contents. As a result, there are _two "
"different `a`s_ in the expanded code: one in the first syntax context, the "
"second in the other. In other words, `a` is not the same identifier as `a`, "
"however similar they may appear."
msgstr ""
"展開されたマクロの背景色（つまり構文コンテキスト）は、展開の一部として _変わる"
"_ ことに注意してください。各 `macro_rules!` マクロの展開には、その内容に対し"
"て、新しく固有の構文コンテキストが与えられます。その結果、展開されたコードには "
"2 つの異なる `a` が存在します。最初の構文コンテキストのものと、別のコンテキスト"
"のものです。言い換えれば、同じように見えても、2つの `a` は同じ識別子ではありま"
"せん。"

#: src/decl-macros/minutiae/hygiene.md:35
msgid ""
"That said, tokens that were substituted _into_ the expanded output _retain_ "
"their original syntax context (by virtue of having been provided to the macro "
"as opposed to being part of the macro itself). Thus, the solution is to modify "
"the macro as follows:"
msgstr ""
"つまり、展開された出力に代入されたトークンは、元の構文コンテキストを保持します"
"（マクロ自体の一部ではなく、マクロに提供されたという理由で）。したがって、解決"
"策はマクロを次のように変更することです:"

#: src/decl-macros/minutiae/hygiene.md:40
msgid "Which, upon expansion becomes:"
msgstr "これで、展開はこのようになります:"

#: src/decl-macros/minutiae/hygiene.md:44
msgid ""
"The compiler will accept this code because there is only one `a` being used."
msgstr ""
"コンパイラは、 使用される `a` が1つだけ存在するため、このコードを受け入れます。"

#: src/decl-macros/minutiae/hygiene.md:46
msgid "`$crate`"
msgstr "`$crate`"

#: src/decl-macros/minutiae/hygiene.md:48
msgid ""
"Hygiene is also the reason that we need the `$crate` metavariable when our "
"macro needs access to other items in the defining crate. What this special "
"metavariable does is that it expands to an absolute path to the defining crate."
msgstr ""
"マクロから定義されたクレート内の別のアイテムにアクセスする必要があるとき、メタ"
"変数 `$crate` が必要となる理由もまた、ハイジーンです。この特別なメタ変数は定義"
"クレートへの絶対パスに展開されます。"

#: src/decl-macros/minutiae/hygiene.md:51
msgid ""
"```rust,ignore\n"
"//// Definitions in the `helper_macro` crate.\n"
"#[macro_export]\n"
"macro_rules! helped {\n"
"    // () => { helper!() } // This might lead to an error due to 'helper' not "
"being in scope.\n"
"    () => { $crate::helper!() }\n"
"}\n"
"\n"
"#[macro_export]\n"
"macro_rules! helper {\n"
"    () => { () }\n"
"}\n"
"\n"
"//// Usage in another crate.\n"
"// Note that `helper_macro::helper` is not imported!\n"
"use helper_macro::helped;\n"
"\n"
"fn unit() {\n"
"   // but it still works due to `$crate` properly expanding to the crate path "
"`helper_macro`\n"
"   helped!();\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"//// `helper_macro` クレート内の定義\n"
"#[macro_export]\n"
"macro_rules! helped {\n"
"    // () => { helper!() } // これは `helper` がスコープにないため、エラーにな"
"るでしょう。\n"
"    () => { $crate::helper!() }\n"
"}\n"
"\n"
"#[macro_export]\n"
"macro_rules! helper {\n"
"    () => { () }\n"
"}\n"
"\n"
"//// 別クレートでの使用法。\n"
"// `helper_macro::helper` がインポートされていないことに注意！\n"
"use helper_macro::helped;\n"
"\n"
"fn unit() {\n"
"   // `$crate` がクレートのパス `helper_macro` に適切に展開されるため、動作しま"
"す。\n"
"   helped!();\n"
"}\n"
"```"

#: src/decl-macros/minutiae/hygiene.md:74
msgid ""
"Note that, because `$crate` refers to the current crate, it must be used with "
"a fully qualified module path when referring to non-macro items:"
msgstr ""
"ただし、`$crate` は現在のクレートを参照するので、マクロ以外のアイテムを参照する"
"ときは、完全修飾のモジュールパスとともに使用しなければならないことに注意してく"
"ださい:"

#: src/decl-macros/minutiae/identifiers.md:3
msgid ""
"There are two tokens which you are likely to run into eventually that _look_ "
"like identifiers, but aren't. Except when they are."
msgstr ""
"あなたがいつか遭遇することになる、識別子のように _見える_ ものの、そうではない2"
"つのトークンがあります。それらが識別子である場合は別ですが。"

#: src/decl-macros/minutiae/identifiers.md:6
msgid ""
"First is `self`. This is _very definitely_ a keyword. However, it also happens "
"to fit the definition of an identifier. In regular Rust code, there's no way "
"for `self` to be interpreted as an identifier, but it _can_ happen with "
"`macro_rules!` macros:"
msgstr ""
"1つめは `self`です。これは _確実に間違いなく_ キーワードです。しかしながら、と"
"きに識別子の定義にも当てはまってしまうことがあります。通常のRustのコードでは "
"`self` を識別子として解釈することはありませんが、`macro_rules!` マクロではそれ"
"が _ありえます_ :"

#: src/decl-macros/minutiae/identifiers.md:11
msgid ""
"```rust\n"
"macro_rules! what_is {\n"
"    (self) => {\"the keyword `self`\"};\n"
"    ($i:ident) => {concat!(\"the identifier `\", stringify!($i), \"`\")};\n"
"}\n"
"\n"
"macro_rules! call_with_ident {\n"
"    ($c:ident($i:ident)) => {$c!($i)};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\", what_is!(self));\n"
"    println!(\"{}\", call_with_ident!(what_is(self)));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! what_is {\n"
"    (self) => {\"the keyword `self`\"};\n"
"    ($i:ident) => {concat!(\"the identifier `\", stringify!($i), \"`\")};\n"
"}\n"
"\n"
"macro_rules! call_with_ident {\n"
"    ($c:ident($i:ident)) => {$c!($i)};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\", what_is!(self));\n"
"    println!(\"{}\", call_with_ident!(what_is(self)));\n"
"}\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:27
msgid "The above outputs:"
msgstr "上記の出力は:"

#: src/decl-macros/minutiae/identifiers.md:34
msgid ""
"But that makes no sense; `call_with_ident!` required an identifier, matched "
"one, and substituted it! So `self` is both a keyword and not a keyword at the "
"same time. You might wonder how this is in any way important. Take this "
"example:"
msgstr ""
"妙なことになっていますね。 `call_with_ident!` は識別子を必要とし、マッチしたも"
"のがあり、それを代入しました！そう、`self` はキーワードであり、また同時にキー"
"ワードでありません。どのようなときにこれが重要なのか気になるかもしれません。次"
"の例を見てみましょう:"

#: src/decl-macros/minutiae/identifiers.md:39
msgid ""
"```rust\n"
"macro_rules! make_mutable {\n"
"    ($i:ident) => {let mut $i = $i;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_mutable!(self);\n"
"        self.0 *= 2;\n"
"        self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! make_mutable {\n"
"    ($i:ident) => {let mut $i = $i;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_mutable!(self);\n"
"        self.0 *= 2;\n"
"        self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:59
msgid "This fails to compile with:"
msgstr "これはコンパイルに失敗します:"

#: src/decl-macros/minutiae/identifiers.md:74
msgid ""
"So the macro will happily match `self` as an identifier, allowing you to use "
"it in cases where you can't actually use it. But, fine; it somehow remembers "
"that `self` is a keyword even when it's an identifier, so you _should_ be able "
"to do this, right?"
msgstr ""
"つまり、マクロは `self` を識別子として喜んでマッチさせ、実際には使えないケース"
"でも使えるようにします。でも大丈夫です。 `self` は識別子であってもキーワードで"
"あることがとにかく記憶されています。そう、次のようなことが可能な _はず_ です。"
"そうでしょう？"

#: src/decl-macros/minutiae/identifiers.md:77
msgid ""
"```rust\n"
"macro_rules! make_self_mutable {\n"
"    ($i:ident) => {let mut $i = self;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_self_mutable!(mut_self);\n"
"        mut_self.0 *= 2;\n"
"        mut_self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! make_self_mutable {\n"
"    ($i:ident) => {let mut $i = self;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_self_mutable!(mut_self);\n"
"        mut_self.0 *= 2;\n"
"        mut_self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:97
msgid "This fails with:"
msgstr "これは次のように失敗します:"

#: src/decl-macros/minutiae/identifiers.md:116
msgid ""
"Now the compiler thinks we refer to our module with `self`, but that doesn't "
"make sense. We already have a `self` right there, in the function signature "
"which is definitely not a module. It's almost like it's complaining that the "
"`self` it's trying to use isn't the _same_ `self`... as though the `self` "
"keyword has hygiene, like an... identifier."
msgstr ""
"ここでコンパイラは `self`により自モジュールを参照していると考えますが、それはお"
"かしいです。すでに関数のシグネチャに `self` があり、そしてこれは間違いなくモ"
"ジュールではありません。まるで、使おうとしている `self` が _同じ_ `self` ではな"
"いことに文句を言っているかのようです ...あたかも `self` キーワードが識別子のよ"
"うにハイジーンであるかのように。"

#: src/decl-macros/minutiae/identifiers.md:120
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($body:expr) => {\n"
"        fn double(mut self) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {{\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($body:expr) => {\n"
"        fn double(mut self) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {{\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:143
msgid "Same error.  What about..."
msgstr "同じエラー。 ではこれでどうでしょう..."

#: src/decl-macros/minutiae/identifiers.md:145
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double(mut $self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {self, {\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double(mut $self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {self, {\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:168
msgid ""
"At last, _this works_. So `self` is both a keyword _and_ an identifier when it "
"feels like it. Surely this works for other, similar constructs, right?"
msgstr ""
"ついに、 _これは動くようになりました_ 。つまり、`self`はキーワードであると同時"
"に、その気になれば識別子にもなるのです。きっとこれは他の、似たような構成要素で"
"も使えるんですよね？"

#: src/decl-macros/minutiae/identifiers.md:172
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double($self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {_, 0}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double($self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {_, 0}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/identifiers.md:203
msgid ""
"No, of course not. `_` is a keyword that is valid in patterns and expressions, "
"but somehow _isn't_ an identifier like the keyword `self` is, despite matching "
"the definition of an identifier just the same."
msgstr ""
"いいえ、もちろん違います。`_` はパターンや式の中で有効なキーワードです。しか"
"し、キーワード `self` と同じように識別子の定義に合致しているにもかかわらず、 "
"`_` はなぜか識別子では _ありません_ 。"

#: src/decl-macros/minutiae/identifiers.md:206
msgid ""
"You might think you can get around this by using `$self_:pat` instead; that "
"way, `_` will match! Except, no, because `self` isn't a pattern. Joy."
msgstr ""
"代わりに `$self_:pat` を使えば、これを回避できると思うかもしれません。 そうすれ"
"ば `_` はマッチします！しかし、うまくいきません。 `self` はパターンではないから"
"です。愉快なことです。"

#: src/decl-macros/minutiae/identifiers.md:209
msgid ""
"The only work around for this (in cases where you want to accept some "
"combination of these tokens) is to use a [`tt`](./fragment-specifiers.md#tt) "
"matcher instead."
msgstr ""
"これを回避するには（これらのトークンの組み合わせを受け入れたい場合）、代わりに"
"[`tt`](./fragment-specifiers.md#tt)マッチャーを使うしかありません。"

#: src/decl-macros/minutiae/debugging.md:3
msgid ""
"**Note**: This is a list of debugging tools specifically tailored towards "
"declarative macros, additional means of debugging these can be found in the "
"[debugging chapter](../../syntax-extensions/debugging.md) of syntax extensions."
msgstr ""
"**注意**: これは宣言的マクロに特化したデバッグツールのリストです。これらのデ"
"バッグの追加手段は、構文拡張の[デバッキングの章](../../syntax-extensions/"
"debugging.md)にあります。"

#: src/decl-macros/minutiae/debugging.md:5
msgid ""
"One of the most useful is [`trace_macros!`](https://doc.rust-lang.org/std/"
"macro.trace_macros.html), which is a directive to the compiler instructing it "
"to dump every `macro_rules!` macro invocation prior to expansion. For example, "
"given the following:"
msgstr ""
"最も便利なものの1つは、[`trace_macros!`](https://doc.rust-lang.org/std/macro."
"trace_macros.html)です。これはコンパイラに対する指示です。各 `macro_rules!` マ"
"クロ呼び出しを、展開の前にダンプするように指示します。例えば、次のようにすると:"

#: src/decl-macros/minutiae/debugging.md:8
msgid ""
"```rust,ignore\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(trace_macros)]\n"
"\n"
"macro_rules! each_tt {\n"
"    () => {};\n"
"    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};\n"
"}\n"
"\n"
"each_tt!(foo bar baz quux);\n"
"trace_macros!(true);\n"
"each_tt!(spim wak plee whum);\n"
"trace_macros!(false);\n"
"each_tt!(trom qlip winp xod);\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(trace_macros)]\n"
"\n"
"macro_rules! each_tt {\n"
"    () => {};\n"
"    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};\n"
"}\n"
"\n"
"each_tt!(foo bar baz quux);\n"
"trace_macros!(true);\n"
"each_tt!(spim wak plee whum);\n"
"trace_macros!(false);\n"
"each_tt!(trom qlip winp xod);\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/debugging.md:47
msgid ""
"This is _particularly_ invaluable when debugging deeply recursive `macro_rules!"
"` macros. You can also enable this from the command-line by adding `-Z trace-"
"macros` to the compiler command line."
msgstr ""
"これは特に再帰的な `macro_rules!` マクロを詳しくデバッグするときに _非常に_ 便"
"利です。また、コンパイラのコマンドラインに `-Z trace-macros` を追加することで、"
"コマンドラインからこの機能を有効にすることも可能です。"

#: src/decl-macros/minutiae/debugging.md:50
msgid ""
"Secondly, there is [`log_syntax!`](https://doc.rust-lang.org/std/macro."
"log_syntax.html) which causes the compiler to output all tokens passed to it. "
"For example, this makes the compiler sing a song:"
msgstr ""
"次に、[`log_syntax!`](https://doc.rust-lang.org/std/macro.log_syntax.html) があ"
"ります。これはコンパイラに渡されたすべてのトークンを出力させます。例えば、以下"
"はコンパイラに歌を歌わせます:"

#: src/decl-macros/minutiae/debugging.md:53
msgid ""
"```rust\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(log_syntax)]\n"
"\n"
"macro_rules! sing {\n"
"    () => {};\n"
"    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};\n"
"}\n"
"\n"
"sing! {\n"
"    ^ < @ < . @ *\n"
"    '\\x08' '{' '\"' _ # ' '\n"
"    - @ '$' && / _ %\n"
"    ! ( '\\t' @ | = >\n"
"    ; '\\x08' '\\'' + '$' ? '\\x7f'\n"
"    , # '\"' ~ | ) '\\x07'\n"
"}\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(log_syntax)]\n"
"\n"
"macro_rules! sing {\n"
"    () => {};\n"
"    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};\n"
"}\n"
"\n"
"sing! {\n"
"    ^ < @ < . @ *\n"
"    '\\x08' '{' '\"' _ # ' '\n"
"    - @ '$' && / _ %\n"
"    ! ( '\\t' @ | = >\n"
"    ; '\\x08' '\\'' + '$' ? '\\x7f'\n"
"    , # '\"' ~ | ) '\\x07'\n"
"}\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/debugging.md:74
msgid ""
"This can be used to do slightly more targeted debugging than [`trace_macros!`]"
"(https://doc.rust-lang.org/std/macro.trace_macros.html)."
msgstr ""
"これは、[`trace_macros!`](https://doc.rust-lang.org/std/macro.trace_macros."
"html) よりも少し的を絞ったデバッグを行うために使えます。"

#: src/decl-macros/minutiae/debugging.md:76
msgid ""
"Another amazing tool is [`lukaslueg`'s](https://github.com/lukaslueg) "
"[`macro_railroad`](https://github.com/lukaslueg/macro_railroad), a tool that "
"allows you visualize and generate syntax diagrams for Rust's `macro_rules!` "
"macros. It visualizes the accepted macro's grammar as an automata."
msgstr ""
"もう一つの素晴らしいツールは、[`lukaslueg` の](https://github.com/lukaslueg) "
"[`macro_railroad`](https://github.com/lukaslueg/macro_railroad) です。これは、"
"Rust の `macro_rules!` マクロの構文図を視覚化して生成できるツールです。受け付け"
"たマクロの文法をオートマトンとして視覚化します。"

#: src/decl-macros/minutiae/scoping.md:3
msgid ""
"The way in which mbe macros are scoped can be somewhat unintuitive. They use "
"two forms of scopes: textual scope, and path-based scope."
msgstr ""
"mbeマクロのスコープは、やや直感的でない場合があります。２つの形式のスコープ、す"
"なわちテキストスコープとパスベーススコープです。"

#: src/decl-macros/minutiae/scoping.md:6
msgid ""
"When such a macro is invoked by an unqualified identifier(an identifier that "
"isn't part of a multi-segment path), it is first looked up in textual scoping "
"and then in path-based scoping should the first lookup not yield any results. "
"If it is invoked by a qualified identifier it will skip the textual scoping "
"lookup and instead only do a look up in the path-based scoping."
msgstr ""
"このようなマクロが修飾なしの識別子 (マルチセグメントパスの一部ではない識別子) "
"によって呼び出されると、最初にテキストスコープで検索され、最初の検索で結果が得"
"られない場合はパスベーススコープで検索されます。修飾ありの識別子で呼び出された"
"場合は、テキストスコープでの検索はスキップされ、代わりにパスベーススコープでの"
"検索のみが行われます。"

#: src/decl-macros/minutiae/scoping.md:9
msgid "Textual Scope"
msgstr "テキストスコープ"

#: src/decl-macros/minutiae/scoping.md:11
msgid ""
"Firstly, unlike everything else in the language, function-like macros will "
"remain visible in sub-modules."
msgstr ""
"まず、言語のその他すべてのものと異なり、関数風のマクロはサブモジュールでも可視"
"です。"

#: src/decl-macros/minutiae/scoping.md:13
msgid ""
"```rust\n"
"macro_rules! X { () => {}; }\n"
"mod a {\n"
"    X!(); // defined\n"
"}\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! X { () => {}; }\n"
"mod a {\n"
"    X!(); // 定義されている\n"
"}\n"
"mod b {\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    X!(); // 定義されている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:27
msgid ""
"**Note**: In these examples, remember that all of them have the _same "
"behavior_ when the module contents are in separate files."
msgstr ""
"**注意**: これらの例では、モジュールの内容が別々のファイルにある場合に、すべて "
"_同じ振る舞い_ をすることを覚えておいてください。"

#: src/decl-macros/minutiae/scoping.md:29
msgid ""
"Secondly, _also_ unlike everything else in the language, `macro_rules!` macros "
"are only accessible _after_ their definition. Also note that this example "
"demonstrates how `macro_rules!` macros do not \"leak\" out of their defining "
"scope:"
msgstr ""
"次にまた、言語のその他すべてのものと異なり、`macro_rules!` マクロは定義の _後_ "
"にのみ受け付けられます。この例は `macro_rules!` マクロが定義されたスコープから"
"「漏れ」ないことを示しています:"

#: src/decl-macros/minutiae/scoping.md:32
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"mod b {\n"
"    // X!(); // undefined\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    // X!(); // undefined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"mod b {\n"
"    // X!(); // 定義されていない\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:47
msgid ""
"To be clear, this lexical order dependency applies even if you move the macro "
"to an outer scope:"
msgstr ""
"誤解のないように言うと、このテキスト上の順序の依存関係は、マクロを外側のスコー"
"プに移した場合でも適用されるということです:"

#: src/decl-macros/minutiae/scoping.md:49
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => {}; }\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"macro_rules! X { () => {}; }\n"
"mod b {\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    X!(); // 定義されている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:63
msgid "However, this dependency _does not_ apply to macros themselves:"
msgstr "しかし、この依存関係はマクロ自体には _適用されません_ :"

#: src/decl-macros/minutiae/scoping.md:65
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => { Y!(); }; }\n"
"mod b {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"macro_rules! X { () => { Y!(); }; }\n"
"mod b {\n"
"    // X!(); // 定義されているが、 Y! が定義されていない\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // 定義されており、 Y! も定義されている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:80
msgid ""
"Defining `macro_rules!` macros multiple times is allowed and the most recent "
"declaration will simply shadow previous ones unless it has gone out of scope."
msgstr ""
"マクロ `macro_rules!` マクロを複数回定義してもかまいません。単に、最も最新の定"
"義が、それがスコープを外れない限り、それ以前の定義を隠します。"

#: src/decl-macros/minutiae/scoping.md:82
msgid ""
"```rust\n"
"macro_rules! X { (1) => {}; }\n"
"X!(1);\n"
"macro_rules! X { (2) => {}; }\n"
"// X!(1); // Error: no rule matches `1`\n"
"X!(2);\n"
"\n"
"mod a {\n"
"    macro_rules! X { (3) => {}; }\n"
"    // X!(2); // Error: no rule matches `2`\n"
"    X!(3);\n"
"}\n"
"// X!(3); // Error: no rule matches `3`\n"
"X!(2);\n"
"\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! X { (1) => {}; }\n"
"X!(1);\n"
"macro_rules! X { (2) => {}; }\n"
"// X!(1); // Error: no rule matches `1`\n"
"X!(2);\n"
"\n"
"mod a {\n"
"    macro_rules! X { (3) => {}; }\n"
"    // X!(2); // Error: no rule matches `2`\n"
"    X!(3);\n"
"}\n"
"// X!(3); // Error: no rule matches `3`\n"
"X!(2);\n"
"\n"
"```"

#: src/decl-macros/minutiae/scoping.md:99
msgid ""
"`macro_rules!` macros can be exported from a module using the `#[macro_use]` "
"attribute. Using this on a module is similar to saying that you do not want to "
"have the module's macro's scope end with the module."
msgstr ""
"`macro_rules!` マクロは、 `#[macro_use]` 属性を使用することで、モジュールからエ"
"クスポートできます。これをモジュールで使用することは、モジュールのマクロのス"
"コープをモジュール内で終わらせたくないと言うことと同じです。"

#: src/decl-macros/minutiae/scoping.md:102
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    X!(); // 定義されている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:117
msgid ""
"Note that this can interact in somewhat bizarre ways due to the fact that "
"identifiers in a `macro_rules!` macro (including other macros) are only "
"resolved upon expansion:"
msgstr ""
"`macro_rules!` マクロ（他のマクロも含む）内の識別子は展開時にのみ解決されるた"
"め、多少奇妙な相互作用が起こる可能性があることに注意してください:"

#: src/decl-macros/minutiae/scoping.md:119
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => { Y!(); }; }\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => { Y!(); }; }\n"
"    // X!(); // 定義されているが、 Y! が定義されていない\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // 定義されており、 Y! もされている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:135
msgid ""
"Another complication is that `#[macro_use]` applied to an `extern crate` _does "
"not_ behave this way: such declarations are effectively _hoisted_ to the top "
"of the module. Thus, assuming `X!` is defined in an external crate called "
"`macs`, the following holds:"
msgstr ""
"もう1つの複雑な点は、`#[macro_use]` を `extern crate` に適用した場合、このよう"
"な振る舞いを _しない_ ことです。そうした宣言は、モジュールのトップに事実上 _引"
"き上げられます_ 。したがって、`X!`が `macs` という外部クレートで定義されている"
"と仮定すると、次のようになります:"

#: src/decl-macros/minutiae/scoping.md:137
msgid ""
"```rust,ignore\n"
"mod a {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod b {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"#[macro_use] extern crate macs;\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod a {\n"
"    // X!(); // 定義されているが、 Y! が定義されていない\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod b {\n"
"    X!(); // 定義されており、 Y! もされている\n"
"}\n"
"#[macro_use] extern crate macs;\n"
"mod c {\n"
"    X!(); // 定義されており、 Y! もされている\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/scoping.md:152
msgid ""
"Finally, note that these scoping behaviors apply to _functions_ as well, with "
"the exception of `#[macro_use]` (which isn't applicable):"
msgstr ""
"最後に、これらのスコープの振る舞いは _関数_ に同様に適用されることに注意してく"
"ださい。ただし `#[macro_use]` （適用できません）は例外です:"

#: src/decl-macros/minutiae/scoping.md:154
msgid ""
"```rust\n"
"macro_rules! X {\n"
"    () => { Y!() };\n"
"}\n"
"\n"
"fn a() {\n"
"    macro_rules! Y { () => {\"Hi!\"} }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"    {\n"
"        assert_eq!(X!(), \"Hi!\");\n"
"        macro_rules! Y { () => {\"Bye!\"} }\n"
"        assert_eq!(X!(), \"Bye!\");\n"
"    }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"}\n"
"\n"
"fn b() {\n"
"    macro_rules! Y { () => {\"One more\"} }\n"
"    assert_eq!(X!(), \"One more\");\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     a();\n"
"#     b();\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! X {\n"
"    () => { Y!() };\n"
"}\n"
"\n"
"fn a() {\n"
"    macro_rules! Y { () => {\"Hi!\"} }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"    {\n"
"        assert_eq!(X!(), \"Hi!\");\n"
"        macro_rules! Y { () => {\"Bye!\"} }\n"
"        assert_eq!(X!(), \"Bye!\");\n"
"    }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"}\n"
"\n"
"fn b() {\n"
"    macro_rules! Y { () => {\"One more\"} }\n"
"    assert_eq!(X!(), \"One more\");\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     a();\n"
"#     b();\n"
"# }\n"
"```"

#: src/decl-macros/minutiae/scoping.md:181
msgid ""
"These scoping rules are why a common piece of advice is to place all "
"`macro_rules!` macros which should be accessible \"crate wide\" at the very "
"top of your root module, before any other modules. This ensures they are "
"available _consistently_. This also applies to `mod` definitions for files, as "
"in:"
msgstr ""
"このようなスコープルールがあるため、一般的なアドバイスとして、「クレートワイ"
"ド」にアクセス可能なすべての `macro_rules!` マクロを、他のモジュールよりも先"
"に、ルートモジュールの最上位に置くことが推奨されています。こうすることで、それ"
"らが _一貫して_ 利用できるようになります。これはファイルに対する `mod` の定義に"
"も当てはまります:"

#: src/decl-macros/minutiae/scoping.md:191
msgid ""
"The order here is important, swap the declaration order and it won't compile."
msgstr "ここでの順番は重要です。宣言の順番を入れ替えるとコンパイルできません。"

#: src/decl-macros/minutiae/scoping.md:193
msgid "Path-Based Scope"
msgstr "パスベーススコープ"

#: src/decl-macros/minutiae/scoping.md:195
msgid ""
"By default, a `macro_rules!` macro has no path-based scope. However, if it has "
"the `#[macro_export]` attribute, then it is declared in the crate root scope "
"and can be referred to similar to how you refer to any other item. The [Import "
"and Export](./import-export.html) chapter goes more in-depth into said "
"attribute."
msgstr ""
"デフォルトでは、`macro_rules!` はパスベーススコープを持ちません。しかし、"
"`#[macro_export]` 属性を持つ場合、クレートのルートスコープで宣言され、他のアイ"
"テムと同様に参照することができます。[インポートとエクスポート](./import-export."
"html)の章では、この属性についてさらに詳しく説明しています。"

#: src/decl-macros/minutiae/import-export.md:3
msgid ""
"Importing `macro_rules!` macros differs between the two Rust Editions, 2015 "
"and 2018. It is recommended to read both parts nevertheless, as the 2018 "
"Edition can still use the constructs that are explained in the 2015 Edition."
msgstr ""
"`macro_rules!`マクロのインポートは、2つのRust Edition、2015と2018、で異なりま"
"す。とはいえ、2018 Editionでも2015 Editionで説明されている構成物を使用すること"
"ができるので、両方のパートを読むことをお勧めします。"

#: src/decl-macros/minutiae/import-export.md:6
msgid "Edition 2015"
msgstr "Edition 2015"

#: src/decl-macros/minutiae/import-export.md:8
msgid ""
"In Edition 2015 you have to use the `#[macro_use]` attribute that has already "
"been introduced in the [scoping chapter](./scoping.md). This can be applied to "
"_either_ modules or external crates. For example:"
msgstr ""
"Edition 2015 では、[スコープの章](./scoping.md) で既に紹介されている "
"`#[macro_use]` 属性を使用する必要があります。これはモジュールと外部クレートの _"
"どちらにも_ 適用できます。例えば:"

#: src/decl-macros/minutiae/import-export.md:24
msgid ""
"`macro_rules!` macros can be exported from the current crate using "
"`#[macro_export]`. Note that this _ignores_ all visibility."
msgstr ""
"`macro_rules!` マクロは `#[macro_export]` を使用して現在のクレートからエクス"
"ポートできます。これはすべての可視性を _無視する_ ことに注意してください。"

#: src/decl-macros/minutiae/import-export.md:27
msgid "Given the following definition for a library package `macs`:"
msgstr "ライブラリパッケージ `macs` の定義を以下に示します:"

#: src/decl-macros/minutiae/import-export.md:29
msgid ""
"```rust,ignore\n"
"mod macros {\n"
"    #[macro_export] macro_rules! X { () => { Y!(); } }\n"
"    #[macro_export] macro_rules! Y { () => {} }\n"
"}\n"
"\n"
"// X! and Y! are *not* defined here, but *are* exported,\n"
"// despite `macros` being private.\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod macros {\n"
"    #[macro_export] macro_rules! X { () => { Y!(); } }\n"
"    #[macro_export] macro_rules! Y { () => {} }\n"
"}\n"
"\n"
"// X! と Y! はここでは定義されて *いません* が、エクスポートされて *います"
"* 。\n"
"// `macros` はプライベートであるにもかかわらずです。\n"
"```"

#: src/decl-macros/minutiae/import-export.md:39
msgid "The following code will work as expected:"
msgstr "以下のコードは期待通りに動作します:"

#: src/decl-macros/minutiae/import-export.md:41
msgid ""
"```rust,ignore\n"
"X!(); // X is defined\n"
"#[macro_use] extern crate macs;\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"X!(); // X は定義されています\n"
"#[macro_use] extern crate macs;\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"

#: src/decl-macros/minutiae/import-export.md:49
msgid ""
"This works, as said in the [scoping chapter](./scoping.md), because "
"`#[macro_use]` works slightly different on extern crates, as it basically "
"_hoists_ the exported macros out of the crate to the top of the module."
msgstr ""
"これは[scoping chapter](./scoping.md)で述べられているように動作します。なぜな"
"ら、 `#[macro_use]` は externクレートでは少し異なる働き、すなわちクレートからエ"
"クスポートされたマクロをモジュールのトップに _引き上げる_ ためです。"

#: src/decl-macros/minutiae/import-export.md:51
msgid ""
"Note: you can _only_ `#[macro_use]` an external crate from the root module."
msgstr "注意: ルートモジュールから _のみ_ `#[macro_use]` 可能です。"

#: src/decl-macros/minutiae/import-export.md:53
msgid ""
"Finally, when importing `macro_rules!` macros from an external crate, you can "
"control _which_ macros you import. You can use this to limit namespace "
"pollution, or to override specific macros, like so:"
msgstr ""
"最後に、外部クレートから `macro_rules!` マクロをインポートする場合、 _どの_ マ"
"クロをインポートするかを制御できます。これを使用すると、名前空間の汚染を制限し"
"たり、特定のマクロを上書きしたりすることができます:"

#: src/decl-macros/minutiae/import-export.md:56
msgid ""
"```rust,ignore\n"
"// Import *only* the `X!` macro.\n"
"#[macro_use(X)] extern crate macs;\n"
"\n"
"// X!(); // X is defined, but Y! is undefined\n"
"\n"
"macro_rules! Y { () => {} }\n"
"\n"
"X!(); // X is defined, and so is Y!\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// `X!` マクロ _のみ_ をインポート\n"
"#[macro_use(X)] extern crate macs;\n"
"\n"
"// X!(); // X は定義されているが、 Y! が定義されていない\n"
"\n"
"macro_rules! Y { () => {} }\n"
"\n"
"X!(); // X は定義されており、 Y! も定義されている\n"
"\n"
"fn main() {}\n"
"```"

#: src/decl-macros/minutiae/import-export.md:69
msgid ""
"When exporting `macro_rules!` macros, it is often useful to refer to non-macro "
"symbols in the defining crate. Because crates can be renamed, there is a "
"special substitution variable available: [`$crate`](./hygiene.md#crate). This "
"will _always_ expand to an absolute path prefix to the containing crate (_e.g."
"_ `:: macs`)."
msgstr ""
"`macro_rules!` マクロをエクスポートする場合、定義しているクレートの中にて、マク"
"ロ以外のシンボルを参照すると便利なことがよくあります。クレートは名前を変更でき"
"るので、特別な置換変数 : [`$crate`](./hygiene.md#crate) が用意されています。こ"
"れは _常に_ 、それが含まれるクレートの絶対パスの接頭辞（例: `:: macs`）に展開さ"
"れます。"

# いまいち意味がとれていない。
# $crate は 1.30から導入されたので、その辺についてのお話と思われる。
# つまり、$crateがないと、どのような問題が起こるかということが記述されている、はず。
#: src/decl-macros/minutiae/import-export.md:73
msgid ""
"Note that unless your compiler version is >= 1.30, this does _not_ work for "
"`macro_rules!` macros, because `macro_rules!` macros do not interact with "
"regular name resolution in any way. Otherwise, you cannot use something like "
"`$crate::Y!` to refer to a particular macro within your crate. The "
"implication, combined with selective imports via `#[macro_use]` is that there "
"is currently _no way_ to guarantee any given macro will be available when "
"imported by another crate."
msgstr ""
"コンパイラバージョンが 1.30 以上でない場合、 `macro_rules!` マクロは通常の名前"
"解決と一切相互作用しないため、これは `macro_rules!` について動作 _しない_ こと"
"に注意してください。そうでない場合、自身のクレートの特定のマクロを参照するため"
"に、 `$crate::Y!` のようなものを使えません。これを `#[macro_use]` による選択的"
"インポートとの組わせたとして、あるマクロが他のクレートからインポートされたとき"
"に利用可能であることを保証する方法は現在のところ _ありません_ 。"

#: src/decl-macros/minutiae/import-export.md:77
msgid ""
"It is recommended that you _always_ use absolute paths to non-macro names, to "
"avoid conflicts, _including_ names in the standard library."
msgstr ""
"標準ライブラリの名前も含め、コンフリクトを避けるため、マクロ以外の名前には _常"
"に_ 絶対パスを使用することをお勧めします。"

#: src/decl-macros/minutiae/import-export.md:81
msgid "Edition 2018"
msgstr "Edition 2018"

#: src/decl-macros/minutiae/import-export.md:83
msgid ""
"The 2018 Edition made our lives a lot easier when it comes to `macro_rules!` "
"macros. Why you ask? Quite simply because it managed to make them feel more "
"like proper items than some special thing in the language. What this means is "
"that we can properly import and use them in a namespaced fashion!"
msgstr ""
"Edition 2018では、`macro_rules!` マクロに関してとても楽になりました。なぜかっ"
"て？それは単純に、マクロを言語内の特別なものというよりも、適切なアイテムのよう"
"に感じられるようにしてくれるからです。どういうことかというと、適切にインポート"
"して、名前空間の仕方によって使えるようになったということです！"

#: src/decl-macros/minutiae/import-export.md:88
msgid ""
"So instead of using `#[macro_use]` to import every exported macro from a crate "
"into the global namespace we can now do the following:"
msgstr ""
"そのため、`#[macro_use]`を使用してクレートからエクスポートされたマクロすべてを"
"グローバル名前空間にインポートする代わりに、次のようにすることができます:"

#: src/decl-macros/minutiae/import-export.md:90
msgid ""
"```rs\n"
"use some_crate::some_macro;\n"
"\n"
"fn main() {\n"
"    some_macro!(\"hello\");\n"
"    // as well as\n"
"    some_crate::some_other_macro!(\"macro world\");\n"
"}\n"
"```"
msgstr ""
"```rs\n"
"use some_crate::some_macro;\n"
"\n"
"fn main() {\n"
"    some_macro!(\"hello\");\n"
"    // 同様に\n"
"    some_crate::some_other_macro!(\"macro world\");\n"
"}\n"
"```"

#: src/decl-macros/minutiae/import-export.md:100
msgid ""
"Unfortunately, this only applies for external crates, if you use `macro_rules!"
"` macros that you have defined in your own crate you are still required to go "
"with `#[macro_use]` on the defining modules. So scoping applies there the same "
"way as before as well."
msgstr ""
"残念ながら、これは外部クレートにのみ適用されます。自分のクレートで定義した "
"`macro_rules!` マクロを使用する場合は、定義モジュールで `#[macro_use]` を使用す"
"る必要があります。そのため、スコープは以前と同じように適用されます。"

#: src/decl-macros/minutiae/import-export.md:103
msgid ""
"The `$crate` prefix works in this version for everything, macros and items "
"alike since this Edition came out with Rust 1.31."
msgstr ""
"Rust 1.31 で登場したこの Edition では、接頭辞 `$crate` は、マクロでもアイテムで"
"も、すべてに対して機能します。"

#: src/decl-macros/patterns.md:3
msgid "Parsing and expansion patterns."
msgstr "構文解析と展開のパターン。"

#: src/decl-macros/patterns/callbacks.md:3
msgid ""
"Due to the order that macros are expanded in, it is (as of Rust 1.2) "
"impossible to pass information to a macro from the expansion of _another_ "
"macro:"
msgstr ""
"マクロの展開される順番のために、（Rust 1.2では）他のマクロの展開からマクロに情"
"報を渡せません:"

#: src/decl-macros/patterns/callbacks.md:5
msgid ""
"```rust\n"
"macro_rules! recognize_tree {\n"
"    (larch) => { println!(\"#1, the Larch.\") };\n"
"    (redwood) => { println!(\"#2, the Mighty Redwood.\") };\n"
"    (fir) => { println!(\"#3, the Fir.\") };\n"
"    (chestnut) => { println!(\"#4, the Horse Chestnut.\") };\n"
"    (pine) => { println!(\"#5, the Scots Pine.\") };\n"
"    ($($other:tt)*) => { println!(\"I don't know; some kind of birch maybe?"
"\") };\n"
"}\n"
"\n"
"macro_rules! expand_to_larch {\n"
"    () => { larch };\n"
"}\n"
"\n"
"fn main() {\n"
"    recognize_tree!(expand_to_larch!());\n"
"    // first expands to:  recognize_tree! { expand_to_larch ! (  ) }\n"
"    // and then:          println! { \"I don't know; some kind of birch maybe?"
"\" }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! recognize_tree {\n"
"    (larch) => { println!(\"#1, the Larch.\") };\n"
"    (redwood) => { println!(\"#2, the Mighty Redwood.\") };\n"
"    (fir) => { println!(\"#3, the Fir.\") };\n"
"    (chestnut) => { println!(\"#4, the Horse Chestnut.\") };\n"
"    (pine) => { println!(\"#5, the Scots Pine.\") };\n"
"    ($($other:tt)*) => { println!(\"I don't know; some kind of birch maybe?"
"\") };\n"
"}\n"
"\n"
"macro_rules! expand_to_larch {\n"
"    () => { larch };\n"
"}\n"
"\n"
"fn main() {\n"
"    recognize_tree!(expand_to_larch!());\n"
"    // 最初の展開は :  recognize_tree! { expand_to_larch ! (  ) }\n"
"    // その後　　　 :  println! { \"I don't know; some kind of birch maybe?"
"\" }\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:26
msgid "This can make modularizing macros very difficult."
msgstr "このため、マクロのモジュール化が非常に難しくなります。"

#: src/decl-macros/patterns/callbacks.md:28
msgid "An alternative is to use recursion and pass a callback:"
msgstr "取りうる方法として、再帰を使用してコールバックを渡す方法があります:"

#: src/decl-macros/patterns/callbacks.md:30
msgid ""
"```rust\n"
"// ...\n"
"\n"
"macro_rules! call_with_larch {\n"
"    ($callback:ident) => { $callback!(larch) };\n"
"}\n"
"\n"
"fn main() {\n"
"    call_with_larch!(recognize_tree);\n"
"    // first expands to:  call_with_larch! { recognize_tree }\n"
"    // then:              recognize_tree! { larch }\n"
"    // and finally:       println! { \"#1, the Larch.\" }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// ...\n"
"\n"
"macro_rules! call_with_larch {\n"
"    ($callback:ident) => { $callback!(larch) };\n"
"}\n"
"\n"
"fn main() {\n"
"    call_with_larch!(recognize_tree);\n"
"    // 最初の展開は :  call_with_larch! { recognize_tree }\n"
"    // その後　　　 :  recognize_tree! { larch }\n"
"    // 最後に　　　 :  println! { \"#1, the Larch.\" }\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:45
msgid ""
"Using a `tt` repetition, one can also forward arbitrary arguments to a "
"callback."
msgstr ""
"`tt` の繰り返しを使うと、任意の引数をコールバックに転送することもできます。"

#: src/decl-macros/patterns/callbacks.md:47
msgid ""
"```rust\n"
"macro_rules! callback {\n"
"    ($callback:ident( $($args:tt)* )) => {\n"
"        $callback!( $($args)* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    callback!(callback(println(\"Yes, this *was* unnecessary.\")));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! callback {\n"
"    ($callback:ident( $($args:tt)* )) => {\n"
"        $callback!( $($args)* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    callback!(callback(println(\"Yes, this *was* unnecessary.\")));\n"
"}\n"
"```"

#: src/decl-macros/patterns/callbacks.md:59
msgid "You can, of course, insert additional tokens in the arguments as needed."
msgstr "もちろん、必要に応じて引数に他にトークンを追加できます。"

#: src/decl-macros/patterns/tt-muncher.md:3
msgid ""
"```rust\n"
"macro_rules! mixed_rules {\n"
"    () => {};\n"
"    (trace $name:ident; $($tail:tt)*) => {\n"
"        {\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"    (trace $name:ident = $init:expr; $($tail:tt)*) => {\n"
"        {\n"
"            let $name = $init;\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     let a = 42;\n"
"#     let b = \"Ho-dee-oh-di-oh-di-oh!\";\n"
"#     let c = (false, 2, 'c');\n"
"#     mixed_rules!(\n"
"#         trace a;\n"
"#         trace b;\n"
"#         trace c;\n"
"#         trace b = \"They took her where they put the crazies.\";\n"
"#         trace b;\n"
"#     );\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! mixed_rules {\n"
"    () => {};\n"
"    (trace $name:ident; $($tail:tt)*) => {\n"
"        {\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"    (trace $name:ident = $init:expr; $($tail:tt)*) => {\n"
"        {\n"
"            let $name = $init;\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     let a = 42;\n"
"#     let b = \"Ho-dee-oh-di-oh-di-oh!\";\n"
"#     let c = (false, 2, 'c');\n"
"#     mixed_rules!(\n"
"#         trace a;\n"
"#         trace b;\n"
"#         trace c;\n"
"#         trace b = \"They took her where they put the crazies.\";\n"
"#         trace b;\n"
"#     );\n"
"# }\n"
"```"

#: src/decl-macros/patterns/tt-muncher.md:35
msgid ""
"This pattern is perhaps the _most powerful_ macro parsing technique available, "
"allowing one to parse grammars of significant complexity. However, it can "
"increase compile times if used excessively, so should be used with care."
msgstr ""
"このパターンは、あるいは _最も強力な_ マクロのパース手法です。これは非常に複雑"
"な文法を解析可能です。しかし、過度に使用するとコンパイル時間が長くなる可能性が"
"あるため、注意して利用すべきです。"

#: src/decl-macros/patterns/tt-muncher.md:39
msgid ""
"A _TT muncher_ is a recursive `macro_rules!` macro that works by incrementally "
"processing its input one step at a time. At each step, it matches and removes "
"(munches) some sequence of tokens from the start of its input, generates some "
"intermediate output, then recurses on the input tail."
msgstr ""
"_TT 消化器(TT muncher)_ は、入力を1度に1ステップずつ漸進的に処理する、再帰的な "
"`macro_rules!` マクロです。 各ステップで、入力の先頭から、あるトークンのシーケ"
"ンスをマッチして取り除き (munches)、中間出力を生成し、そして入力の残りを再帰的"
"に処理します。"

#: src/decl-macros/patterns/tt-muncher.md:42
msgid ""
"The reason for \"TT\" in the name specifically is that the unprocessed part of "
"the input is _always_ captured as `$($tail:tt)*`. This is done as a [`tt`](../"
"minutiae/fragment-specifiers.html#tt) repetition is the only way to "
"_losslessly_ capture part of a macro's input."
msgstr ""
"「TT」が名前に含まれている理由は、入力の未処理の部分が _常に_ `$($tail:tt)*` と"
"してキャプチャされるからです。これは、[`tt`](../minutiae/fragment-specifiers."
"html#tt)の繰り返しが、マクロの入力の部分を _損失なく_ キャプチャする唯一の方法"
"だからです。"

#: src/decl-macros/patterns/tt-muncher.md:45
msgid ""
"The only hard restrictions on TT munchers are those imposed on the "
"`macro_rules!` macro system as a whole:"
msgstr ""
"TT消化器の唯一の厳しい制限は、`macro_rules!`マクロシステムそのものに課されるも"
"のです:"

#: src/decl-macros/patterns/tt-muncher.md:47
msgid ""
"You can only match against literals and grammar constructs which can be "
"captured by `macro_rules!`."
msgstr "`macro_rules!` でキャプチャできるリテラルと文法構文のみマッチできます。"

#: src/decl-macros/patterns/tt-muncher.md:48
msgid "You cannot match unbalanced groups."
msgstr "アンバランスなグループのマッチはできません。"

#: src/decl-macros/patterns/tt-muncher.md:50
msgid ""
"It is important, however, to keep the macro recursion limit in mind. "
"`macro_rules!` does not have _any_ form of tail recursion elimination or "
"optimization. It is recommended that, when writing a TT muncher, you make "
"reasonable efforts to keep recursion as limited as possible. This can be done "
"by adding additional rules to account for variation in the input (as opposed "
"to recursion into an intermediate layer), or by making compromises on the "
"input syntax to make using standard repetitions more tractable."
msgstr ""
"しかし、マクロの再帰制限を念頭に置くことが重要です。`macro_rules!` は、あらゆる"
"末尾再帰の除去や最適化を持ちません。TT消化器を書くときには、再帰を可能な限り制"
"限するように合理的な努力をすることをお勧めします。これは、(中間層への再帰ではな"
"く)入力のバリエーションを反映したルールを追加したり、標準的な繰り返しをより扱い"
"やすくなるように入力構文を妥協したりすることで可能となります。"

#: src/decl-macros/patterns/tt-muncher.md:57
#: src/decl-macros/patterns/internal-rules.md:84
#: src/decl-macros/patterns/push-down-acc.md:78
msgid "Performance"
msgstr "パフォーマンス"

#: src/decl-macros/patterns/tt-muncher.md:59
msgid ""
"TT munchers are inherently quadratic. Consider a TT muncher rule that consumes "
"one token tree and then recursively calls itself on the remaining input. If it "
"is passed 100 token trees:"
msgstr ""
"TT消化器は本質的に2次（の多項式時間）です。1つのトークンツリーを消費し、残りの"
"入力を対象に再帰的に自分自身を呼び出すTT消化器のルールを考えてみましょう。100個"
"のトークンツリーが渡された場合:"

#: src/decl-macros/patterns/tt-muncher.md:62
msgid "The initial invocation will match against all 100 token trees."
msgstr "最初の呼び出しは、100個のトークンツリーすべてに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:63
msgid "The first recursive invocation will match against 99 token trees."
msgstr "最初の再帰呼び出しは、99個のトークンツリーに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:64
msgid "The next recursive invocation will match against 98 token trees."
msgstr "次の再帰呼び出しは、98個のトークンツリーに対してマッチします。"

#: src/decl-macros/patterns/tt-muncher.md:66
msgid ""
"And so on, down to 1. This is a classic quadratic pattern, and long inputs can "
"cause macro expansion to blow out compile times."
msgstr ""
"これが1個まで続きます。これは典型的な2次のパターンであり、長い入力はマクロの展"
"開によるコンパイル時間の浪費を引き起こします。"

#: src/decl-macros/patterns/tt-muncher.md:69
msgid ""
"Try to avoid using TT munchers too much, especially with long inputs. The "
"default value of the `recursion_limit` attribute is a good sanity check; if "
"you have to exceed it, you might be heading for trouble."
msgstr ""
"TT消化器を使いすぎないようにしましょう。長い入力に対しては特にそうです。 "
"`recursion_limit` 属性のデフォルト値は良いサニティチェックになります。これを超"
"えなければいけないなら、厄介なことになるかもしれません。"

#: src/decl-macros/patterns/tt-muncher.md:72
msgid ""
"If you have the choice between writing a TT muncher that can be called once to "
"handle multiple things, or a simpler macro that can be called multiple times "
"to handle a single thing, prefer the latter. For example, you could change a "
"macro that is called like this:"
msgstr ""
"複数のことを処理するために1度だけ呼び出せるTT消化器を書くか、1つのことを処理す"
"るために複数回呼び出せるより単純なマクロを書くか、どちらかを選べるのであれば後"
"者を選びましょう。例えば、以下のように呼び出されるマクロを変更できます:"

#: src/decl-macros/patterns/tt-muncher.md:84
msgid "To one that is called like this:"
msgstr "これを以下のように呼び出せるように:"

#: src/decl-macros/patterns/tt-muncher.md:93
msgid "The longer the input, the more likely this will improve compile times."
msgstr ""
"これは、入力が長ければ長いほど、コンパイル時間が短縮される可能性を高くします。"

#: src/decl-macros/patterns/tt-muncher.md:95
msgid ""
"Also, if a TT muncher macro has many rules, put the most frequently matched "
"rules as early as possible. This avoids unnecessary matching failures. (In "
"fact, this is good advice for any kind of declarative macro, not just TT "
"munchers.)"
msgstr ""
"また、TT消化器のマクロに多くのルールがある場合、最も頻繁にマッチするルールをで"
"きるだけ早い方に配置します。不必要なマッチングの失敗を避けることができます(実"
"際、これは TT消化器だけではなく、どのような種類の宣言型マクロにもとっても良いア"
"ドバイスです)。"

#: src/decl-macros/patterns/tt-muncher.md:100
msgid ""
"Finally, if you can write a macro using normal repetition via `*` or `+`, that "
"should be preferred to a TT muncher. This is most likely if each invocation of "
"the TT muncher would only process one token at a time. In more complicated "
"cases, there is an advanced technique used within the `quote` crate that can "
"avoid the quadratic behaviour, at the cost of some conceptual complexity. See "
"[this comment](https://github.com/dtolnay/quote/"
"blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746) for "
"details."
msgstr ""
"最後に、もし `*` や `+` を使った通常の繰り返しでマクロを書けるのであれば、TTマ"
"ンチャーよりもそちらを使うことをお勧めします。これは、TT消化器の各呼び出しが一"
"度に1つのトークンしか処理しない場合によく見られます。より複雑なケースでは、"
"`quote`クレート内で使用される高度なテクニックがあります。これは多少の概念的複雑"
"さを犠牲に、2次の性質を避けることを可能にします。詳細は[このコメント](https://"
"github.com/dtolnay/quote/blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib."
"rs#L664-L746)を参照してください。"

#: src/decl-macros/patterns/internal-rules.md:18
msgid ""
"Internal rules can be used to unify multiple `macro_rules!` macros into one, "
"or to make it easier to read and write [TT Munchers](./tt-muncher.html) by "
"explicitly naming what rule you wish to call in a macro."
msgstr ""
"内部ルールは、複数の `macro_rules!` マクロを一つにまとめることや、マクロの中で"
"呼び出したいルールに明示的に名前を付けることにより[TT消化器](./tt-muncher."
"html) の読み書きを簡単にすることに利用できます。"

#: src/decl-macros/patterns/internal-rules.md:20
msgid ""
"So why is it useful to unify multiple macros-by-example into one? The main "
"reasoning for this is how they are handled in the 2015 Edition of Rust due to "
"`macro_rules!` macros not being namespaced in said edition. This gives one the "
"troubles of having to re-export all the internal `macro_rules!` macros as well "
"as polluting the global macro namespace or even worse, macro name collisions "
"with other crates. In short, it's quite a hassle. This fortunately isn't "
"really a problem anymore nowadays with a rustc version >= 1.30, for more "
"information consult the [Import and Export chapter](../minutiae/import-export."
"html)."
msgstr ""
"では、なぜ複数の macros-by-example を1つにまとめることが有用なのでしょうか？\n"
"その主な理由は、Rustの Edition 2015 でのこれらマクロの扱われ方にあります。この "
"Edition では `macro_rules!` マクロは名前空間化されていません。このため、内部的"
"な `macro_rules!` マクロをすべて再エクスポートしなければならず、グローバルなマ"
"クロ名前空間を汚染し、さらに悪いことに他のクレートとマクロ名が衝突したりすると"
"いうトラブルが発生します。要するに、かなり面倒なのです。幸いなことに、rustcの"
"バージョンが1.30以上であれば、これは問題ではなくなりました。詳しくは[インポート"
"とエクスポートの章](../minutiae/import-export.html)を参照してください。"

#: src/decl-macros/patterns/internal-rules.md:26
msgid ""
"Nevertheless, let's talk about how we can unify multiple `macro_rules!` macros "
"into one with this technique and what exactly this technique even is."
msgstr ""
"ともあれ、この手法によりどのように複数の `macro_rules!` マクロを1つにまとめる"
"か、およびこの手法が何であるかについてお話しましょう。"

#: src/decl-macros/patterns/internal-rules.md:28
msgid ""
"We have two `macro_rules!` macros, the common [`as_expr!` macro](../building-"
"blocks/ast-coercion.html) and a `foo` macro that makes use of the first one:"
msgstr ""
"ここに2つの `macro_rules!` マクロがあります。一般的な [`as_expr!` マクロ](../"
"building-blocks/ast-coercion.html) と、このマクロを利用する `foo` マクロです:"

#: src/decl-macros/patterns/internal-rules.md:46
msgid ""
"This is definitely not the nicest solution we could have for this macro, as it "
"pollutes the global macro namespace as mentioned earlier. In this specific "
"case `as_expr` is also a very simple macro that we only used once, so let's "
"\"embed\" this macro in our `foo` macro with internal rules! To do so, we "
"simply prepend a new matcher for our macro, which consists of the matcher used "
"in the `as_expr` macro, but with a small addition. We prepend a tokentree that "
"makes it match only when specifically asked to. In this case we can for "
"example use `@as_expr`, so our matcher becomes `(@as_expr $e:expr) => {$e};`. "
"With this we get the macro that was defined at the very top of this page:"
msgstr ""
"前述の通り、このマクロはグローバルのマクロの名前空間を汚染してしまうため、ここ"
"での最も良い解決策ではありません。この特定のケースでは `as_expr` も一度しか使用"
"されない非常に単純なマクロなので、このマクロを内部ルールで `foo` マクロに「組み"
"込み」ましょう！これを行うには、マクロに単にマッチャーを先頭に挿入します。この"
"マッチャーは `as_expr` マクロにて使っていたものから構成されるものですが、追加が"
"あります。それが明示的に要求された場合のみマッチするように、トークンツリーを前"
"につけます。例えばこのケースでは `@as_expr` を利用でき、するとマッチャーは "
"`(@as_expr $e:expr) => {$e};` となります。これで、このページの一番上で定義した"
"マクロが得られます:"

#: src/decl-macros/patterns/internal-rules.md:68
msgid ""
"You see how we embedded the `as_expr` macro in the `foo` one? All that changed "
"is that instead of invoking the `as_expr` macro, we now invoke `foo` "
"recursively but with a special token tree prepended to the arguments, `foo!"
"(@as_expr $($tts)*)`. If you look closely you might even see that this pattern "
"can be combined quite nicely with [TT Munchers](./tt-muncher.html)!"
msgstr ""
"`foo` マクロの中に `as_expr` マクロを組み込んだことがわかりますか？変更されたの"
"は `as_expr` マクロを呼び出す代わりに `foo` を再帰的に呼び出すようになっただけ"
"です。よく見ると、このパターンは[TT Munchers](./tt-muncher.html)とうまく組み合"
"わせることができます！"

#: src/decl-macros/patterns/internal-rules.md:72
msgid ""
"The reason for using `@` was that, as of Rust 1.2, the `@` token is _not_ used "
"in prefix position; as such, it cannot conflict with anything. This reasoning "
"became obsolete later on when in Rust 1.7 macro matchers got future proofed by "
"emitting a warning to prevent certain tokens from being allowed to follow "
"certain fragments[^ambiguity-restrictions], which in Rust 1.12 became a hard-"
"error. Other symbols or unique prefixes may be used as desired, but use of `@` "
"has started to become widespread, so using it may aid readers in understanding "
"your macro."
msgstr ""
"`@` を使用する理由は、Rust 1.2 では `@` トークンはプレフィックスの位置では使用"
"されないからです。よってほかの何かと衝突することがありません。この理由は後に意"
"味がなくなりました。まず Rust 1.7 にてマクロのマッチャーが将来の対策として、特"
"定のフラグメントに特定のトークンが続くことの無いよう警告を発するようになり、そ"
"して Rust 1.12 にてハードエラーになりました。他のシンボルやユニークな接頭辞を使"
"用することもできますが、 `@` が広く使われているため、これを使用することは、マク"
"ロを読む人にとって理解の助けになるかもしれません。"

#: src/decl-macros/patterns/internal-rules.md:76
msgid "[ambiguity-restrictions](../minutiae/metavar-and-expansion.html)"
msgstr "[曖昧さの制限](../minutiae/metavar-and-expansion.html)"

#: src/decl-macros/patterns/internal-rules.md:78
msgid ""
"**Note**: in the early days of Rust the `@` token was previously used in "
"prefix position to denote a garbage-collected pointer, back when the language "
"used sigils to denote pointer types. Its only _current_ purpose is for binding "
"names to patterns. For this, however, it is used as an _infix_ operator, and "
"thus does not conflict with its use here."
msgstr ""
"**注**: Rustの初期の頃、`@` トークンはガベージコレクションポインタを示すために"
"プレフィックスの位置で使われていました（言語がポインタタイプを示すシジルを使用"
"していた頃）。 _現在の_ 唯一の用途は、名前をパターンにバインドすることです。し"
"かし、これは _中置_ 演算子として使用されるため、ここでの使用と衝突することはあ"
"りません。"

#: src/decl-macros/patterns/internal-rules.md:82
msgid ""
"Additionally, internal rules will often come _before_ any \"bare\" rules, to "
"avoid issues with `macro_rules!` incorrectly attempting to parse an internal "
"invocation as something it cannot possibly be, such as an expression."
msgstr ""
"さらに、`macro_rules!` が内部的呼び出しを、式のようなあり得ないものとして、誤っ"
"てパースしようとするという問題を避けるために、内部ルールは「素の」ルールより前"
"に置かれることがあります。"

#: src/decl-macros/patterns/internal-rules.md:86
msgid ""
"One downside of internal rules is that they can hurt compile times. Only one "
"macro rule can match any (valid) macro invocation, but the compiler must try "
"to match all rules in order. If a macro has many rules, there can be many such "
"failures, and the use of internal rules will increase the number of such "
"failures."
msgstr ""
"内部ルールの欠点は、コンパイル時間を損なうことです。ただ1つのマクロルールのみが"
"マクロ呼び出しにマッチしますが、コンパイラはほかのすべてのルールを順に試す必要"
"があります。マクロが多くのルールを持っているほど、このような不一致が多く起こり"
"得ます。そして内部ルールの使用はこのような不一致を増加します。"

#: src/decl-macros/patterns/internal-rules.md:90
msgid ""
"Also, the `@as_expr`\\-style identifier makes rules longer, slightly "
"increasing the amount of work the compiler must do when matching."
msgstr ""
"また、`@as_expr`スタイルの識別子はルールを長くし、コンパイラがマッチ処理時に行"
"わなければならない作業量を少し増加します。"

#: src/decl-macros/patterns/internal-rules.md:93
msgid ""
"Therefore, for best performance, avoiding internal rules is best. Avoiding "
"them often makes complex macros easier to read, too."
msgstr ""
"したがって、最高のパフォーマンスを得るためには、内部ルールを避けるのが最善で"
"す。また、内部ルールを避けると、複雑なマクロも読みやすくなることもあります。"

#: src/decl-macros/patterns/push-down-acc.md:3
#, fuzzy
msgid "The following macro uses _push-down accumulation_."
msgstr "以下のマクロは_push-down accumulation_を使用しています。"

#: src/decl-macros/patterns/push-down-acc.md:5
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! init_array {\n"
"    [$e:expr; $n:tt] => { \n"
"        {   \n"
"            let e = $e; \n"
"            accum!([$n, e.clone()] -> [])\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules! accum {\n"
"    ([3, $e:expr] -> [$($body:tt)*]) => { accum!([2, $e] -> [$($body)* "
"$e,]) };\n"
"    ([2, $e:expr] -> [$($body:tt)*]) => { accum!([1, $e] -> [$($body)* "
"$e,]) };\n"
"    ([1, $e:expr] -> [$($body:tt)*]) => { accum!([0, $e] -> [$($body)* "
"$e,]) };\n"
"    ([0, $_:expr] -> [$($body:tt)*]) => { [$($body)*] };\n"
"}\n"
"\n"
"let strings: [String; 3] = init_array![String::from(\"hi!\"); 3];\n"
"# assert_eq!(format!(\"{:?}\", strings), \"[\\\"hi!\\\", \\\"hi!\\\", \\\"hi!\\"
"\"]\");\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ init_array { [$e:expr; $n:tt\n"
"    [$e:expr; $n:tt] => {\n"
"        {\n"
"            let e = $e; \n"
"            accum!([$n, e.clone()] -> [])\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules!\n"
"    ([3, $e:expr] -> [$($body:tt)*]) => { accum!([2, $e] -> [$($body)* "
"$e,])};\n"
"    ([2, $e:expr] -> [$($body:tt)*]) => { accum!([1, $e] -> [$($body)* "
"$e,]) }; { accum!};\n"
"    ([1, $e:expr] -> [$($body:tt)*]) => { accum!([0, $e] -> [$($body)* "
"$e,]) }; { accum!};\n"
"    ([0, $_:expr] -> [$($body:tt)*]) => { [$($body)*] }; \n"
"}\n"
"\n"
"文字列: [文字列; 3] = init_array![String::from(\"hi!\"); 3]; \n"
"# assert_eq!(format!(\"{:?}\", strings), \"[ \\\"hi!）\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:25
#, fuzzy
msgid ""
"All syntax extensions in Rust **must** result in a complete, supported syntax "
"element (such as an expression, item, _etc._). This means that it is "
"impossible to have a syntax extension expand to a partial construct."
msgstr ""
"Rustのすべての構文拡張は、サポートされる完全な構文要素（式、アイテム、_etc.）つ"
"まり、構文拡張を部分的な構成要素に展開することはできません。"

#: src/decl-macros/patterns/push-down-acc.md:28
#, fuzzy
msgid ""
"One might hope that the above example could be more directly expressed like so:"
msgstr "上記の例をもっと直接的に表現することができればと思うかもしれません:"

#: src/decl-macros/patterns/push-down-acc.md:46
#, fuzzy
msgid ""
"The expectation is that the expansion of the array literal would proceed as "
"follows:"
msgstr "期待されるのは、配列リテラルの展開が次のように進むことです:"

#: src/decl-macros/patterns/push-down-acc.md:55
#, fuzzy
msgid ""
"However, this would require each intermediate step to expand to an incomplete "
"expression. Even though the intermediate results will never be used _outside_ "
"of a macro context, it is still forbidden."
msgstr ""
"しかし、この場合、各中間ステップを不完全な式に展開する必要があります。中間結果"
"はマクロコンテキスト以外で使用されることはありませんが、それでも禁止されていま"
"す。"

#: src/decl-macros/patterns/push-down-acc.md:58
#, fuzzy
msgid ""
"Push-down, however, allows us to incrementally build up a sequence of tokens "
"without needing to actually have a complete construct at any point prior to "
"completion. In the example given at the top, the sequence of invocations "
"proceeds as follows:"
msgstr ""
"しかし、プッシュダウンでは、完了する前のどの時点でも、実際に完全なコンストラク"
"トを持っている必要はなく、トークンのシーケンスをインクリメンタルに構築すること"
"ができます。冒頭の例では、呼び出しのシーケンスは次のように進みます:"

#: src/decl-macros/patterns/push-down-acc.md:61
#, fuzzy
msgid ""
"```rust,ignore\n"
"init_array!(String::from(\"hi!\"); 3)\n"
"accum!([3, e.clone()] -> [])\n"
"accum!([2, e.clone()] -> [e.clone(),])\n"
"accum!([1, e.clone()] -> [e.clone(), e.clone(),])\n"
"accum!([0, e.clone()] -> [e.clone(), e.clone(), e.clone(),])\n"
"[e.clone(), e.clone(), e.clone(),]\n"
"```"
msgstr ""
"錆、無視\n"
"init_array!(String::from(\"hi!\"); 3)\n"
"accum!([3, e.clone()] -> [])\n"
"accum!([2, e.clone()] -> [e.clone(),])\n"
"accum!([1, e.clone()] -> [e.clone(), e.clone(),])\n"
"accum!([0, e.clone()] -> [e.clone(), e.clone(),])\n"
"[e.clone(), e.clone(), e.clone(),])\n"
"```"

#: src/decl-macros/patterns/push-down-acc.md:70
#, fuzzy
msgid ""
"As you can see, each layer adds to the accumulated output until the "
"terminating rule finally emits it as a complete construct."
msgstr ""
"おわかりのように、各レイヤーは、最終的に終了ルールが完全な構成体として出力する"
"まで、蓄積された出力を追加します。"

#: src/decl-macros/patterns/push-down-acc.md:72
#, fuzzy
msgid ""
"The only critical part of the above formulation is the use of `$($body:tt)*` "
"to preserve the output without triggering parsing. The use of `($input) -> "
"($output)` is simply a convention adopted to help clarify the behavior of such "
"macros."
msgstr ""
"上記の定式化で唯一重要なのは、パースすることなく出力を保持するために `$($body:"
"tt)*` を使っていることです。($input) -> ($output)`の使用は、単にこのようなマク"
"ロの動作を明確にするために採用された慣習です。"

#: src/decl-macros/patterns/push-down-acc.md:75
#, fuzzy
msgid ""
"Push-down accumulation is frequently used as part of [incremental TT munchers]"
"(./tt-muncher.md), as it allows arbitrarily complex intermediate results to be "
"constructed. [Internal Rules](./internal-rules.md) were of use here as well, "
"as they simplify creating such macros."
msgstr ""
"プッシュダウン累積は、[incremental TT muncher](./tt-muncher.md)の一部として頻繁"
"に使用されます。[内部ルール](./internal-rules.md)は、このようなマクロの作成を単"
"純化するので、ここでも役に立ちました。"

#: src/decl-macros/patterns/push-down-acc.md:80
#, fuzzy
msgid ""
"Push-down accumulation is inherently quadratic. Consider a push-down "
"accumulation rule that builds up an accumulator of 100 token trees, one token "
"tree per invocation."
msgstr ""
"プッシュダウン累積は本質的に2次式です。100個のトークンツリーのアキュムレータを"
"構築するプッシュダウン累積規則を考えてみましょう。"

#: src/decl-macros/patterns/push-down-acc.md:82
#, fuzzy
msgid "The initial invocation will match against the empty accumulator."
msgstr "最初の呼び出しは空のアキュムレータとマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:83
#, fuzzy
msgid ""
"The first recursive invocation will match against the accumulator of 1 token "
"tree."
msgstr ""
"最初の再帰呼び出しは、1トークンツリーのアキュムレータに対してマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:84
#, fuzzy
msgid ""
"The next recursive invocation will match against the accumulator of 2 token "
"trees."
msgstr ""
"次の再帰呼び出しは、2つのトークンツリーのアキュムレータに対してマッチします。"

#: src/decl-macros/patterns/push-down-acc.md:86
#, fuzzy
msgid ""
"And so on, up to 100. This is a classic quadratic pattern, and long inputs can "
"cause macro expansion to blow out compile times. Furthermore, TT munchers are "
"also inherently quadratic over their input, so a macro that uses both TT "
"munching _and_ push-down accumulation will be doubly quadratic!"
msgstr ""
"というように、最大100まで。これは典型的な 2 次パターンであり、長い入力はマクロ"
"の展開がコンパイル時間を吹っ飛ばす原因になります。さらに、TT マンチャーも本質的"
"に入力に対して 2 次パターンなので、TT マンチャーとプッシュダウン蓄積の両方を使"
"用するマクロは 2 次パターンになります！"

#: src/decl-macros/patterns/push-down-acc.md:90
#, fuzzy
msgid ""
"All the [performance advice](./tt-muncher.md#performance) about TT munchers "
"holds for push-down accumulation.  In general, avoid using them too much, and "
"keep them as simple as possible."
msgstr ""
"TTマンチャーに関する[パフォーマンスに関するアドバイス](./tt-muncher."
"md#performance)はすべて、プッシュダウン・アキュムレーションにも当てはまりま"
"す。  一般的には、使い過ぎは避け、できるだけシンプルにしてください。"

#: src/decl-macros/patterns/push-down-acc.md:93
#, fuzzy
msgid ""
"Finally, make sure you put the accumulator at the _end_ of rules, rather than "
"the beginning. That way, if a rule fails, the compiler won't have had to match "
"the (potentially long) accumulator before hitting the part of the rule that "
"fails to match. This can make a large difference to compile times."
msgstr ""
"最後に、アキュムレータをルールの最初ではなく最後に置くようにしてください。そう"
"することで、ルールが失敗した場合、コンパイラはマッチに失敗したルールの部分を"
"ヒットする前に、（潜在的に長い）アキュムレータをマッチさせる必要がなくなりま"
"す。これはコンパイル時間に大きな違いをもたらします。"

#: src/decl-macros/patterns/repetition-replacement.md:9
#, fuzzy
msgid ""
"This pattern is where a matched repetition sequence is simply discarded, with "
"the variable being used to instead drive some repeated pattern that is related "
"to the input only in terms of length."
msgstr ""
"このパターンでは、マッチした繰り返しシーケンスが単に破棄され、代わりに、長さの"
"点でのみ入力に関連する繰り返しパターンを駆動するために変数が使用されます。"

#: src/decl-macros/patterns/repetition-replacement.md:11
#, fuzzy
msgid ""
"For example, consider constructing a default instance of a tuple with more "
"than 12 elements (the limit as of Rust 1.2)."
msgstr ""
"例えば、12個以上の要素（Rust 1.2での制限）を持つタプルのデフォルトインスタンス"
"を作成することを考えてみましょう。"

#: src/decl-macros/patterns/repetition-replacement.md:34
#, fuzzy
msgid "**: we _could_ have simply used `$tup_tys::default()`."
msgstr "**: 単純に `$tup_tys::default()` を使うこともできました。"

#: src/decl-macros/patterns/repetition-replacement.md:36
#, fuzzy
msgid ""
"Here, we are not actually _using_ the matched types. Instead, we throw them "
"away and replace them with a single, repeated expression. To put it another "
"way, we don't care _what_ the types are, only _how many_ there are."
msgstr ""
"ここでは、マッチした型を実際には_使用しません。その代わりに、それらを捨て、単一"
"の繰り返し式に置き換えます。別の言い方をすれば、型が何であるかは気にしません。"

#: src/decl-macros/patterns/tt-bundling.md:3
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! call_a_or_b_on_tail {\n"
"    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) => {\n"
"        $a(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) => {\n"
"        $b(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ($ab:tt, $_skip:tt $($tail:tt)*) => {\n"
"        call_a_or_b_on_tail!($ab, $($tail)*)\n"
"    };\n"
"}\n"
"\n"
"fn compute_len(s: &str) -> Option<usize> {\n"
"    Some(s.len())\n"
"}\n"
"\n"
"fn show_tail(s: &str) -> Option<usize> {\n"
"    println!(\"tail: {:?}\", s);\n"
"    None\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            the recursive part that skips over all these\n"
"            tokens does not much care whether we will call a\n"
"            or call b: only the terminal rules care.\n"
"        ),\n"
"        None\n"
"    );\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            and now, to justify the existence of two paths\n"
"            we will also call a: its input should somehow\n"
"            be self-referential, so let us make it return\n"
"            some ninety-one!\n"
"        ),\n"
"        Some(91)\n"
"    );\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロのルール！ call_a_or_b_on_tail {\n"
"    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) =&gt; {\n"
"        a(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) =&gt; { $b(stringify!"
"($($tail)*)) }; { $a(stringify!\n"
"        b(文字列化!($($tail)*))\n"
"    };\n"
"\n"
"    ($ab:tt, $_skip:tt $($tail:tt)*)=&gt;{。\n"
"        call_a_or_b_on_tail!($ab, $($tail)*)\n"
"    };\n"
"}\n"
"\n"
"fn compute_len(s: &amp;str) -&gt; オプション<usize> {。\n"
"    some(s.len())\n"
"}\n"
"\n"
"fn show_tail(s: &amp;str) -&gt; オプション<usize> {。\n"
"    println!(\"tail:{:?}\", s); \n"
"    なし\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail)、\n"
"            これらのすべての\n"
"            を呼び出すかbを呼び出すかはあまり気にしません。\n"
"            を呼び出すかbを呼び出すかはあまり気にしません。\n"
"        ),\n"
"        なし\n"
"    );\n"
"    assert_eq!\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail)、\n"
"            そして今、2つのパスの存在を正当化するために\n"
"            を呼び出すことにします。\n"
"            を返すようにしましょう。\n"
"            を返すようにしましょう！\n"
"        ),\n"
"        いくつかの(91)\n"
"    );\n"
"}\n"
"```"

#: src/decl-macros/patterns/tt-bundling.md:50
#, fuzzy
msgid ""
"In particularly complex recursive macros, a large number of arguments may be "
"needed in order to carry identifiers and expressions to successive layers. "
"However, depending on the implementation there may be many intermediate layers "
"which need to forward these arguments, but do not need to _use_ them."
msgstr ""
"特に複雑な再帰的マクロでは、識別子と式を連続するレイヤに運ぶために、多数の引数"
"が必要になるかもしれません。しかし、実装によっては、これらの引数を転送する必要"
"があっても、それらを_使用する必要がない中間層が多数あるかもしれません。"

#: src/decl-macros/patterns/tt-bundling.md:53
#, fuzzy
msgid ""
"As such, it can be very useful to bundle all such arguments together into a "
"single TT by placing them in a group. This allows layers which do not need to "
"use the arguments to simply capture and substitute a single [`tt`](../minutiae/"
"fragment-specifiers.html#tt), rather than having to exactly capture and "
"substitute the entire argument group."
msgstr ""
"そのため、このような引数をグループにまとめて、1つのTTにまとめると非常に便利で"
"す。これにより、引数を使用する必要のないレイヤーは、引数グループ全体を正確に"
"キャプチャして代入する必要がなく、単純に単一の[`tt`](../minutiae/fragment-"
"specifiers.html#tt)をキャプチャして代入することができます。"

#: src/decl-macros/patterns/tt-bundling.md:56
#, fuzzy
msgid ""
"The example above bundles the `$a` and `$b` expressions into a group which can "
"then be forwarded as a single [`tt`](../minutiae/fragment-specifiers.html#tt) "
"by the recursive rule. This group is then destructured by the terminal rules "
"to access the expressions."
msgstr ""
"上の例では、`$a` 式と `$b` 式を1つのグループにまとめ、再帰ルールによって1つの "
"[`tt`](../minutiae/fragment-specifiers.html#tt) として転送しています。そして、"
"このグループは、式にアクセスするための終端ルールによって再構築されます。"

#: src/decl-macros/building-blocks.md:3
#, fuzzy
msgid "Reusable snippets of `macro_rules!` macro code."
msgstr "マクロコード `macro_rules!` の再利用可能なスニペット。"

#: src/decl-macros/building-blocks/ast-coercion.md:3
#, fuzzy
msgid ""
"The Rust parser is not very robust in the face of `tt` substitutions. Problems "
"can arise when the parser is expecting a particular grammar construct and "
"_instead_ finds a lump of substituted `tt` tokens. Rather than attempt to "
"parse them, it will often just _give up_. In these cases, it is necessary to "
"employ an AST coercion."
msgstr ""
"Rust パーサーは `tt` の置換にあまり強くありません。パーサが特定の文法構文を期待"
"していて、その代わりに置換された `tt` トークンの塊を見つけたときに問題が発生す"
"ることがあります。このような場合、パーサは構文を解析しようとするのではなく、単"
"にあきらめることになります。このような場合、AST強制を使う必要があります。"

#: src/decl-macros/building-blocks/ast-coercion.md:22
#, fuzzy
msgid ""
"These coercions are often used with [push-down accumulation](../patterns/push-"
"down-acc.md) macros in order to get the parser to treat the final `tt` "
"sequence as a particular kind of grammar construct."
msgstr ""
"これらの強制子はしばしば[push-down accumulation](../patterns/push-down-acc.md)"
"マクロと一緒に使われます。"

#: src/decl-macros/building-blocks/ast-coercion.md:24
#, fuzzy
msgid ""
"Note that this specific set of macros is determined by what macros are allowed "
"to expand to, _not_ what they are able to capture."
msgstr ""
"このマクロの特定のセットは、マクロが何をキャプチャできるかではなく、マクロが何"
"を展開できるかによって決定されることに注意してください。"

#: src/decl-macros/building-blocks/counting.md:3
#, fuzzy
msgid ""
"What follows are several techniques for counting in `macro_rules!` macros:"
msgstr ""
"以下は、`macro_rules!` マクロでカウントするためのいくつかのテクニックです:"

#: src/decl-macros/building-blocks/counting.md:5
#, fuzzy
msgid ""
"**Note**: If you are just interested in the most efficient way [look here](./"
"counting.md#bit-twiddling)"
msgstr ""
"**注**: 最も効率的な方法に興味があるなら[ここ](./counting.md#bit-twiddling)を見"
"てください。"

#: src/decl-macros/building-blocks/counting.md:7
#, fuzzy
msgid "Repetition with replacement"
msgstr "交換を伴う繰り返し"

#: src/decl-macros/building-blocks/counting.md:9
#, fuzzy
msgid ""
"Counting things in a macro is a surprisingly tricky task. The simplest way is "
"to use replacement with a repetition match."
msgstr ""
"マクロで数を数えるのは意外と厄介な作業です。最も単純な方法は、繰り返しマッチで"
"置換を使うことです。"

#: src/decl-macros/building-blocks/counting.md:26
#, fuzzy
msgid ""
"This is a fine approach for smallish numbers, but will likely _crash the "
"compiler_ with inputs of around 500 or so tokens. Consider that the output "
"will look something like this:"
msgstr ""
"この方法は小さな数であれば問題ありませんが、500トークン程度の入力ではコンパイラ"
"がクラッシュする可能性が高くなります。出力は次のようになると考えてください:"

#: src/decl-macros/building-blocks/counting.md:33
#, fuzzy
msgid ""
"The compiler must parse this into an AST, which will produce what is "
"effectively a perfectly unbalanced binary tree 500+ levels deep."
msgstr ""
"コンパイラーはこれをASTにパースしなければなりません。ASTは、500レベル以上の深さ"
"の完全にアンバランスなバイナリツリーを生成します。"

#: src/decl-macros/building-blocks/counting.md:35
msgid "Recursion"
msgstr "再帰"

#: src/decl-macros/building-blocks/counting.md:37
#, fuzzy
msgid "An older approach is to use recursion."
msgstr "古いアプローチとしては、再帰を使う方法があります。"

#: src/decl-macros/building-blocks/counting.md:50
#, fuzzy
msgid ""
"**Note**: As of `rustc` 1.2, the compiler has _grievous_ performance problems "
"when large numbers of integer literals of unknown type must undergo inference. "
"We are using explicitly `usize`\\-typed literals here to avoid that."
msgstr ""
"**注意**: rustc` 1.2 では、未知の型の大量の整数リテラルが推論を受けなければなら"
"ない場合、コンパイラは_悲しむべき_パフォーマンス問題を抱えています。それを避け"
"るために、ここでは明示的に `usize` 型のリテラルを使用しています。"

#: src/decl-macros/building-blocks/counting.md:53
#, fuzzy
msgid ""
"If this is not suitable (such as when the type must be substitutable), you can "
"help matters by using `as` (_e.g._ `0 as $ty`, `1 as $ty`, _etc._)."
msgstr ""
"これが適切でない場合(置換可能な型でなければならない場合など)は、`as`を使用する"
"ことで、問題を解決することができます(_e._ `0 as $ty`、`1 as $ty`など)。"

#: src/decl-macros/building-blocks/counting.md:55
#, fuzzy
msgid ""
"This _works_, but will trivially exceed the recursion limit. Unlike the "
"repetition approach, you can extend the input size by matching multiple tokens "
"at once."
msgstr ""
"これはうまくいきますが、些細なことで再帰の制限を超えてしまいます。繰り返しのア"
"プローチとは異なり、複数のトークンを一度にマッチさせることで入力サイズを拡張す"
"ることができます。"

#: src/decl-macros/building-blocks/counting.md:58
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! count_tts {\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt\n"
"     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt\n"
"     $($tail:tt)*)\n"
"        => {20usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $($tail:tt)*)\n"
"        => {10usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $($tail:tt)*)\n"
"        => {5usize + count_tts!($($tail)*)};\n"
"    ($_a:tt\n"
"     $($tail:tt)*)\n"
"        => {1usize + count_tts!($($tail)*)};\n"
"    () => {0usize};\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(700, count_tts!(\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        // Repetition breaks somewhere after this\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"    ));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ count_tts {\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     k:tt $_l:tt $_m:tt $_n:tt $_o:tt\n"
"     p:tt $_q:tt $_r:tt $_s:tt $_t:tt\n"
"     ($tail:tt)*)\n"
"        => {20usize + count_tts!($($tail)*)}; \n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     ($tail:tt)*)\n"
"        => {10usize + count_tts!($($tail)*)}; \n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     ($($tail:tt)*))\n"
"        => {5usize + count_tts!($($tail)*)}; \n"
"    ($_a:tt\n"
"     ($($tail:tt)*)\n"
"        => {1usize + count_tts!($($tail)*)}; \n"
"    () => {0usize};\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(700, count_tts!(),,,,,,,,,,,.\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        // この後、どこかで繰り返しが中断\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        \n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"    ));\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/counting.md:106
#, fuzzy
msgid "This particular formulation will work up to ~1,200 tokens."
msgstr "この製剤は、～1,200トークンまで使用できます。"

#: src/decl-macros/building-blocks/counting.md:108
#, fuzzy
msgid "Slice length"
msgstr "スライス長"

#: src/decl-macros/building-blocks/counting.md:110
#, fuzzy
msgid ""
"A third approach is to help the compiler construct a shallow AST that won't "
"lead to a stack overflow. This can be done by constructing an array literal "
"and calling the `len` method."
msgstr ""
"3つ目の方法は、スタックオーバーフローにならないような浅いASTをコンパイラが構築"
"できるようにすることです。これは、配列リテラルを構築して `len` メソッドを呼び出"
"すことで実現できます。"

#: src/decl-macros/building-blocks/counting.md:127
#, fuzzy
msgid ""
"This has been tested to work up to 10,000 tokens, and can probably go much "
"higher."
msgstr ""
"これは10,000トークンまで動作することがテストされており、おそらくもっと高くする"
"ことができます。"

#: src/decl-macros/building-blocks/counting.md:129
#, fuzzy
msgid "Array length"
msgstr "配列の長さ"

#: src/decl-macros/building-blocks/counting.md:131
#, fuzzy
msgid ""
"Another modification of the previous approach is to use const generics "
"stabilized in Rust 1.51. It's only slightly slower than slice length method on "
"20,000 tokens and works in const contexts."
msgstr ""
"以前のアプローチのもう1つの修正は、Rust 1.51で安定したconstジェネリックを使うこ"
"とです。20,000トークンではslice lengthメソッドよりわずかに遅く、constコンテキス"
"トで動作します。"

#: src/decl-macros/building-blocks/counting.md:152
#, fuzzy
msgid "Enum counting"
msgstr "列挙カウント"

#: src/decl-macros/building-blocks/counting.md:154
#, fuzzy
msgid ""
"This approach can be used where you need to count a set of mutually distinct "
"identifiers."
msgstr ""
"この方法は、互いに異なる識別子の集合を数える必要がある場合に使用できます。"

#: src/decl-macros/building-blocks/counting.md:175
#, fuzzy
msgid ""
"This method does have two drawbacks. As implied above, it can _only_ count "
"valid identifiers (which are also not keywords), and it does not allow those "
"identifiers to repeat."
msgstr ""
"この方法には2つの欠点があります。上記で暗示したように、有効な識別子(キーワード"
"でもない)のみを数えることができ、それらの識別子を繰り返すことはできません。"

#: src/decl-macros/building-blocks/counting.md:178
#, fuzzy
msgid "Bit twiddling"
msgstr "ビットいじり"

#: src/decl-macros/building-blocks/counting.md:180
#, fuzzy
msgid "Another recursive approach using bit operations:"
msgstr "ビット演算を使ったもう一つの再帰的アプローチ:"

#: src/decl-macros/building-blocks/counting.md:194
#, fuzzy
msgid ""
"This approach is pretty smart as it effectively halves its input whenever its "
"even and then multiplying the counter by 2 (or in this case shifting 1 bit to "
"the left which is equivalent). If the input is uneven it simply takes one "
"token tree from the input `or`s the token tree to the previous counter which "
"is equivalent to adding 1 as the lowest bit has to be a 0 at this point due to "
"the previous shifting. Rinse and repeat until we hit the base rule `() => 0`."
msgstr ""
"このアプローチはかなりスマートで、入力が偶数であるときは常に入力を半分にし、カ"
"ウンターを2倍します（この場合は1ビットを左にシフトします）。入力が不均等な場合"
"は、単純に入力からトークンツリーを1つ取るか、トークンツリーを前のカウンターに移"
"します。基本ルール `() => 0` にぶつかるまで繰り返します。"

#: src/decl-macros/building-blocks/counting.md:198
#, fuzzy
msgid ""
"The benefit of this is that the constructed AST expression that makes up the "
"counter value will grow with a complexity of `O(log(n))` instead of `O(n)` "
"like the other approaches. Be aware that you can still hit the recursion limit "
"with this if you try hard enough. Credits for this method go to Reddit user "
"[`YatoRust`](https://www.reddit.com/r/rust/comments/d3yag8/"
"the_little_book_of_rust_macros/)."
msgstr ""
"この利点は、カウンターの値を構成するAST式が他のアプローチのように `O(n)` ではな"
"く `O(log(n))` の複雑さで成長することです。この方法でも頑張れば再帰限界にぶつか"
"る可能性があることに注意してください。この方法のクレジットはRedditユーザー"
"[`YatoRust`](https://www.reddit.com/r/rust/comments/d3yag8/"
"the_little_book_of_rust_macros/)にあります。"

#: src/decl-macros/building-blocks/counting.md:203
#, fuzzy
msgid "Let's go through the procedure by hand once:"
msgstr "一度、手で手順を確認してみましょう:"

#: src/decl-macros/building-blocks/counting.md:208
#, fuzzy
msgid ""
"This invocation will match the third rule due to the fact that we have an even "
"number of token trees(10). The matcher names the odd token trees in the "
"sequence `$a` and the even ones `$even` but the expansion only makes use of "
"`$a`, which means it effectively discards all the even elements cutting the "
"input in half. So the invocation now becomes:"
msgstr ""
"偶数のトークンツリー(10)があるため、この呼び出しは3番目のルールにマッチします。"
"マッチャーはトークン木列の奇数に `$a`、偶数に `$even` という名前を付けますが、"
"展開では `$a` のみを使用します。そのため、呼び出しは次のようになります:"

#: src/decl-macros/building-blocks/counting.md:214
#, fuzzy
msgid ""
"This invocation will now match the second rule as its input is an uneven "
"amount of token trees. In this case the first token tree is discarded to make "
"the input even again, then we also do the halving step in this invocation "
"again since we know the input would be even now anyways. Therefore we can "
"count 1 for the uneven discard and multiply by 2 again since we also halved."
msgstr ""
"この呼び出しは2番目のルールにマッチします。この場合、最初のトークンツリーを破棄"
"して入力を偶数にします。したがって、不均等な廃棄を1と数え、また半分にしたので2"
"を掛けます。"

#: src/decl-macros/building-blocks/counting.md:230
#, fuzzy
msgid ""
"Now to check if we expanded correctly manually we can use a one of the tools "
"we introduced for [`debugging`](../minutiae/debugging.md). When expanding the "
"macro there we should get:"
msgstr ""
"手動で正しく展開できたかどうかを確認するには、[`debugging`]（../minutiae/"
"debugging.md）で紹介したツールを使います。そこでマクロを展開すると"

#: src/decl-macros/building-blocks/counting.md:236
#, fuzzy
msgid "That's the same so we didn't make any mistakes, great!"
msgstr "それは同じなので、ミスはありませんでした！"

#: src/decl-macros/building-blocks/abacus-counting.md:1
#, fuzzy
msgid "Abacus Counters"
msgstr "そろばんカウンター"

#: src/decl-macros/building-blocks/abacus-counting.md:3
#, fuzzy
msgid ""
"**Provisional**: needs a more compelling example. Matching nested groups that "
"are _not_ denoted by Rust groups is sufficiently unusual that it may not merit "
"inclusion."
msgstr ""
"*仮***: もっと説得力のある例が必要です。Rustグループによって示されないネストさ"
"れたグループとのマッチングは十分に珍しいので、含める価値はないかもしれません。"

#: src/decl-macros/building-blocks/abacus-counting.md:6
#, fuzzy
msgid ""
"**Note**: this section assumes understanding of [push-down accumulation](#push-"
"down-accumulation) and [incremental TT munchers](#incremental-tt-munchers)."
msgstr ""
"*注***: このセクションは、[push-down accumulation](#push-down-accumulation) と "
"[incremental TT munchers](#incremental-tt-munchers) を理解していることを前提と"
"しています。"

#: src/decl-macros/building-blocks/abacus-counting.md:8
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! abacus {\n"
"    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((- $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (- $($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (+ $($count)*))\n"
"    };\n"
"\n"
"    // Check if the final result is zero.\n"
"    (() -> ()) => { true };\n"
"    (() -> ($($count:tt)+)) => { false };\n"
"}\n"
"\n"
"fn main() {\n"
"    let equals_zero = abacus!((++-+-+++--++---++----+) -> ());\n"
"    assert_eq!(equals_zero, true);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール\n"
"    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {\n"
"        そろばん！(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((- $($moves:tt)*) -> ($($count:tt)*)) => {そろばん!\n"
"        そろばん！(($($moves)*) -> (- $($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => { {そろばん!\n"
"        そろばん!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {そろばん!\n"
"        そろばん!(($($moves)*) -> (+ $($count)*))。\n"
"    };\n"
"\n"
"    // 最終結果が0かどうかを調べます。\n"
"    (() -> ()) => { true }; \n"
"    (() -> ($($count:tt)+)) => { false }; \n"
"}\n"
"\n"
"fn main() {\n"
"    let equals_zero = そろばん!((++-+-+++--++---++++----+) -> ()); \n"
"    assert_eq!(equals_zero, true); \n"
"}\n"
"```"

#: src/decl-macros/building-blocks/abacus-counting.md:34
#, fuzzy
msgid ""
"This technique can be used in cases where you need to keep track of a varying "
"counter that starts at or near zero, and must support the following operations:"
msgstr ""
"このテクニックは、ゼロまたはゼロに近い値から始まる変化するカウンターを追跡する"
"必要があり、以下の操作をサポートする必要がある場合に使用できます:"

#: src/decl-macros/building-blocks/abacus-counting.md:36
#, fuzzy
msgid "Increment by one."
msgstr "1ずつ増やします。"

#: src/decl-macros/building-blocks/abacus-counting.md:37
#, fuzzy
msgid "Decrement by one."
msgstr "1つ減ります。"

#: src/decl-macros/building-blocks/abacus-counting.md:38
#, fuzzy
msgid "Compare to zero (or any other fixed, finite value)."
msgstr "ゼロ（または他の固定された有限の値）と比較してください。"

#: src/decl-macros/building-blocks/abacus-counting.md:40
#, fuzzy
msgid ""
"A value of _n_ is represented by _n_ instances of a specific token stored in a "
"group. Modifications are done using recursion and [push-down accumulation]"
"(#push-down-accumulation). Assuming the token used is `x`, the operations "
"above are implemented as follows:"
msgstr ""
"n_の値は、グループに格納された特定のトークンの_n_個のインスタンスで表されます。"
"変更は再帰と[push-down accumulation](#push-down-accumulation)を使って行われま"
"す。使用するトークンを `x` とすると、上記の操作は以下のように実装されます:"

#: src/decl-macros/building-blocks/abacus-counting.md:44
#, fuzzy
msgid "Increment by one: match `($($count:tt)*)`, substitute `(x $($count)*)`."
msgstr ""
"1つ増やす: `($($count:tt)*)` にマッチし、 `(x $($count)*)` を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:45
#, fuzzy
msgid "Decrement by one: match `(x $($count:tt)*)`, substitute `($($count)*)`."
msgstr "1つ減らす: `(x $($count:tt)*)` にマッチ、 `($($count)*)` を代入。"

#: src/decl-macros/building-blocks/abacus-counting.md:46
#, fuzzy
msgid "Compare to zero: match `()`."
msgstr "ゼロとの比較: `()` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:47
#, fuzzy
msgid "Compare to one: match `(x)`."
msgstr "(x)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:48
#, fuzzy
msgid "Compare to two: match `(x x)`."
msgstr "(x)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:49
#: src/decl-macros/building-blocks/abacus-counting.md:78
#, fuzzy
msgid "_(and so on...)_"
msgstr ""
"また、APIが非推奨になることもあります。この場合、それを使用していると、今まで無"
"かった警告が出るようになります。"

#: src/decl-macros/building-blocks/abacus-counting.md:51
#, fuzzy
msgid ""
"In this way, operations on the counter are like flicking tokens back and forth "
"like an abacus.[^abacus]"
msgstr ""
"このように、カウンターの操作は、そろばんのようにトークンを前後にはじくようなも"
"のです[^abacus]。"

#: src/decl-macros/building-blocks/abacus-counting.md:53
#, fuzzy
msgid ""
"This desperately thin reasoning conceals the _real_ reason for this name: to "
"avoid having _yet another_ thing with \"token\" in the name. Talk to your "
"writer about avoiding [semantic satiation](https://en.wikipedia.org/wiki/"
"Semantic_satiation) today!  \n"
"In fairness, it could _also_ have been called [\"unary counting\"](https://en."
"wikipedia.org/wiki/Unary_numeral_system)."
msgstr ""
"この薄っぺらな理由付けには、この名前を付けた本当の理由が隠されています。意味的"
"飽和](https://en.wikipedia.org/wiki/Semantic_satiation)を避けるために、今日あな"
"たのライターに相談してください！  \n"
"公平を期すために、これは[\"単項カウント\"](https://en.wikipedia.org/wiki/"
"Unary_numeral_system)と呼ばれていたかもしれません。"

#: src/decl-macros/building-blocks/abacus-counting.md:58
#, fuzzy
msgid ""
"In cases where you want to represent negative values, _\\-n_ can be "
"represented as _n_ instances of a _different_ token. In the example given "
"above, _+n_ is stored as _n_ `+` tokens, and _\\-m_ is stored as _m_ `-` "
"tokens."
msgstr ""
"負の値を表現したい場合、_n_ は _n_ インスタンスの _different_ トークンとして表"
"現できます。上の例では、 _+n_ は _n_ `+` トークンとして格納され、 _-m_ は _m_ "
"`-` トークンとして格納されます。"

#: src/decl-macros/building-blocks/abacus-counting.md:62
#, fuzzy
msgid ""
"In this case, the operations become slightly more complicated; increment and "
"decrement effectively reverse their usual meanings when the counter is "
"negative. To which given `+` and `-` for the positive and negative tokens "
"respectively, the operations change to:"
msgstr ""
"この場合、操作は少し複雑になります。カウンタが負になると、インクリメントとデク"
"リメントは通常の意味と逆になります。正と負のトークンにそれぞれ `+` と `-` が与"
"えられると、操作は次のように変わります:"

#: src/decl-macros/building-blocks/abacus-counting.md:65
#, fuzzy
msgid "Increment by one:"
msgstr "1ずつ増やします:"

#: src/decl-macros/building-blocks/abacus-counting.md:66
#, fuzzy
msgid "match `()`, substitute `(+)`."
msgstr "マッチ `()`, 置き換える `(+)`."

#: src/decl-macros/building-blocks/abacus-counting.md:67
#, fuzzy
msgid "match `(- $($count:tt)*)`, substitute `($($count)*)`."
msgstr "マッチ `(- $($count:tt)*)`, substitute `($($count)*)`."

#: src/decl-macros/building-blocks/abacus-counting.md:68
#, fuzzy
msgid "match `($($count:tt)+)`, substitute `(+ $($count)+)`."
msgstr "($($count:tt)+)`にマッチする場合は、`(+ $($count)+)`を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:69
#, fuzzy
msgid "Decrement by one:"
msgstr "1つ減ります:"

#: src/decl-macros/building-blocks/abacus-counting.md:70
#, fuzzy
msgid "match `()`, substitute `(-)`."
msgstr "マッチ `()`, 代入 `(-)`."

#: src/decl-macros/building-blocks/abacus-counting.md:71
#, fuzzy
msgid "match `(+ $($count:tt)*)`, substitute `($($count)*)`."
msgstr "マッチ `(+ $($count:tt)*)`, substitute `($($count)*)`."

#: src/decl-macros/building-blocks/abacus-counting.md:72
#, fuzzy
msgid "match `($($count:tt)+)`, substitute `(- $($count)+)`."
msgstr "($($count:tt)+)`にマッチする場合は、`(- $($count)+)`を代入します。"

#: src/decl-macros/building-blocks/abacus-counting.md:73
#, fuzzy
msgid "Compare to 0: match `()`."
msgstr "0と比較: `()` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:74
#, fuzzy
msgid "Compare to +1: match `(+)`."
msgstr "(+)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:75
#, fuzzy
msgid "Compare to -1: match `(-)`."
msgstr "1との比較: `(-)` にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:76
#, fuzzy
msgid "Compare to +2: match `(++)`."
msgstr "(++)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:77
#, fuzzy
msgid "Compare to -2: match `(--)`."
msgstr "(--)`にマッチします。"

#: src/decl-macros/building-blocks/abacus-counting.md:80
#, fuzzy
msgid ""
"Note that the example at the top combines some of the rules together (for "
"example, it combines increment on `()` and `($($count:tt)+)` into an increment "
"on `($($count:tt)*)`)."
msgstr ""
"一番上の例では、いくつかのルールを組み合わせていることに注意してください (例え"
"ば、 `()` のインクリメントと `($($count:tt)+)` のインクリメントを組み合わせ"
"て、 `($($count:tt)*)` のインクリメントにしています)。"

#: src/decl-macros/building-blocks/abacus-counting.md:82
#, fuzzy
msgid ""
"If you want to extract the actual _value_ of the counter, this can be done "
"using a regular [counter macro](./counting.md). For the example above, the "
"terminal rules can be replaced with the following:"
msgstr ""
"カウンターの実際の_値_を抽出したい場合は、通常の[カウンターマクロ](./counting."
"md)を使って行うことができます。上の例では、端末のルールを次のように置き換えるこ"
"とができます:"

#: src/decl-macros/building-blocks/abacus-counting.md:85
#, fuzzy
msgid ""
"```rust,ignore\n"
"macro_rules! abacus {\n"
"    // ...\n"
"\n"
"    // This extracts the counter as an integer expression.\n"
"    (() -> ()) => {0};\n"
"    (() -> (- $($count:tt)*)) => {\n"
"        - ( count_tts!($( $count_tts:tt )*) )\n"
"    };\n"
"    (() -> (+ $($count:tt)*)) => {\n"
"        count_tts!($( $count_tts:tt )*)\n"
"    };\n"
"}\n"
"\n"
"// One of the many token tree counting macros in the counting chapter\n"
"macro_rules! count_tts {\n"
"    // ...\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"macro_rules!\n"
"    // ...\n"
"\n"
"    // これはカウンタを整数式として取り出します。\n"
"    (() -> ()) => {0};\n"
"    (() -> (- $($count:tt)*)) => { ...\n"
"        - ( count_tts!($( $count_tts:tt )*) ) )\n"
"    };\n"
"    (() -> (+ $($count:tt)*))=>{。\n"
"        count_tts!($( $count_tts:tt )* ))\n"
"    };\n"
"}\n"
"\n"
"// カウントの章では、トークン木をカウントするマクロを多数用意しています。\n"
"macro_rules!\n"
"    // ...\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/abacus-counting.md:105
#, fuzzy
msgid ""
"**: strictly speaking, the above formulation of `abacus!` is needlessly "
"complex. It can be implemented much more efficiently using repetition, "
"provided you _do not_ need to match against the counter's value in a macro:"
msgstr ""
"**: 厳密に言えば、上記の`abacus!マクロの中でカウンターの値とマッチする必要がな"
"ければ、繰り返しを使うことで、より効率的に実装することができます:"

#: src/decl-macros/building-blocks/parsing.md:3
#, fuzzy
msgid ""
"Parsing some of Rust's items can be useful in certain situations. This section "
"will show a few macros that can parse some of Rust's more complex items like "
"structs and functions to a certain extent. The goal of these macros is not to "
"be able to parse the entire grammar of the items but to parse parts that are "
"in general quite useful without being too complex to parse. This means we "
"ignore things like generics and such."
msgstr ""
"Rustのいくつかの項目を解析することは、特定の状況において有用です。このセクショ"
"ンでは、構造体や関数のようなRustのより複雑な項目をある程度解析できるマクロをい"
"くつか紹介します。これらのマクロの目的は、項目の文法全体を解析できるようにする"
"ことではなく、解析が複雑すぎず、一般的に非常に有用な部分を解析することです。つ"
"まり、ジェネリクスなどは無視します。"

#: src/decl-macros/building-blocks/parsing.md:7
#, fuzzy
msgid ""
"The main points of interest of these macros are their `matchers`. The "
"transcribers are only there for example purposes and are usually not that "
"impressive."
msgstr ""
"これらのマクロの主な注目点は `matchers` です。テープ起こしはあくまでも例として"
"行われるもので、通常はそれほど印象的なものではありません。"

#: src/decl-macros/building-blocks/parsing.md:10
msgid "Function"
msgstr "関数"

#: src/decl-macros/building-blocks/parsing.md:12
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! function_item_matcher {\n"
"    (\n"
"\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? )\n"
"    //                          ^~~~~~~~~~~~~~~~argument list!~~~~~~~~~~~~~~^\n"
"            $( -> $ret_ty:ty )?\n"
"    //      ^~~~return type~~~^\n"
"            { $($tt:tt)* }\n"
"    //      ^~~~~body~~~~^\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )? "
"{ $($tt)* }\n"
"    }\n"
"}\n"
"\n"
"#function_item_matcher!(\n"
"#    #[inline]\n"
"#    #[cold]\n"
"#    pub fn foo(bar: i32, baz: i32, ) -> String {\n"
"#        format!(\"{} {}\", bar, baz)\n"
"#    }\n"
"#);\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(foo(13, 37), \"13 37\");\n"
"# }\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ function_item_matcher {\n"
"    (\n"
"\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)?)\n"
"    // "
"^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"            $( -> $ret_ty:ty )?\n"
"    // ^~~~リターン・タイプ~~~~^ $( -> $ret_ty:ty )?\n"
"            { $($tt:tt)* }?\n"
"    // ^~~~~本文~~~~~^ ?\n"
"    ) => {\n"
"        $( #[$meta] )*)\n"
"        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )?"
"{ $($tt)* } ?\n"
"    }\n"
"}\n"
"\n"
"#function_item_matcher!(\n"
"#[inline]\n"
"#[cold]\n"
"pub fn foo(bar: i32, baz: i32, ) -> String { # format!\n"
"# format!(\"{} {}\", bar, baz)\n"
"# }\n"
"#);\n"
"#\n"
"# fn main() {\n"
"# assert_eq!(foo(13, 37), \"13 37\"); \n"
"# }\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:43
#, fuzzy
msgid ""
"A simple function matcher that ignores qualifiers like `unsafe`, `async`, ... "
"as well as generics and where clauses. If parsing those is required it is "
"likely that you are better off using a proc-macro instead."
msgstr ""
"unsafe`、`async` などの修飾子やジェネリクス、where 節を無視するシンプルな関数"
"マッチャです。これらのパースが必要な場合は、代わりに proc-macro を使用する方が"
"良いでしょう。"

#: src/decl-macros/building-blocks/parsing.md:46
#, fuzzy
msgid ""
"This lets you for example, inspect the function signature, generate some extra "
"things from it and then re-emit the entire function again. Kind of like a "
"`Derive` proc-macro but weaker and for functions."
msgstr ""
"これにより、例えば、関数のシグネチャを検査し、そこから余分なものを生成し、関数"
"全体を再度実行することができます。Derive`マクロのようなものです。"

#: src/decl-macros/building-blocks/parsing.md:49
#, fuzzy
msgid ""
"Ideally we would like to use a pattern fragment specifier instead of an ident "
"for the arguments but this is currently not allowed. Fortunately people don't "
"use non-identifier patterns in function signatures that often so this is "
"okay(a shame, really)."
msgstr ""
"理想的には、引数にidentの代わりにパターン断片指定子を使いたいところですが、現在"
"のところこれは許可されていません。幸いなことに、関数のシグネチャでidentでないパ"
"ターンを使うことはあまりありません。"

#: src/decl-macros/building-blocks/parsing.md:52
#, fuzzy
msgid "Method"
msgstr "方法"

#: src/decl-macros/building-blocks/parsing.md:54
#, fuzzy
msgid ""
"The macro for parsing basic functions is nice and all, but sometimes we would "
"like to also parse methods, functions that refer to their object via some form "
"of `self` usage. This makes things a bit trickier:"
msgstr ""
"基本的な関数を解析するマクロはいいのですが、時にはメソッドや、何らかの形で "
"`self` を使ってオブジェクトを参照する関数も解析したいことがあります。これは少し"
"厄介です:"

#: src/decl-macros/building-blocks/parsing.md:56
#, fuzzy
msgid "WIP"
msgstr "仕掛品"

#: src/decl-macros/building-blocks/parsing.md:58
#, fuzzy
msgid "Struct"
msgstr "構造"

#: src/decl-macros/building-blocks/parsing.md:60
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! struct_item_matcher {\n"
"    // Unit-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident;\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name;\n"
"    };\n"
"\n"
"    // Tuple-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident (\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~~^\n"
"                $field_vis:vis $field_ty:ty\n"
"    //          ^~~~~~a single field~~~~~~^\n"
"            ),*\n"
"        $(,)? );\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name (\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_ty\n"
"            ),*\n"
"        );\n"
"    };\n"
"\n"
"    // Named-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident {\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~!^\n"
"                $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"            ),*\n"
"        $(,)? }\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name {\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_name : $field_ty\n"
"            ),*\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Foo {\n"
"#       pub bar: i32,\n"
"#       baz: &'static str,\n"
"#       qux: f32\n"
"#    }\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Bar;\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) struct Baz (i32, pub f32, String);\n"
"#);\n"
"#fn main() {\n"
"#    let _: Foo = Foo { bar: 42, baz: \"macros can be nice\", qux: 3.14, };\n"
"#    let _: Bar = Bar;\n"
"#    let _: Baz = Baz(2, 0.1234, String::new());\n"
"#}\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ struct_item_matcher {\n"
"    // ユニット構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident; \n"
"    ) => {\n"
"        ( $( #[$meta] )* ) => { $vis struct $name: ident; ) => { $vis struct "
"$name: ident\n"
"        vis struct $name; \n"
"    };\n"
"\n"
"    // タプル構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident (\n"
"            $(\n"
"                フィールドの属性は以下のようになります。\n"
"    // フィールドの属性\n"
"                field_vis:vis $field_ty:ty\n"
"    // ^~~~~単一のフィールド~~~~~~^\n"
"            ),*\n"
"        $(,)?);\n"
"    ) => {\n"
"        $( #[$meta] )*。\n"
"        vis構造体 $name (\n"
"            $(\n"
"                $( #[$field_meta] )* $vis\n"
"                $field_vis $field_ty\n"
"            ),*\n"
"        );\n"
"    };\n"
"\n"
"    // 名前付き構造体\n"
"    (\n"
"        $( #[$meta:meta] )*。\n"
"    // ^~~~attributes~~~^\n"
"        vis:vis構造体 $name:ident { $vis:vis struct $name:ident { $vis:vis構造"
"体\n"
"            $(\n"
"                フィールドの属性\n"
"    // フィールドの属性\n"
"                field_vis:vis $field_name:ident : $field_ty:ty\n"
"    // ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"            ),*\n"
"        $(,)?}\n"
"    ) => {\n"
"        $( #[$meta] )*。\n"
"        構造体 $name { $vis\n"
"            $(\n"
"                $( #[$field_meta] )* $vis\n"
"                $field_vis $field_name : $field_ty\n"
"            ),*\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#struct_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) struct Foo {\n"
"# pub bar: i32、\n"
"# baz: &'static str、\n"
"# qux: f32\n"
"# }\n"
"#);\n"
"#struct_item_matcher!(\n"
"#[derive(Copy, Clone)].\n"
"# pub(crate) struct Bar; \n"
"#);\n"
"#struct_item_matcher!\n"
"#[derive(Clone)] # pub(crate) struct Bar; #); #struct_item_matcher!\n"
"# pub(crate) struct Baz (i32, pub f32, String); \n"
"#);\n"
"#fn main() {\n"
"# let _: Foo = Foo { bar: 42, baz: \"macros can be nice\", qux: 3.14, }; \n"
"# let _: Bar = Bar; \n"
"# let _: Baz = Baz(2, 0.1234, String::new()); \n"
"#}\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:140
#, fuzzy
msgid "Enum"
msgstr ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"

#: src/decl-macros/building-blocks/parsing.md:142
#, fuzzy
msgid ""
"Parsing enums is a bit more complex than structs so we will finally make use "
"of some of the [patterns](../patterns.md) we have discussed, [Incremental TT "
"Muncher](../patterns/tt-muncher.md) and [Internal Rules](../patterns/internal-"
"rules.md). Instead of just building the parsed enum again we will merely visit "
"all the tokens of the enum, as rebuilding the enum would require us to collect "
"all the parsed tokens temporarily again via a [Push Down Accumulator](../"
"patterns/push-down-acc.md)."
msgstr ""
"列挙型の解析は構造体よりも少し複雑なので、最後に、これまで説明した [パターン]"
"(../patterns.md) の一部、[インクリメンタル TT マンチャー](../patterns/tt-"
"muncher.md) と [内部ルール](../patterns/internal-rules.md) を利用します。enumを"
"再構築するには、[Push Down Accumulator](../patterns/push-down-acc.md)を使って、"
"パースされたトークンを一時的に収集する必要があるからです。"

#: src/decl-macros/building-blocks/parsing.md:145
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! enum_item_matcher {\n"
"    // tuple variant\n"
"    (@variant $variant:ident (\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~~^\n"
"            $field_vis:vis $field_ty:ty\n"
"    //      ^~~~~~a single field~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    ) $(, $($tt:tt)* )? ) => {\n"
"\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // named variant\n"
"    (@variant $variant:ident {\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~!^\n"
"            $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    } $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // unit variant\n"
"    (@variant $variant:ident $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // trailing comma\n"
"    (@variant ,) => {};\n"
"    // base case\n"
"    (@variant) => {};\n"
"    // entry point\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"        $vis:vis enum $name:ident {\n"
"            $($tt:tt)*\n"
"        }\n"
"    ) => {\n"
"        enum_item_matcher!(@variant $($tt)*)\n"
"    };\n"
"}\n"
"\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Foo {\n"
"#        Bar,\n"
"#        Baz,\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Bar {\n"
"#        Foo(i32, f32),\n"
"#        Bar,\n"
"#        Baz(),\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) enum Baz {}\n"
"#);\n"
"```"
msgstr ""
"ラスト\n"
"マクロルール！ enum_item_matcher { // タプルのバリアント\n"
"    // タプルのバリアント\n"
"    (@variant $variant:ident (\n"
"        $(\n"
"            フィールドの属性は以下のようになります。\n"
"    // フィールドの属性\n"
"            field_vis:vis $field_ty:ty\n"
"    // ^~~~~単一のフィールド~~~~~^ $( #[$field_meta:meta] ),* $(,?\n"
"        ),* $(,)?\n"
"    // ∨~~~入力の残り~~~∨\n"
"    ) $(, $($tt:tt)* )?) => {\n"
"\n"
"        // 残りの列挙を処理\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // 名前付きバリアント\n"
"    (@variant $variant:ident {)?\n"
"        $(\n"
"            $( #[$field_meta:meta] )* )?\n"
"    // フィールドの属性\n"
"            field_vis:vis $field_name:ident : $field_ty:ty\n"
"    // ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~入力の残り\n"
"    }$(, $($tt:tt)* )?) => {\n"
"        // 残りの列挙を処理\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // ユニットバリアント\n"
"    (@variant $variant:ident $(, $($tt:tt)* )?) => {\n"
"        // 残りの列挙型を処理します\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // 末尾のカンマ\n"
"    (@variant ,) => {}; \n"
"    // 基本の場合\n"
"    (@variant) => {}; \n"
"    // エントリ・ポイント\n"
"    (\n"
"        $$( #[$meta:meta] )*の場合\n"
"        vis:vis列挙型 $name:ident { $($tt:tt)\n"
"            $($tt:tt)*\n"
"        }\n"
"    ) => {\n"
"        enum_item_matcher！(@変数 $($tt)*)\n"
"    };\n"
"}\n"
"\n"
"#enum_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) enum Foo {.\n"
"# バー\n"
"# Baz、\n"
"# }\n"
"#);\n"
"#enum_item_matcher!\n"
"#[derive(Copy, Clone)] # pub(crate)\n"
"# pub(crate) enum Bar {.\n"
"# Foo(i32, f32)、\n"
"# Bar、\n"
"# Baz()、\n"
"# }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#[derive(Clone)] #.\n"
"# pub(crate) enum Baz {}.\n"
"#);\n"
"```"

#: src/decl-macros/macros2.md:3
#, fuzzy
msgid ""
"_RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-"
"macros.md)  \n"
"_Tracking Issue_: [rust#39412](https://github.com/rust-lang/rust/"
"issues/39412)  \n"
"_Feature_: `#![feature(decl_macro)]`"
msgstr ""
"RFC_: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-"
"macros.md)\n"
"_Tracking Issue_: [rust#39412](https://github.com/rust-lang/rust/"
"issues/39412)\n"
"_Feature_: `#![feature(decl_macro)]`."

#: src/decl-macros/macros2.md:7
msgid ""
"While not yet stable(or rather far from being finished), there is proposal for "
"a new declarative macro system that is supposed to replace `macro_rules!` "
"dubbed declarative macros 2.0, `macro`, `decl_macro` or confusingly also "
"`macros-by-example`."
msgstr ""
"まだ安定していませんが（というか、完成にはほど遠いですが）、 `macro_rules!` を"
"置き換えるための、新しい宣言的マクロシステムが提案されています。宣言的マクロ"
"2.0 や `macro`、`decl_macro`、あるいは紛らわしいですが `macros-by-example` と呼"
"ばれています。"

#: src/decl-macros/macros2.md:9
msgid ""
"This chapter is only meant to quickly glance over the current state, showing "
"how to use this macro system and where it differs. Nothing described here is "
"final or complete, and may be subject to change."
msgstr ""
"この章は、現状をざっと見渡し、このマクロシステムはどのように使うのか、及びどう"
"違うのかを示すことを目的としています。ここに記載されている内容は最終的なもので"
"も完全なものでもなく、変更される可能性があります。"

#: src/decl-macros/macros2.md:12
msgid "Syntax"
msgstr "構文"

#: src/decl-macros/macros2.md:14
msgid ""
"We'll do a comparison between the `macro` and `macro_rules` syntax for two "
"macros we have implemented in previous chapters:"
msgstr ""
"前の章で実装した2つのマクロについて、 `macro` 構文と `macro_rules` 構文を比較し"
"てみましょう:"

#: src/decl-macros/macros2.md:38
msgid ""
"As can be seen, they look very similar, with just a few differences as well as "
"that `macro`s have two different forms."
msgstr ""
"ご覧のように、両者は非常によく似ていますが、 `macro` 側には2つの異なる形式があ"
"ることだけが少し違います。"

#: src/decl-macros/macros2.md:40
msgid ""
"Let's inspect the `count_tts` macro first, as that one looks more like what we "
"are used to. As can be seen, it practically looks identical to the "
"`macro_rules` version with two exceptions, it uses the `macro` keyword and the "
"rule separator is a `,` instead of a `;`."
msgstr ""
"まず `count_tts` マクロを見てみましょう。見慣れた形をしていますね。見ての通り、"
"これは `macro_rules` バージョンとほぼ同一のものですが、2つ差異があります。キー"
"ワード `macro` を使用すること、およびルールを（`;` ではなく） `,` で区切ること"
"です。"

#: src/decl-macros/macros2.md:43
msgid ""
"There is a second form to this though, which is a shorthand for macros that "
"only have one rule. Taking a look at `replace_expr` we can see that in this "
"case we can write the definition in a way that more resembles an ordinary "
"function. We can write the matcher directly after the name followed by the "
"transcriber, dropping a pair of braces and the `=>` token."
msgstr ""
"これは1つだけのルールを持つマクロの省略記法ですが、2つめの形式もあります。"
"`replace_expr` を見ると、このケースでは、より普通の関数に似ている方法で定義を記"
"述できることがわかります。括弧と `=>` トークンを無しに、マッチャーを名前の後に"
"直接記述し、続けてトランスクライバーを記述できる。"

#: src/decl-macros/macros2.md:47
msgid ""
"Syntax for invoking `macro`s is the same as for `macro_rules` and function-"
"like procedural macros, the name followed by a `!` followed by the macro input "
"token tree."
msgstr ""
"`macro` の呼び出しの構文は `macro_rules` や関数風の手続き的マクロと同じです。つ"
"まり、名前に続けて `!` 、続けてマクロの入力トークンツリーです。"

#: src/decl-macros/macros2.md:49
msgid "`macro` are proper items"
msgstr "`macro` が適切なアイテムに"

#: src/decl-macros/macros2.md:51
msgid ""
"Unlike with `macro_rules` macros, which are textually scoped and require "
"`#[macro_export]`(and potentially a re-export) to be treated as an item, "
"`macro` macros behave like proper rust items by default."
msgstr ""
"テキスト上にスコープされ、アイテムとして扱うには `#[macro_export]` (そして潜在"
"的に再エクスポート)が必要となる、 `macro_rules` マクロと異なり、 `macro`マクロ"
"はデフォルトで適切なRustのアイテムのように振る舞います。"

#: src/decl-macros/macros2.md:53
msgid ""
"As such, you can properly qualify them with visibility specifiers like `pub`, "
"`pub(crate)`, `pub(in path)` and the like."
msgstr ""
"そのため、`pub`、`pub(crate)`、`pub(in path)` などの可視性指定子で適切に修飾す"
"ることができます。"

#: src/decl-macros/macros2.md:58
msgid ""
"Hygiene is by far the biggest difference between the two declarative macro "
"systems. Unlike `macro_rules` which have [mixed site hygiene](./minutiae/"
"hygiene.md), `macro` have definition site hygiene, meaning they do not leak "
"identifiers outside of their invocation."
msgstr ""
"ハイジーンは、2つの宣言型マクロシステムの最大の相違点です。[混合サイトハイジー"
"ン](./minutiae/hygiene.md)を持つ `macro_rules` とは異なり、`macro` は定義サイト"
"ハイジーンを持っています。これは識別子を呼び出しの外部に晒さないことを意味しま"
"す。"

#: src/decl-macros/macros2.md:61
msgid ""
"As such the following compiles with a `macro_rules` macro, but fails with a "
"`macro` definition:"
msgstr ""
"そのため以下は、`macro_rules` マクロを使うとコンパイルされますが、`macro` 定義"
"では失敗します:"

#: src/decl-macros/macros2.md:63
msgid ""
"```rust\n"
"#![feature(decl_macro)]\n"
"// try uncommenting the following line, and commenting out the line right "
"after\n"
"\n"
"macro_rules! foo {\n"
"// macro foo {\n"
"    ($name: ident) => {\n"
"        pub struct $name;\n"
"\n"
"        impl $name {\n"
"            pub fn new() -> $name {\n"
"                $name\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foo!(Foo);\n"
"\n"
"fn main() {\n"
"    // this fails with a `macro`, but succeeds with a `macro_rules`\n"
"    let foo = Foo::new();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#![feature(decl_macro)]\n"
"// 下の行のコメントを外し、その直後の行をコメントアウトしてみてください。\n"
"\n"
"macro_rules! foo {\n"
"// macro foo {\n"
"    ($name: ident) => {\n"
"        pub struct $name;\n"
"\n"
"        impl $name {\n"
"            pub fn new() -> $name {\n"
"                $name\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foo!(Foo);\n"
"\n"
"fn main() {\n"
"    // これは `macro` では失敗しますが、`macro_rules` では成功します。\n"
"    let foo = Foo::new();\n"
"}\n"
"```"

#: src/decl-macros/macros2.md:88
msgid ""
"There may be plans to allow escaping hygiene for identifiers(hygiene bending) "
"in the future."
msgstr ""
"今後、識別子のハイジーンのエスケープ(ハイジーンのベンディング)を許可する計画さ"
"れるかもしれません。"

#: src/proc-macros.md:3
#, fuzzy
msgid "Note: This section is still very incomplete!"
msgstr "注: このセクションはまだ非常に不完全です！"

#: src/proc-macros.md:5
#, fuzzy
msgid ""
"This chapter will introduce Rust's second syntax extension type, _procedural "
"macros_."
msgstr ""
"この章では、Rustの2番目の構文拡張タイプである_procedural macros_を紹介します。"

#: src/proc-macros.md:7
#, fuzzy
msgid ""
"As with the [declarative macros](./decl-macros.md) chapter, this one is also "
"split into a [methodical](./proc-macros/methodical.md) and a (WIP) practical "
"subchapter with the former being a more formal introduction and the latter "
"being a more practical oriented one."
msgstr ""
"宣言的マクロ](./decl-macros.md)の章と同様に、この章も[方法論](./proc-macros/"
"methodical.md)と(WIP)実践的な小章に分かれており、前者はより形式的な紹介で、後者"
"はより実践的なものです。"

#: src/proc-macros.md:9
#, fuzzy
msgid ""
"A lot of the basic information covered has been sourced from the [rust "
"reference](https://doc.rust-lang.org/nightly/reference/introduction.html), as "
"most knowledge about procedural macros is currently located there."
msgstr ""
"基本的な情報の多くは、[錆のリファレンス](https://doc.rust-lang.org/nightly/"
"reference/introduction.html) を参照しています。"

#: src/proc-macros/methodical.md:3
#, fuzzy
msgid ""
"This chapter will introduce Rust's procedural macro system by explaining the "
"system as a whole."
msgstr ""
"この章では、Rustの手続き型マクロシステムを紹介し、システム全体を説明します。"

#: src/proc-macros/methodical.md:5
#, fuzzy
msgid ""
"Unlike a [declarative macro](../decl-macros.md), a procedural macro takes the "
"form of a Rust function taking in a token stream(or two) and outputting a "
"token stream."
msgstr ""
"宣言型マクロ](../decl-macros.md)とは異なり、手続き型マクロは、トークンストリー"
"ム(または2つ)を取り込み、トークンストリームを出力するRust関数の形をとります。"

#: src/proc-macros/methodical.md:7
#, fuzzy
msgid ""
"A proc-macro is at its core just a function exported from a crate with the "
"`proc-macro` [crate type](https://doc.rust-lang.org/reference/linkage.html), "
"so when writing multiple proc macros you can have them all live in one crate."
msgstr ""
"proc-macroは、基本的には`proc-macro` [crate type](https://doc.rust-lang.org/"
"reference/linkage.html)を持つcrateからエクスポートされる関数です。複数のprocマ"
"クロを書く場合、それらを1つのcrateにまとめることができます。"

#: src/proc-macros/methodical.md:9
#, fuzzy
msgid ""
"**Note**: When using Cargo, to define a `proc-macro` crate you define and set "
"the `lib.proc-macro` key in the `Cargo.toml` to true."
msgstr ""
"**注意**: Cargo を使用する場合、`proc-macro` クレートを定義するには、`Cargo."
"toml` で `lib.proc-macro` キーを定義して true に設定します。"

#: src/proc-macros/methodical.md:15
#, fuzzy
msgid ""
"A `proc-macro` type crate implicitly links to the compiler-provided "
"[proc_macro](https://doc.rust-lang.org/proc_macro/index.html) crate, which "
"contains all the things you need to get going with developing procedural "
"macros. The two most important types exposed by the crate are the "
"[`TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html), "
"which are the proc-macro variant of the already familiar token trees as well "
"as the [`Span`](https://doc.rust-lang.org/proc_macro/struct.Span.html), which "
"describes a part of source code used primarily for error reporting and "
"hygiene. See the [Hygiene and Spans](./hygiene.md) chapter for more "
"information."
msgstr ""
"proc-macro` 型の木枠はコンパイラが提供する [proc_macro](https://doc.rust-lang."
"org/proc_macro/index.html) 木枠に暗黙的にリンクしています。このクレートによって"
"公開される2つの最も重要な型は、[`TokenStream`](https://doc.rust-lang.org/"
"proc_macro/struct.TokenStream.html)です。これは、すでにおなじみのトークンツリー"
"の proc-macro バリアントであり、[`Span`](https://doc.rust-lang.org/proc_macro/"
"struct.Span.html)は、主にエラーレポートとハイジーンに使用されるソースコードの一"
"部を記述します。詳しくは[Hygiene and Spans](./hygiene.md)の章を参照してくださ"
"い。"

#: src/proc-macros/methodical.md:18
#, fuzzy
msgid ""
"As proc-macros therefore are functions living in a crate, they can be "
"addressed as all the other items in a Rust project. All thats required to add "
"the crate to the dependency graph of a project and bring the desired item into "
"scope."
msgstr ""
"したがって、proc-macrosはクレート内に存在する関数であるため、Rustプロジェクトの"
"他のすべての項目と同様に扱うことができます。必要なのは、プロジェクトの依存関係"
"グラフにクレートを追加し、目的のアイテムをスコープに入れることだけです。"

#: src/proc-macros/methodical.md:21
#, fuzzy
msgid ""
"**Note**: Procedural macros invocations still run at the same stage in the "
"compiler expansion-wise as declarative macros, just that they are standalone "
"Rust programs that the compiler compiles, runs, and finally either replaces or "
"appends to."
msgstr ""
"**注意**: 注***: 手続き型マクロの呼び出しは、宣言型マクロと同じようにコンパイラ"
"の拡張ステージで実行されます。"

#: src/proc-macros/methodical.md:24
#, fuzzy
msgid "Types of procedural macros"
msgstr "手続き型マクロの種類"

#: src/proc-macros/methodical.md:26
#, fuzzy
msgid ""
"With procedural macros, there actually exists 3 different kinds with each "
"having slightly different properties."
msgstr ""
"プロシージャル・マクロには、実際には3つの種類があり、それぞれ少しずつ性質が異な"
"ります。"

#: src/proc-macros/methodical.md:27
#, fuzzy
msgid ""
"_function-like_ proc-macros which are used to implement `$name ! $arg` "
"invocable macros"
msgstr ""
"関数型 proc マクロで、 `$name ！arg` を実装するために使われる proc マクロです。"

#: src/proc-macros/methodical.md:28
#, fuzzy
msgid "_attribute_ proc-macros which are used to implement `#[$arg]` attributes"
msgstr "`#[$arg]` 属性を実装するために使われる _attribute_ proc-macros"

#: src/proc-macros/methodical.md:29
#, fuzzy
msgid ""
"_derive_ proc-macros which are used to implement a derive, an _input_ to a "
"`#[derive(…)]` attribute"
msgstr ""
"deriveを実装するために使用される_derive_ proc-macros、`#[derive(...)]`属性への"
"_input_。"

#: src/proc-macros/methodical.md:31
#, fuzzy
msgid ""
"At their core, all 3 work almost the same with a few differences in their "
"inputs and output reflected by their function definition. As mentioned all a "
"procedural macro really is, is a function that maps a token stream so let's "
"take a quick look at each basic definition and their differences."
msgstr ""
"核となる部分は3つともほとんど同じですが、関数の定義によって入出力に若干の違いが"
"あります。前述したように、手続き型マクロの本質はトークンストリームをマッピング"
"する関数です。"

#: src/proc-macros/methodical.md:34
msgid "_function-like_"
msgstr "_関数型_"

#: src/proc-macros/methodical.md:42
msgid "_attribute_"
msgstr "_アトリビュート_"

#: src/proc-macros/methodical.md:50
#, fuzzy
msgid "_derive_"
msgstr "{cH0000ffff}ありがとう"

#: src/proc-macros/methodical.md:58
#, fuzzy
msgid ""
"As shown, the basic structure is the same for each, a public function marked "
"with an attribute defining its procedural macro type returning a "
"`TokenStream`. Note how the return type is a `TokenStream` and not a result or "
"something else that gives the notion of being fallible. This does not mean "
"that proc-macros cannot fail though, in fact they have two ways of reporting "
"errors, the first one being to panic and the second to emit a [`compile_error!"
"`](https://doc.rust-lang.org/std/macro.compile_error.html) invocation. If a "
"proc-macro panics the compiler will catch it and emit the payload as an error "
"coming from the macro invocation."
msgstr ""
"このように、基本的な構造はそれぞれ同じで、手続き型マクロの型を定義する属性で"
"マークされたパブリック関数が `TokenStream` を返します。戻り値の型が "
"`TokenStream` であり、結果や何か他のものではないことに注意してください。しか"
"し、これは proc マクロが失敗しないという意味ではありません。実際、proc マクロに"
"はエラーを報告する 2 つの方法があり、1 つ目はパニックを起こす方法、2 つ目は "
"[`compile_error!`](https://doc.rust-lang.org/std/macro.compile_error.html) を呼"
"び出す方法です。proc-macro がパニックを起こした場合、コンパイラはそれをキャッチ"
"し、マクロの呼び出しによるエラーとしてペイロードを出します。"

#: src/proc-macros/methodical.md:63
#, fuzzy
msgid ""
"**Beware**: The compiler will happily hang on endless loops spun up inside "
"proc-macros causing the compilation of crates using the proc-macro to hang as "
"well."
msgstr ""
"**注意してください**: 注意**: コンパイラーはプロック・マクロの中で紡ぎ出される"
"無限ループに喜んでハングし、プロック・マクロを使用するクレートのコンパイルもハ"
"ングします。"

#: src/proc-macros/methodical/function-like.md:3
#, fuzzy
msgid ""
"Function-like procedural macros are invoked like declarative macros that is "
"`makro!(…)`."
msgstr "関数型手続き型マクロは、宣言型マクロのように `makro!"

#: src/proc-macros/methodical/function-like.md:5
#, fuzzy
msgid ""
"This type of macro is the simplest of the three though. It is also the only "
"one which you can't differentiate from declarative macros when solely looking "
"at the invocation."
msgstr ""
"しかし、このタイプのマクロは3つの中で最も単純です。また、呼び出しを見ただけでは"
"宣言型マクロと区別できない唯一のものです。"

#: src/proc-macros/methodical/function-like.md:8
#, fuzzy
msgid ""
"A simple skeleton of a function-like procedural macro looks like the following:"
msgstr "関数型手続き型マクロの簡単な骨格は以下のようになります:"

#: src/proc-macros/methodical/function-like.md:18
#, fuzzy
msgid ""
"As one can see this is in fact just a mapping from one [`TokenStream`](https://"
"doc.rust-lang.org/proc_macro/struct.TokenStream.html) to another where the "
"`input` will be the tokens inside of the invocation delimiters, e.g. for an "
"example invocation `foo!(bar)` the input token stream would consist of the "
"`bar` token. The returned token stream will **replace** the macro invocation."
msgstr ""
"これは実際には、ある [`TokenStream`](https://doc.rust-lang.org/proc_macro/"
"struct.TokenStream.html) から別の [`TokenStream`](https://doc.rust-lang.org/"
"proc_macro/struct.TokenStream.html) へのマッピングに過ぎません。`input` は呼び"
"出しの区切り文字の中にあるトークンになります。例えば、`foo!(bar)` という呼び出"
"しの例では、入力トークン ストリームは `bar` トークンで構成されます。返される"
"トークンストリームはマクロを **置き換えます** 。"

#: src/proc-macros/methodical/function-like.md:21
#, fuzzy
msgid ""
"For this macro type the same placement and expansion rules apply as for "
"declarative macros, that is the macro must output a correct token stream for "
"the invocation location. Unlike with declarative macros though, function-like "
"procedural macros do not have certain restrictions imposed on their inputs "
"though. That is the restrictions for what may follow fragment specifiers "
"listed in the [Metavariables and Expansion Redux](../../decl-macros/minutiae/"
"metavar-and-expansion.md) chapter listed is not applicable here, as the "
"procedural macros work on the tokens directly instead of matching them against "
"fragment specifiers or similar."
msgstr ""
"つまり、マクロは呼び出し位置に対して正しいトークンストリームを出力しなければな"
"りません。しかし、宣言型マクロとは異なり、関数型手続きマクロでは、入力に特定の"
"制限が課されることはありません。つまり、[Metavariables and Expansion Redux]"
"(../../decl-macros/minutiae/metavar-and-expansion.md)の章に記載されている、フラ"
"グメント指定子の後に続くものの制限は、ここでは適用されません。"

#: src/proc-macros/methodical/function-like.md:25
#, fuzzy
msgid ""
"With that said it is apparent that the procedural counter part to these macros "
"is more powerful as they can arbitrarily modify their input, and produce any "
"output desired as long as its within the bounds of the language syntax."
msgstr ""
"とはいえ、これらのマクロに対応する手続き的な部分がより強力であることは明らかで"
"す。マクロは入力を任意に変更することができ、言語構文の範囲内であればどんな出力"
"でも出すことができるからです。"

#: src/proc-macros/methodical/function-like.md:29
#: src/proc-macros/methodical/attr.md:26 src/proc-macros/methodical/derive.md:20
#: src/proc-macros/methodical/derive.md:50
#, fuzzy
msgid "Usage example:"
msgstr "使用例"

#: src/proc-macros/methodical/attr.md:3
#, fuzzy
msgid ""
"Attribute procedural macros define new _outer_ attributes which can be "
"attached to items. This type can be invoked with the `#[attr]` or `#[attr(…)]` "
"syntax where `…` is an arbitrary token tree."
msgstr ""
"属性手続きマクロはアイテムに付加できる新しい_outer_属性を定義します。この型は "
"`#[attr]` または `#[attr(...)]` 構文で呼び出すことができます。"

#: src/proc-macros/methodical/attr.md:6
#, fuzzy
msgid ""
"A simple skeleton of an attribute procedural macro looks like the following:"
msgstr "属性プロシージャマクロの簡単なスケルトンは以下のようになります:"

#: src/proc-macros/methodical/attr.md:16
#, fuzzy
msgid ""
"Of note here is that unlike the other two procedural macro kinds, this one has "
"two input parameters instead of one."
msgstr ""
"ここで注目すべきは、他の2種類の手続き型マクロとは異なり、このマクロには入力パラ"
"メーターが1つではなく2つあるということです。"

#: src/proc-macros/methodical/attr.md:17
#, fuzzy
msgid ""
"The first parameter is the delimited token tree following the attribute's "
"name, excluding the delimiters around it. It is empty if the attribute is "
"written bare, that is just a name without a `(TokenTree)` following it, e.g. "
"`#[attr]`."
msgstr ""
"最初のパラメータは、属性名に続く区切られたトークンツリーです。例えば、 "
"`#[attr]`."

#: src/proc-macros/methodical/attr.md:19
#, fuzzy
msgid ""
"The second token stream is the item the attribute is attached to _without_ the "
"attribute this proc macro defines. As this is an [`active`](https://doc.rust-"
"lang.org/reference/attributes.html#active-and-inert-attributes) attribute, the "
"attribute will be stripped from the item before it is being passed to the proc "
"macro."
msgstr ""
"2つ目のトークンストリームは、この proc マクロが定義するアトリビュートを除いた、"
"アトリビュートがアタッチされているアイテムです。これは[`active`](https://doc."
"rust-lang.org/reference/attributes.html#active-and-inert-attributes)属性なの"
"で、属性はprocマクロに渡される前にアイテムから取り除かれます。"

#: src/proc-macros/methodical/attr.md:22
#, fuzzy
msgid ""
"The returned token stream will **replace** the annotated item fully. Note that "
"the replacement does not have to be a single item, it can be 0 or more."
msgstr ""
"返されたトークンストリームは、アノテーションされた項目を完全に **置換** しま"
"す。置換される項目は1つである必要はなく、0個以上でもよいことに注意してくださ"
"い。"

#: src/proc-macros/methodical/derive.md:3
#, fuzzy
msgid ""
"Derive procedural macros define new inputs for the [`derive`](https://doc.rust-"
"lang.org/reference/attributes/derive.html) attribute. This type can be invoked "
"by feeding it to a derive attribute's input, e.g. `#[derive(TlbormDerive)]`."
msgstr ""
"Derive 手続き型マクロは、[`derive`](https://doc.rust-lang.org/reference/"
"attributes/derive.html) 属性の新しい入力を定義します。この型は "
"`#[derive(TlbormDerive)]` のようにderive属性の入力に与えることで呼び出すことが"
"できます。"

#: src/proc-macros/methodical/derive.md:6
#, fuzzy
msgid "A simple skeleton of a derive procedural macro looks like the following:"
msgstr "派生プロシージャマクロの簡単なスケルトンは以下のようになります:"

#: src/proc-macros/methodical/derive.md:16
#, fuzzy
msgid ""
"The `proc_macro_derive` is a bit more special in that it requires an extra "
"identifier, this identifier will become the actual name of the derive proc "
"macro. The input token stream is the item the derive attribute is attached to, "
"that is, it will always be an `enum`, `struct` or `union` as these are the "
"only items a derive attribute can annotate. The returned token stream will be "
"**appended** to the containing block or module of the annotated item with the "
"requirement that the token stream consists of a set of valid items."
msgstr ""
"proc_macro_derive` は少し特殊で、特別な識別子を必要とします。入力されるトークン"
"ストリームは、derive 属性がアタッチされるアイテムです。つまり、derive 属性がア"
"ノテーションできるアイテムは `enum`、`struct`、`union` だけなので、常に "
"`enum`、`struct`、`union` になります。返されたトークンストリームは、アノテー"
"ションされたアイテムのブロックまたはモジュールに **付加** されます。"

#: src/proc-macros/methodical/derive.md:28
#, fuzzy
msgid "Helper Attributes"
msgstr "ヘルパーの属性"

#: src/proc-macros/methodical/derive.md:30
#, fuzzy
msgid ""
"Derive proc macros are a bit more special in that they can add additional "
"attributes visible only in the scope of the item definition. These attributes "
"are called _derive macro helper attributes_ and are [inert](https://doc.rust-"
"lang.org/reference/attributes.html#active-and-inert-attributes). Their purpose "
"is to give derive proc macros additional customizability on a per field or "
"variant basis, that is these attributes can be used to annotate fields or enum "
"variants while having no effect on their own. As they are `inert` they will "
"not be stripped and are visible to all macros."
msgstr ""
"派生 proc マクロは少し特殊で、アイテム定義のスコープでのみ見える属性を追加する"
"ことができます。これらの属性は _derive macro helper attributes_ と呼ばれ、"
"[inert](https://doc.rust-lang.org/reference/attributes.html#active-and-inert-"
"attributes) です。これらの属性の目的は、derive proc マクロにフィールドやバリア"
"ントごとのカスタマイズ性を追加することです。これらの属性は `inert` なので、取り"
"除かれることはなく、すべてのマクロから見ることができます。"

#: src/proc-macros/methodical/derive.md:35
#, fuzzy
msgid ""
"They can be defined by adding an `attributes(helper0, helper1, ..)` argument "
"to the `proc_macro_derive` attribute containing a comma separated list of "
"identifiers which are the names of the helper attributes."
msgstr ""
"これらは `proc_macro_derive` 属性に `attributes(helper0, helper1, ...)` という"
"引数を追加することで定義することができます。"

#: src/proc-macros/methodical/derive.md:37
#, fuzzy
msgid ""
"Thus a simple skeleton of a derive procedural macro with helper attributes "
"looks like the following:"
msgstr ""
"このように、ヘルパー属性を持つderive手続き型マクロの簡単なスケルトンは以下のよ"
"うになります:"

#: src/proc-macros/methodical/derive.md:47
#, fuzzy
msgid ""
"That is all there is to helper attributes, to consume them in the proc macro "
"the implementation will then have to check the attributes of fields and "
"variants to see whether they are attributed with the corresponding helper. It "
"is an error to use a helper attribute if none of the used derive macros of the "
"given item declare it as such, as the compiler will then instead try to "
"resolve it as a normal attribute."
msgstr ""
"proc マクロでヘルパー属性を使うためには、実装はフィールドとバリアントの属性を"
"チェックして、対応するヘルパー属性があるかどうかを確認する必要があります。コン"
"パイラはそれを通常の属性として解決しようとします。"

#: src/proc-macros/third-party-crates.md:3
#, fuzzy
msgid ""
"**Note**: Crates beyond the automatically linked [`proc_macro`](https://doc."
"rust-lang.org/proc_macro/) crate are not required to write procedural macros. "
"The crates listed here merely make writing them simpler and more concise, "
"while potentially adding to the compilation time of the procedural macro due "
"to added dependencies."
msgstr ""
"**注意**: 自動的にリンクされる [`proc_macro`](https://doc.rust-lang.org/"
"proc_macro/) 以外のクレートは、手続き型マクロを書くために必要ではありません。こ"
"こに列挙されたクレートは、手続き型マクロのコンパイル時間を増加させる可能性があ"
"る一方で、手続き型マクロの記述をより単純で簡潔にするだけです。"

#: src/proc-macros/third-party-crates.md:6
#, fuzzy
msgid ""
"As procedural macros live in a crate they can naturally depend on ([crates.io]"
"(https://crates.io/)) crates. turns out the crate ecosystem has some really "
"helpful crates tailored towards procedural macros that this chapter will "
"quickly go over, most of which will be used in the following chapters to "
"implement the example macros. As these are merely quick introductions it is "
"advised to look at each crate's documentation for more in-depth information if "
"required."
msgstr ""
"手続きマクロはクレートの中にあるので、当然([crates.io](https://crates.io/))ク"
"レートに依存することができます。クレートエコシステムには、手続きマクロのために"
"調整された本当に便利なクレートがいくつかあるので、この章では簡単に説明します。"
"これらは単なる簡単な紹介なので、必要であれば、より詳細な情報を得るために各ク"
"レートのドキュメントを見ることをお勧めします。"

#: src/proc-macros/third-party-crates.md:10
#, fuzzy
msgid "[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)"
msgstr "[proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)"

#: src/proc-macros/third-party-crates.md:12
#, fuzzy
msgid ""
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/), the successor of "
"the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate! Or so you "
"might think but that is of course not correct, the name might be a bit "
"misleading. This crate is actually just a wrapper around the [`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/) crate serving two specific purposes, "
"taken from the documentation:"
msgstr ""
"[proc_macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)は、[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)の後継クレートです！と思うかもしれません"
"が、それはもちろん正しくありません。このクレートは実際には[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)クレートのラッパーに過ぎず、ドキュメント"
"から引用した2つの特定の目的を果たします:"

#: src/proc-macros/third-party-crates.md:14
#, fuzzy
msgid ""
"Bring proc-macro-like functionality to other contexts like build.rs and main."
"rs."
msgstr ""
"build.rsやmain.rsのような他のコンテキストにproc-macroのような機能をもたらしま"
"す。"

#: src/proc-macros/third-party-crates.md:15
#, fuzzy
msgid "Make procedural macros unit testable."
msgstr "手続き型マクロをユニットテスト可能に"

#: src/proc-macros/third-party-crates.md:17
#, fuzzy
msgid ""
"As the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate is "
"exclusive to [`proc_macro`](https://doc.rust-lang.org/proc_macro/) type "
"crates, making them unit testable or accessing them from non-proc macro code "
"is next to impossible. With that in mind the [`proc-macro2`](https://docs.rs/"
"proc-macro2/*/proc_macro2/) crate mimics the original [`proc_macro`](https://"
"doc.rust-lang.org/proc_macro/) crate's api, acting as a wrapper in proc-macro "
"crates and standing on its own in non-proc-macro crates. Hence it is advised "
"to build libraries targeting proc-macro code to be built against [`proc-"
"macro2`](https://docs.rs/proc-macro2/*/proc_macro2/) instead as that will "
"enable those libraries to be unit testable, which is also the reason why the "
"following listed crates take and emit [`proc-macro2::TokenStream`](https://"
"docs.rs/proc-macro2/1.0.27/proc_macro2/struct.TokenStream.html)s instead. When "
"a `proc_macro` token stream is required, one can simply `.into()` the `proc-"
"macro2` token stream to get the `proc_macro` version and vice-versa."
msgstr ""
"proc_macro`](https://doc.rust-lang.org/proc_macro/)クレートは[`proc_macro`]"
"(https://doc.rust-lang.org/proc_macro/)タイプのクレートと排他的であるため、それ"
"らをユニットテスト可能にしたり、非procマクロコードからアクセスすることは不可能"
"に近いです。この点を考慮して、[`proc-macro2`](https://docs.rs/proc-macro2/*/"
"proc_macro2/) クレートはオリジナルの [`proc_macro`](https://doc.rust-lang.org/"
"proc_macro/) クレートの API を模倣し、proc-macro クレートではラッパーとして動作"
"し、proc-macro 以外のクレートでは単独で動作します。したがって、proc-macro コー"
"ドをターゲットにしたライブラリは、[`proc-macro2`](https://docs.rs/proc-macro2/"
"*/proc_macro2/) に対してビルドすることをお勧めします。proc_macro` のトークンス"
"トリームが必要な場合、単純に `proc-macro2` のトークンストリームを `.into()` し"
"て `proc_macro` バージョンを取得することができます。"

#: src/proc-macros/third-party-crates.md:22
#, fuzzy
msgid ""
"Procedural macros using the `proc-macro2` crate will usually import the `proc-"
"macro2::TokenStream` in an aliased form like `use proc-macro2::TokenStream as "
"TokenStream2`."
msgstr ""
"proc-macro2` クレートを使用する手続き型マクロは、通常 `proc-macro2::"
"TokenStream` を `use proc-macro2::TokenStream as TokenStream2` のようなエイリア"
"ス形式でインポートします。"

#: src/proc-macros/third-party-crates.md:24
#, fuzzy
msgid "[`quote`](https://docs.rs/quote/*/quote/)"
msgstr "[`quote`](https://docs.rs/quote/*/quote/)"

#: src/proc-macros/third-party-crates.md:26
#, fuzzy
msgid ""
"The [`quote`](https://docs.rs/quote/*/quote/) crate mainly exposes just one "
"macro, the [`quote!`](https://docs.rs/quote/1/quote/macro.quote.html) macro."
msgstr ""
"quote`](https://docs.rs/quote/*/quote/)クレートは主に1つのマクロ、[`quote!`]"
"(https://docs.rs/quote/1/quote/macro.quote.html)マクロだけを公開します。"

#: src/proc-macros/third-party-crates.md:28
#, fuzzy
msgid ""
"This little macro allows you to easily create token streams by writing the "
"actual source out as syntax while also giving you the power of interpolating "
"tokens right into the written syntax. [Interpolation](https://docs.rs/quote/1/"
"quote/macro.quote.html#interpolation) can be done by using the `#local` syntax "
"where local refers to a local in the current scope. Likewise `#( #local )*` "
"can be used to interpolate over an iterator of types that implement "
"[`ToTokens`](https://docs.rs/quote/1/quote/trait.ToTokens.html), this works "
"similar to declarative `macro_rules!` repetitions in that they allow a "
"separator as well as extra tokens inside the repetition."
msgstr ""
"この小さなマクロを使うと、実際のソースを構文として書き出すことでトークン スト"
"リームを簡単に作成することができます。[補間](https://docs.rs/quote/1/quote/"
"macro.quote.html#interpolation) は `#local` 構文を使うことで行えます。local は"
"現在のスコープ内の local を指します。同様に `#( #local )*` を使うと、"
"[`ToTokens`](https://docs.rs/quote/1/quote/trait.ToTokens.html) を実装している"
"型のイテレータを補間することができます。これは宣言的な `macro_rules!` の繰り返"
"しに似ていて、繰り返しの中に余分なトークンだけでなくセパレータを置くことができ"
"ます。"

#: src/proc-macros/third-party-crates.md:32
#, fuzzy
msgid ""
"```rs\n"
"let name = /* some identifier */;\n"
"let exprs = /* an iterator over expressions tokenstreams */;\n"
"let expanded = quote! {\n"
"    impl SomeTrait for #name { // #name interpolates the name local from "
"above\n"
"        fn some_function(&self) -> usize {\n"
"            #( #exprs )* // #name interpolates exprs by iterating the "
"iterator\n"
"        }\n"
"    }\n"
"};\n"
"```"
msgstr ""
"``rs\n"
"let name = /* ある識別子 */; \n"
"let exprs = /* 式のトークンストリームに対するイテレータ */; \n"
"let expanded = quote！{\n"
"    impl SomeTrait for #name { // #nameは上記のローカルな名前を補間します。\n"
"        fn some_function(&self) -> usize { #( #exprs )* *; let expanded = "
"quote!\n"
"            #( #exprs )* // #nameはイテレータを反復することでexprsを補間しま"
"す。\n"
"        }\n"
"    }\n"
"};\n"
"```"

#: src/proc-macros/third-party-crates.md:44
#, fuzzy
msgid ""
"This a very useful tool when preparing macro output avoiding the need of "
"creating a token stream by inserting tokens one by one."
msgstr ""
"これは、トークンを1つずつ挿入してトークンストリームを作成する必要をなくし、マク"
"ロ出力を準備する際に非常に便利なツールです。"

#: src/proc-macros/third-party-crates.md:46
#, fuzzy
msgid ""
"**Note**: As stated earlier, this crate makes use of `proc_macro2` and thus "
"the `quote!` macro returns a `proc-macro2::TokenStream`."
msgstr ""
"**注意**: 前述したように、この木枠は `proc_macro2` を使用しているので、 `quote!"
"` マクロは `proc-macro2::TokenStream` を返します。"

#: src/proc-macros/third-party-crates.md:48
#, fuzzy
msgid "[`syn`](https://docs.rs/syn/*/syn/)"
msgstr "(https://docs.rs/syn/*/syn/)"

#: src/proc-macros/third-party-crates.md:50
#, fuzzy
msgid ""
"The [`syn`](https://docs.rs/syn/*/syn/) crate is a parsing library for parsing "
"a stream of Rust tokens into a syntax tree of Rust source code. It is a very "
"powerful library that makes parsing proc-macro input quite a bit easier, as "
"the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate itself does "
"not expose any kind of parsing capabilities, merely the tokens. As the library "
"can be a heavy compilation dependency, it makes heavy use of feature gates to "
"allow users to cut it as small as required."
msgstr ""
"syn`](https://docs.rs/syn/*/syn/)クレートは、RustトークンのストリームをRustソー"
"スコードの構文木にパースするためのパースライブラリです。proc_macro`](https://"
"doc.rust-lang.org/proc_macro/) クレート自身は構文解析機能を公開せず、単にトーク"
"ンを公開するだけなので、proc-macro 入力の構文解析を非常に簡単にする非常に強力な"
"ライブラリです。このライブラリはコンパイル依存性が高いので、ユーザが必要な分だ"
"け小さくできるようにフィーチャーゲートを多用しています。"

#: src/proc-macros/third-party-crates.md:54
#, fuzzy
msgid "So what does it offer? A bunch of things."
msgstr "それで、何を提供してくれるのですか？いろいろあります。"

#: src/proc-macros/third-party-crates.md:56
#, fuzzy
msgid ""
"First of all it has definitions and parsing for all standard Rust syntax "
"nodes(when the `full` feature is enabled), as well as a [`DeriveInput`]"
"(https://docs.rs/syn/1/syn/struct.DeriveInput.html) type which encapsulates "
"all the information a derive macro gets passed as an input stream as a "
"structured input(requires the `derive` feature, enabled by default). These can "
"be used right out of the box with the [`parse_macro_input!`](https://docs.rs/"
"syn/1/syn/macro.parse_macro_input.html) macro(requires the `parsing` and `proc-"
"macro` features, enabled by default) to parse token streams into these types."
msgstr ""
"また、[`DeriveInput`](https://docs.rs/syn/1/syn/struct.DeriveInput.html)型は、"
"deriveマクロが入力ストリームとして渡されるすべての情報を構造化入力としてカプセ"
"ル化します(`derive`機能が必要で、デフォルトで有効になっています)。これらの型"
"は、[`parse_macro_input!`](https://docs.rs/syn/1/syn/macro.parse_macro_input."
"html) マクロ(`parsing` と `proc-macro` 機能が必要です。デフォルトで有効になって"
"います)を使用して、トークン・ストリームをこれらの型にパースすることができます。"

#: src/proc-macros/third-party-crates.md:58
#, fuzzy
msgid ""
"If Rust syntax doesn't cut it, and instead one wishes to parse custom non-Rust "
"syntax the crate also offers a generic [parsing API](https://docs.rs/syn/1/syn/"
"parse/index.html), mainly in the form of the [`Parse`](https://docs.rs/syn/1/"
"syn/parse/trait.Parse.html) trait(requires the `parsing` feature, enabled by "
"default)."
msgstr ""
"Rust の構文では不十分で、Rust 以外のカスタム構文をパースしたい場合、このクレー"
"トは汎用的な [パース API](https://docs.rs/syn/1/syn/parse/index.html) も提供し"
"ます。"

#: src/proc-macros/third-party-crates.md:60
#, fuzzy
msgid ""
"Aside from this the types exposed by the library keep location information and "
"spans which allows procedural macros to emit detailed error messages pointing "
"at the macro input at the points of interest."
msgstr ""
"これとは別に、ライブラリによって公開される型は、位置情報とスパンを保持します。"
"これにより、手続き型マクロは、関心のあるポイントでマクロ入力を指し示す詳細なエ"
"ラーメッセージを発することができます。"

#: src/proc-macros/third-party-crates.md:62
#, fuzzy
msgid ""
"As this is again a library for procedural macros, it makes use of the "
"`proc_macro2` token streams and spans and as such, conversions may be required."
msgstr ""
"このライブラリも手続き型マクロのライブラリなので、 `proc_macro2` トークン・スト"
"リームとスパンを使用します。"

#: src/proc-macros/hygiene.md:3
#, fuzzy
msgid ""
"This chapter talks about procedural macro [hygiene](../syntax-extensions/"
"hygiene.md) and the type that encodes it, [`Span`](https://doc.rust-lang.org/"
"proc_macro/struct.Span.html)."
msgstr ""
"この章では、手続き型マクロ[hygiene](../syntax-extensions/hygiene.md)と、それを"
"エンコードする型である[`Span`](https://doc.rust-lang.org/proc_macro/struct."
"Span.html)について説明します。"

#: src/proc-macros/hygiene.md:5
#, fuzzy
msgid ""
"Every token in a [`TokenStream`](https://doc.rust-lang.org/proc_macro/struct."
"TokenStream.html) has an associated `Span` holding some additional info. A "
"span, as its documentation states, is `A region of source code, along with "
"macro expansion information`. It points into a region of the original source "
"code(important for displaying diagnostics at the correct places) as well as "
"holding the kind of _hygiene_ for this location. The hygiene is relevant "
"mainly for identifiers, as it allows or forbids the identifier from "
"referencing things or being referenced by things defined outside of the "
"invocation."
msgstr ""
"TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html)内の"
"すべてのトークンは、いくつかの追加情報を保持する `Span` に関連付けられていま"
"す。スパンとは、そのドキュメントにあるように、「マクロ展開情報とともに、ソース"
"コードの一領域」です。これは、元のソースコードの領域を指し示すだけでなく(正しい"
"場所に診断を表示するために重要です)、この場所の_hygiene_の種類を保持します。"
"hygieneは主に識別子に関係し、識別子がものを参照したり、呼び出しの外で定義された"
"ものから参照されることを許可または禁止します。"

#: src/proc-macros/hygiene.md:10
#, fuzzy
msgid ""
"There are 3 kinds of hygiene(which can be seen by the constructors of the "
"`Span` type):"
msgstr "Span`型のコンストラクタで見ることができます）:"

#: src/proc-macros/hygiene.md:11
#, fuzzy
msgid ""
"[`definition site`](https://doc.rust-lang.org/proc_macro/struct.Span."
"html#method.def_site)(_**unstable**_): A span that resolves at the macro "
"definition site. Identifiers with this span will not be able to reference "
"things defined outside or be referenced by things outside of the invocation. "
"This is what one would call \"hygienic\"."
msgstr ""
"[定義サイト`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"def_site)(_**unstable***_): マクロ定義サイトで解決するスパンです。このスパンを"
"持つ識別子は、外部で定義されたものを参照したり、呼び出しの外部で定義されたもの"
"から参照されたりすることはできません。これは「衛生的」と呼ばれるものです。"

#: src/proc-macros/hygiene.md:12
#, fuzzy
msgid ""
"[`mixed site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"mixed_site): A span that has the same hygiene as `macro_rules` declarative "
"macros, that is it may resolve to definition site or call site depending on "
"the type of identifier. See [here](../decl-macros/minutiae/hygiene.md) for "
"more information."
msgstr ""
"[`mixed site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"mixed_site): 宣言型マクロ `macro_rules` と同じhygieneを持つスパンです。詳細は"
"[ここ](../decl-macros/minutiae/hygiene.md)を参照してください。"

#: src/proc-macros/hygiene.md:13
#, fuzzy
msgid ""
"[`call site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"call_site): A span that resolves to the invocation site. Identifiers in this "
"case will behave as if written directly at the call site, that is they freely "
"resolve to things defined outside of the invocation and can be referenced from "
"the outside as well. This is what one would call \"unhygienic\"."
msgstr ""
"[呼び出しサイト`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method."
"call_site): 呼び出しサイトを解決するスパンです。つまり、呼び出しの外部で定義さ"
"れたものを自由に解決し、外部からも参照することができます。これは \"非衛生的 "
"\"と呼ばれるものです。"

#: src/glossary.md:3
#, fuzzy
msgid ""
"A place for obscure words and their descriptions. If you feel like there is an "
"important word missing here, please open an [issue](https://github.com/Veykril/"
"tlborm/issues/new) or a pull request."
msgstr ""
"曖昧な単語とその説明のための場所です。重要な単語がここにないと感じたら、[issue]"
"(https://github.com/Veykril/tlborm/issues/new) または pull request を開いてくだ"
"さい。"

#: src/glossary.md:6
#, fuzzy
msgid "Function-like macro"
msgstr "関数型マクロ"

#: src/glossary.md:7
#, fuzzy
msgid ""
"A function like macro describes a syntax extension that can be invoked via the "
"form `identifier!(...)`. It is called this way due to its resemblance of a "
"function call."
msgstr ""
"マクロのような関数は、`identifier!(...)`という形式で呼び出すことができる構文の"
"拡張を記述します。関数の呼び出しに似ていることから、このように呼ばれています。"

#: src/glossary.md:10
#, fuzzy
msgid "Syntax Extension"
msgstr "構文拡張"

#: src/glossary.md:11
#, fuzzy
msgid "The mechanism Rust's `macro_rules!` and procedural macros are built on."
msgstr ""
"Rustの `macro_rules!` と手続き型マクロは、このメカニズムに基づいています。"

#~ msgid ""
#~ "```text\n"
#~ "┌─────────┐   ┌─────────┐\n"
#~ "│ BinOp   │ ┌╴│ LitInt  │\n"
#~ "│ op: Add │ │ │ val: 1  │\n"
#~ "│ lhs: ◌  │╶┘ └─────────┘\n"
#~ "│ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "└─────────┘ └╴│ LitInt  │\n"
#~ "              │ val: 2  │\n"
#~ "              └─────────┘\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "┌─────────┐   ┌─────────┐\n"
#~ "│ BinOp   │ ┌╴│ LitInt  │\n"
#~ "│ op: Add │ │ │ val: 1  │\n"
#~ "│ lhs: ◌  │╶┘ └─────────┘\n"
#~ "│ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "└─────────┘ └╴│ LitInt  │\n"
#~ "              │ val: 2  │\n"
#~ "              └─────────┘\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "a + b + (c + d[0]) + e\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "a + b + (c + d[0]) + e\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "«a» «+» «b» «+» «(   )» «+» «e»\n"
#~ "          ╭────────┴──────────╮\n"
#~ "           «c» «+» «d» «[   ]»\n"
#~ "                        ╭─┴─╮\n"
#~ "                         «0»\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "«a» «+» «b» «+» «(   )» «+» «e»\n"
#~ "          ╭────────┴──────────╮\n"
#~ "           «c» «+» «d» «[   ]»\n"
#~ "                        ╭─┴─╮\n"
#~ "                         «0»\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "                                          ┌─────────┐\n"
#~ "                                          │ BinOp   │\n"
#~ "                                          │ op: Add │\n"
#~ "                                        ┌╴│ lhs: ◌  │\n"
#~ "                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n"
#~ "                            │ op: Add │                 │ name: e │\n"
#~ "                          ┌╴│ lhs: ◌  │                 └─────────┘\n"
#~ "┌─────────┐   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "│ Var     │╶┐ │ BinOp   │╶┘ └─────────┘ └╴│ BinOp   │\n"
#~ "│ name: a │ │ │ op: Add │                 │ op: Add │\n"
#~ "└─────────┘ └╴│ lhs: ◌  │               ┌╴│ lhs: ◌  │\n"
#~ "┌─────────┐ ┌╴│ rhs: ◌  │   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "│ Var     │╶┘ └─────────┘   │ Var     │╶┘ └─────────┘ └╴│ Index   │\n"
#~ "│ name: b │                 │ name: c │               ┌╴│ arr: ◌  │\n"
#~ "└─────────┘                 └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐\n"
#~ "                                          │ Var     │╶┘ └─────────┘ │\n"
#~ "                                          │ name: d │   ┌─────────┐ │\n"
#~ "                                          └─────────┘   │ LitInt  │╶┘\n"
#~ "                                                        │ val: 0  │\n"
#~ "                                                        └─────────┘\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "                                          ┌─────────┐\n"
#~ "                                          │ BinOp   │\n"
#~ "                                          │ op: Add │\n"
#~ "                                        ┌╴│ lhs: ◌  │\n"
#~ "                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n"
#~ "                            │ op: Add │                 │ name: e │\n"
#~ "                          ┌╴│ lhs: ◌  │                 └─────────┘\n"
#~ "┌─────────┐   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "│ Var     │╶┐ │ BinOp   │╶┘ └─────────┘ └╴│ BinOp   │\n"
#~ "│ name: a │ │ │ op: Add │                 │ op: Add │\n"
#~ "└─────────┘ └╴│ lhs: ◌  │               ┌╴│ lhs: ◌  │\n"
#~ "┌─────────┐ ┌╴│ rhs: ◌  │   ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "│ Var     │╶┘ └─────────┘   │ Var     │╶┘ └─────────┘ └╴│ Index   │\n"
#~ "│ name: b │                 │ name: c │               ┌╴│ arr: ◌  │\n"
#~ "└─────────┘                 └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐\n"
#~ "                                          │ Var     │╶┘ └─────────┘ │\n"
#~ "                                          │ name: d │   ┌─────────┐ │\n"
#~ "                                          └─────────┘   │ LitInt  │╶┘\n"
#~ "                                                        │ val: 0  │\n"
#~ "                                                        └─────────┘\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "bitflags! ⬚\n"
#~ "\n"
#~ "lazy_static! ⬚\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let colors = vec! ⬚;\n"
#~ "    println! ⬚;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "bitflags! ⬚\n"
#~ "\n"
#~ "lazy_static! ⬚\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let colors = vec! ⬚;\n"
#~ "    println! ⬚;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let eight = 2 * four!();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let eight = 2 * four!();\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "┌─────────────┐\n"
#~ "│ Let         │\n"
#~ "│ name: eight │   ┌─────────┐\n"
#~ "│ init: ◌     │╶─╴│ BinOp   │\n"
#~ "└─────────────┘   │ op: Mul │\n"
#~ "                ┌╴│ lhs: ◌  │\n"
#~ "     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐\n"
#~ "     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │\n"
#~ "     │ val: 2 │                 │ name: four │\n"
#~ "     └────────┘                 │ body: ()   │\n"
#~ "                                └────────────┘\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "┌─────────────┐\n"
#~ "│ Let         │\n"
#~ "│ name: eight │   ┌─────────┐\n"
#~ "│ init: ◌     │╶─╴│ BinOp   │\n"
#~ "└─────────────┘   │ op: Mul │\n"
#~ "                ┌╴│ lhs: ◌  │\n"
#~ "     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐\n"
#~ "     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │\n"
#~ "     │ val: 2 │                 │ name: four │\n"
#~ "     └────────┘                 │ body: ()   │\n"
#~ "                                └────────────┘\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "┌─────────────┐\n"
#~ "│ Let         │\n"
#~ "│ name: eight │   ┌─────────┐\n"
#~ "│ init: ◌     │╶─╴│ BinOp   │\n"
#~ "└─────────────┘   │ op: Mul │\n"
#~ "                ┌╴│ lhs: ◌  │\n"
#~ "     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n"
#~ "     │ val: 2 │                 │ op: Add │\n"
#~ "     └────────┘               ┌╴│ lhs: ◌  │\n"
#~ "                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n"
#~ "                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n"
#~ "                   │ val: 1 │                 │ val: 3 │\n"
#~ "                   └────────┘                 └────────┘\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "┌─────────────┐\n"
#~ "│ Let         │\n"
#~ "│ name: eight │   ┌─────────┐\n"
#~ "│ init: ◌     │╶─╴│ BinOp   │\n"
#~ "└─────────────┘   │ op: Mul │\n"
#~ "                ┌╴│ lhs: ◌  │\n"
#~ "     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n"
#~ "     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n"
#~ "     │ val: 2 │                 │ op: Add │\n"
#~ "     └────────┘               ┌╴│ lhs: ◌  │\n"
#~ "                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n"
#~ "                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n"
#~ "                   │ val: 1 │                 │ val: 3 │\n"
#~ "                   └────────┘                 └────────┘\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let eight = 2 * (1 + 3);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let eight = 2 * (1 + 3);\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let x = four!();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let x = four!();\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let x = 1 + three!();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let x = 1 + three!();\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let x = 1 + 3;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let x = 1 + 3;\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "make_local!();\n"
#~ "assert_eq!(local, 0);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "make_local!();\n"
#~ "assert_eq!(local, 0);\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let mut local = 0;\n"
#~ "use_local!();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let mut local = 0;\n"
#~ "use_local!();\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "rustc +nightly -Zunpretty=expanded hello.rs\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "rustc +nightly -Zunpretty=expanded hello.rs\n"
#~ "```"

#~ msgid ""
#~ "```ignore\n"
#~ "    ($matcher) => {$expansion}\n"
#~ "```"
#~ msgstr ""
#~ "```ignore\n"
#~ "    ($matcher) => {$expansion}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! four {\n"
#~ "    () => { 1 + 3 };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! four {\n"
#~ "    () => { 1 + 3 };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! one_expression {\n"
#~ "    ($e:expr) => {...};\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! one_expression {\n"
#~ "    ($e:expr) => {...};\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! times_five {\n"
#~ "    ($e:expr) => { 5 * $e };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! times_five {\n"
#~ "    ($e:expr) => { 5 * $e };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! multiply_add {\n"
#~ "    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! multiply_add {\n"
#~ "    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! discard {\n"
#~ "    ($e:expr) => {};\n"
#~ "}\n"
#~ "macro_rules! repeat {\n"
#~ "    ($e:expr) => { $e; $e; $e; };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! discard {\n"
#~ "    ($e:expr) => {};\n"
#~ "}\n"
#~ "macro_rules! repeat {\n"
#~ "    ($e:expr) => { $e; $e; $e; };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! repeat_two {\n"
#~ "    ($($i:ident)*, $($i2:ident)*) => {\n"
#~ "        $( let $i: (); let $i2: (); )*\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "repeat_two!( a b c d e f, u v w x y z );\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! repeat_two {\n"
#~ "    ($($i:ident)*, $($i2:ident)*) => {\n"
#~ "        $( let $i: (); let $i2: (); )*\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "repeat_two!( a b c d e f, u v w x y z );\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "# macro_rules! repeat_two {\n"
#~ "#     ($($i:ident)*, $($i2:ident)*) => {\n"
#~ "#         $( let $i: (); let $i2: (); )*\n"
#~ "#     }\n"
#~ "# }\n"
#~ "\n"
#~ "repeat_two!( a b c d e f, x y z );\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "# macro_rules! repeat_two {\n"
#~ "#     ($($i:ident)*, $($i2:ident)*) => {\n"
#~ "#         $( let $i: (); let $i2: (); )*\n"
#~ "#     }\n"
#~ "# }\n"
#~ "\n"
#~ "repeat_two!( a b c d e f, x y z );\n"
#~ "```"

#~ msgid ""
#~ "```\n"
#~ "error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times\n"
#~ " --> src/main.rs:6:10\n"
#~ "  |\n"
#~ "6 |         $( let $i: (); let $i2: (); )*\n"
#~ "  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times\n"
#~ " --> src/main.rs:6:10\n"
#~ "  |\n"
#~ "6 |         $( let $i: (); let $i2: (); )*\n"
#~ "  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! recurrence {\n"
#~ "    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ };\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! recurrence {\n"
#~ "    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ };\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let fib = {\n"
#~ "    struct Recurrence {\n"
#~ "        mem: [u64; 2],\n"
#~ "        pos: usize,\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let fib = {\n"
#~ "    struct Recurrence {\n"
#~ "        mem: [u64; 2],\n"
#~ "        pos: usize,\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "    impl Iterator for Recurrence {\n"
#~ "        type Item = u64;\n"
#~ "\n"
#~ "        fn next(&mut self) -> Option<Self::Item> {\n"
#~ "            if self.pos < 2 {\n"
#~ "                let next_val = self.mem[self.pos];\n"
#~ "                self.pos += 1;\n"
#~ "                Some(next_val)\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "    impl Iterator for Recurrence {\n"
#~ "        type Item = u64;\n"
#~ "\n"
#~ "        fn next(&mut self) -> Option<Self::Item> {\n"
#~ "            if self.pos < 2 {\n"
#~ "                let next_val = self.mem[self.pos];\n"
#~ "                self.pos += 1;\n"
#~ "                Some(next_val)\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "            } else {\n"
#~ "                let a = /* something */;\n"
#~ "                let n = self.pos;\n"
#~ "                let next_val = a[n-2] + a[n-1];\n"
#~ "\n"
#~ "                self.mem.TODO_shuffle_down_and_append(next_val);\n"
#~ "\n"
#~ "                self.pos += 1;\n"
#~ "                Some(next_val)\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "            } else {\n"
#~ "                let a = /* something */;\n"
#~ "                let n = self.pos;\n"
#~ "                let next_val = a[n-2] + a[n-1];\n"
#~ "\n"
#~ "                self.mem.TODO_shuffle_down_and_append(next_val);\n"
#~ "\n"
#~ "                self.pos += 1;\n"
#~ "                Some(next_val)\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct IndexOffset<'a> {\n"
#~ "    slice: &'a [u64; 2],\n"
#~ "    offset: usize,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Index<usize> for IndexOffset<'a> {\n"
#~ "    type Output = u64;\n"
#~ "\n"
#~ "    fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
#~ "        use std::num::Wrapping;\n"
#~ "\n"
#~ "        let index = Wrapping(index);\n"
#~ "        let offset = Wrapping(self.offset);\n"
#~ "        let window = Wrapping(2);\n"
#~ "\n"
#~ "        let real_index = index - offset + window;\n"
#~ "        &self.slice[real_index.0]\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct IndexOffset<'a> {\n"
#~ "    slice: &'a [u64; 2],\n"
#~ "    offset: usize,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Index<usize> for IndexOffset<'a> {\n"
#~ "    type Output = u64;\n"
#~ "\n"
#~ "    fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
#~ "        use std::num::Wrapping;\n"
#~ "\n"
#~ "        let index = Wrapping(index);\n"
#~ "        let offset = Wrapping(self.offset);\n"
#~ "        let window = Wrapping(2);\n"
#~ "\n"
#~ "        let real_index = index - offset + window;\n"
#~ "        &self.slice[real_index.0]\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let a = IndexOffset { slice: &self.mem, offset: n };\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let a = IndexOffset { slice: &self.mem, offset: n };\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "{\n"
#~ "    use std::mem::swap;\n"
#~ "\n"
#~ "    let mut swap_tmp = next_val;\n"
#~ "    for i in (0..2).rev() {\n"
#~ "        swap(&mut swap_tmp, &mut self.mem[i]);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "{\n"
#~ "    use std::mem::swap;\n"
#~ "\n"
#~ "    let mut swap_tmp = next_val;\n"
#~ "    for i in (0..2).rev() {\n"
#~ "        swap(&mut swap_tmp, &mut self.mem[i]);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "0\n"
#~ "1\n"
#~ "1\n"
#~ "2\n"
#~ "3\n"
#~ "5\n"
#~ "8\n"
#~ "13\n"
#~ "21\n"
#~ "34\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "0\n"
#~ "1\n"
#~ "1\n"
#~ "2\n"
#~ "3\n"
#~ "5\n"
#~ "8\n"
#~ "13\n"
#~ "21\n"
#~ "34\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "error: local ambiguity: multiple parsing options: built-in NTs expr "
#~ "('inits') or 1 other option.\n"
#~ "  --> src/main.rs:75:45\n"
#~ "   |\n"
#~ "75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
#~ "   |\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "error: local ambiguity: multiple parsing options: built-in NTs expr "
#~ "('inits') or 1 other option.\n"
#~ "  --> src/main.rs:75:45\n"
#~ "   |\n"
#~ "75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
#~ "   |\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! count_exprs {\n"
#~ "    /* ??? */\n"
#~ "#     () => {}\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! count_exprs {\n"
#~ "    /* ??? */\n"
#~ "#     () => {}\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:68:50\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                  ^ not found in this "
#~ "scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `n` in this scope\n"
#~ "  --> src/main.rs:68:52\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                    ^ not found in this "
#~ "scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:68:59\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                           ^ not found "
#~ "in this scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `n` in this scope\n"
#~ "  --> src/main.rs:68:61\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                             ^ not "
#~ "found in this scope\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:68:50\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                  ^ not found in this "
#~ "scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `n` in this scope\n"
#~ "  --> src/main.rs:68:52\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                    ^ not found in this "
#~ "scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:68:59\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                           ^ not found "
#~ "in this scope\n"
#~ "\n"
#~ "error[E0425]: cannot find value `n` in this scope\n"
#~ "  --> src/main.rs:68:61\n"
#~ "   |\n"
#~ "68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
#~ "   |                                                             ^ not "
#~ "found in this scope\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "$ rustc +nightly -Zunpretty=expanded recurrence.rs\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "$ rustc +nightly -Zunpretty=expanded recurrence.rs\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! using_a {\n"
#~ "    ($e:expr) => {\n"
#~ "        {\n"
#~ "            let a = 42;\n"
#~ "            $e\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "let four = using_a!(a / 10);\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! using_a {\n"
#~ "    ($e:expr) => {\n"
#~ "        {\n"
#~ "            let a = 42;\n"
#~ "            $e\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "let four = using_a!(a / 10);\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "1\n"
#~ "1\n"
#~ "2\n"
#~ "6\n"
#~ "24\n"
#~ "120\n"
#~ "720\n"
#~ "5040\n"
#~ "40320\n"
#~ "362880\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "1\n"
#~ "1\n"
#~ "2\n"
#~ "6\n"
#~ "24\n"
#~ "120\n"
#~ "720\n"
#~ "5040\n"
#~ "40320\n"
#~ "362880\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! blocks {\n"
#~ "    ($($block:block)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "blocks! {\n"
#~ "    {}\n"
#~ "    {\n"
#~ "        let zig;\n"
#~ "    }\n"
#~ "    { 2 }\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! blocks {\n"
#~ "    ($($block:block)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "blocks! {\n"
#~ "    {}\n"
#~ "    {\n"
#~ "        let zig;\n"
#~ "    }\n"
#~ "    { 2 }\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! items {\n"
#~ "    ($($item:item)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "items! {\n"
#~ "    struct Foo;\n"
#~ "    enum Bar {\n"
#~ "        Baz\n"
#~ "    }\n"
#~ "    impl Foo {}\n"
#~ "    pub use crate::foo;\n"
#~ "    /*...*/\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! items {\n"
#~ "    ($($item:item)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "items! {\n"
#~ "    struct Foo;\n"
#~ "    enum Bar {\n"
#~ "        Baz\n"
#~ "    }\n"
#~ "    impl Foo {}\n"
#~ "    pub use crate::foo;\n"
#~ "    /*...*/\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! lifetimes {\n"
#~ "    ($($lifetime:lifetime)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "lifetimes! {\n"
#~ "    'static\n"
#~ "    'shiv\n"
#~ "    '_\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! lifetimes {\n"
#~ "    ($($lifetime:lifetime)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "lifetimes! {\n"
#~ "    'static\n"
#~ "    'shiv\n"
#~ "    '_\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! paths {\n"
#~ "    ($($path:path)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "paths! {\n"
#~ "    ASimplePath\n"
#~ "    ::A::B::C::D\n"
#~ "    G::<eneri>::C\n"
#~ "    FnMut(u32) -> ()\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! paths {\n"
#~ "    ($($path:path)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "paths! {\n"
#~ "    ASimplePath\n"
#~ "    ::A::B::C::D\n"
#~ "    G::<eneri>::C\n"
#~ "    FnMut(u32) -> ()\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! statements {\n"
#~ "    ($($stmt:stmt)*) => ($($stmt)*);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    statements! {\n"
#~ "        struct Foo;\n"
#~ "        fn foo() {}\n"
#~ "        let zig = 3\n"
#~ "        let zig = 3;\n"
#~ "        3\n"
#~ "        3;\n"
#~ "        if true {} else {}\n"
#~ "        {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "macro_rules! statements {\n"
#~ "    ($($stmt:stmt)*) => ($($stmt)*);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    statements! {\n"
#~ "        struct Foo;\n"
#~ "        fn foo() {}\n"
#~ "        let zig = 3\n"
#~ "        let zig = 3;\n"
#~ "        3\n"
#~ "        3;\n"
#~ "        if true {} else {}\n"
#~ "        {}\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "/* snip */\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    struct Foo;\n"
#~ "    fn foo() { }\n"
#~ "    let zig = 3;\n"
#~ "    let zig = 3;\n"
#~ "    ;\n"
#~ "    3;\n"
#~ "    3;\n"
#~ "    ;\n"
#~ "    if true { } else { }\n"
#~ "    { }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "/* snip */\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    struct Foo;\n"
#~ "    fn foo() { }\n"
#~ "    let zig = 3;\n"
#~ "    let zig = 3;\n"
#~ "    ;\n"
#~ "    3;\n"
#~ "    3;\n"
#~ "    ;\n"
#~ "    if true { } else { }\n"
#~ "    { }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! types {\n"
#~ "    ($($type:ty)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "types! {\n"
#~ "    foo::bar\n"
#~ "    bool\n"
#~ "    [u8]\n"
#~ "    impl IntoIterator<Item = u32>\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! types {\n"
#~ "    ($($type:ty)*) => ();\n"
#~ "}\n"
#~ "\n"
#~ "types! {\n"
#~ "    foo::bar\n"
#~ "    bool\n"
#~ "    [u8]\n"
#~ "    impl IntoIterator<Item = u32>\n"
#~ "}\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```ignore\n"
#~ "macro_rules! dead_rule {\n"
#~ "    ($e:expr) => { ... };\n"
#~ "    ($i:ident +) => { ... };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ignore\n"
#~ "macro_rules! dead_rule {\n"
#~ "    ($e:expr) => { ... };\n"
#~ "    ($i:ident +) => { ... };\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "got an identifier\n"
#~ "got an addition\n"
#~ "got something else\n"
#~ "\n"
#~ "got something else\n"
#~ "got something else\n"
#~ "got something else\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "got an identifier\n"
#~ "got an addition\n"
#~ "got something else\n"
#~ "\n"
#~ "got something else\n"
#~ "got something else\n"
#~ "got something else\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "no_mangle attribute\n"
#~ "inline attribute\n"
#~ "something else (#[no_mangle])\n"
#~ "something else (#[inline])\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "no_mangle attribute\n"
#~ "inline attribute\n"
#~ "something else (#[no_mangle])\n"
#~ "something else (#[inline])\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#![feature(macro_metavar_expr)]\n"
#~ "\n"
#~ "macro_rules! foo {\n"
#~ "    () => {\n"
#~ "        macro_rules! bar {\n"
#~ "            ( $$( $$any:tt )* ) => { $$( $$any )* };\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "foo!();\n"
#~ "bar!();\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#![feature(macro_metavar_expr)]\n"
#~ "\n"
#~ "macro_rules! foo {\n"
#~ "    () => {\n"
#~ "        macro_rules! bar {\n"
#~ "            ( $$( $$any:tt )* ) => { $$( $$any )* };\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "foo!();\n"
#~ "bar!();\n"
#~ "# fn main() {}\n"
#~ "```"

#~ msgid ""
#~ "```text\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:13:21\n"
#~ "   |\n"
#~ "13 | let four = using_a!(a / 10);\n"
#~ "   |                     ^ not found in this scope\n"
#~ "```"
#~ msgstr ""
#~ "```text\n"
#~ "error[E0425]: cannot find value `a` in this scope\n"
#~ "  --> src/main.rs:13:21\n"
#~ "   |\n"
#~ "13 | let four = using_a!(a / 10);\n"
#~ "   |                     ^ not found in this scope\n"
#~ "```"

#~ msgid "a"
#~ msgstr "a"

#, fuzzy
#~ msgid " is not the same identifier as "
#~ msgstr "と同じ識別子ではありません。"

#, fuzzy
#~ msgid ", however similar they may appear."
#~ msgstr "どんなに似ていても。"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "pub mod inner {\n"
#~ "    #[macro_export]\n"
#~ "    macro_rules! call_foo {\n"
#~ "        () => { $crate::inner::foo() };\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn foo() {}\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "pub mod inner {\n"
#~ "    #[macro_export］\n"
#~ "    macro_rules!\n"
#~ "        () => { $crate::inner::foo() }; \n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn foo() {}.\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "the keyword `self`\n"
#~ "the keyword `self`\n"
#~ "```"
#~ msgstr ""
#~ "テキスト\n"
#~ "キーワード `self`\n"
#~ "キーワード `self`\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "error: `mut` must be followed by a named binding\n"
#~ " --> src/main.rs:2:24\n"
#~ "  |\n"
#~ "2 |     ($i:ident) => {let mut $i = $i;};\n"
#~ "  |                        ^^^^^^ help: remove the `mut` prefix: `self`\n"
#~ "...\n"
#~ "9 |         make_mutable!(self);\n"
#~ "  |         -------------------- in this macro invocation\n"
#~ "  |\n"
#~ "  = note: `mut` may be followed by `variable` and `variable @ pattern`\n"
#~ "```"
#~ msgstr ""
#~ "テキスト\n"
#~ "error: `mut` の後には名前付きバインディングが必要です。\n"
#~ " --> src/main.rs:2:24\n"
#~ "  |\n"
#~ "2 | ($i:ident) => {let mut $i = $i;}; \n"
#~ "  | ヘルプ: プレフィックス `mut` を削除します。\n"
#~ "...\n"
#~ "9 | make_mutable!\n"
#~ "  | このマクロの呼び出しでは\n"
#~ "  |\n"
#~ "  = 注意: `mut` の後には `variable` や `variable @ pattern` を付けることがで"
#~ "きます。\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "error[E0424]: expected value, found module `self`\n"
#~ "  --> src/main.rs:2:33\n"
#~ "   |\n"
#~ "2  |       ($i:ident) => {let mut $i = self;};\n"
#~ "   |                                   ^^^^ `self` value is a keyword only "
#~ "available in methods with a `self` parameter\n"
#~ "...\n"
#~ "8  | /     fn double(self) -> Dummy {\n"
#~ "9  | |         make_self_mutable!(mut_self);\n"
#~ "   | |         ----------------------------- in this macro invocation\n"
#~ "10 | |         mut_self.0 *= 2;\n"
#~ "11 | |         mut_self\n"
#~ "12 | |     }\n"
#~ "   | |_____- this function has a `self` parameter, but a macro invocation "
#~ "can only access identifiers it receives from parameters\n"
#~ "   |\n"
#~ "```"
#~ msgstr ""
#~ "テキスト\n"
#~ "error[E0424]: 期待される値、見つかったモジュール `self`\n"
#~ "  --> src/main.rs:2:33\n"
#~ "   |\n"
#~ "2 | ($i:ident) => {let mut $i = self;}; \n"
#~ "   |^^ `self` 値は `self` パラメータを持つメソッドでのみ使用可能なキーワード"
#~ "です。\n"
#~ "...\n"
#~ "8 | / fn double(self) -> ダミー {...\n"
#~ "9 | | make_self_mutable!(mut_self); \n"
#~ "   | このマクロ呼び出しでは\n"
#~ "10 | mut_self.0 *= 2; \n"
#~ "11｜｜ mut_self\n"
#~ "\n"
#~ "   | この関数は `self` パラメータを持ちますが、マクロ呼び出しはパラメータか"
#~ "ら受け取った識別子にしかアクセスできません。\n"
#~ "   |\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "error: no rules expected the token `_`\n"
#~ "  --> src/main.rs:12:21\n"
#~ "   |\n"
#~ "1  | macro_rules! double_method {\n"
#~ "   | -------------------------- when calling this macro\n"
#~ "...\n"
#~ "12 |     double_method! {_, 0}\n"
#~ "   |                     ^ no rules expected this token in macro call\n"
#~ "```"
#~ msgstr ""
#~ "テキスト\n"
#~ "error: トークン `_` を期待するルールがありません。\n"
#~ "  --> src/main.rs:12:21\n"
#~ "   |\n"
#~ "1 | macro_rules!\n"
#~ "   | このマクロを呼び出すとき\n"
#~ "...\n"
#~ "12 | double_method！{_, 0}\n"
#~ "   | ^ マクロ呼び出しでこのトークンを期待するルールはありません。\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```text\n"
#~ "note: trace_macro\n"
#~ "  --> src/main.rs:11:1\n"
#~ "   |\n"
#~ "11 | each_tt!(spim wak plee whum);\n"
#~ "   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
#~ "   |\n"
#~ "   = note: expanding `each_tt! { spim wak plee whum }`\n"
#~ "   = note: to `each_tt ! (wak plee whum) ;`\n"
#~ "   = note: expanding `each_tt! { wak plee whum }`\n"
#~ "   = note: to `each_tt ! (plee whum) ;`\n"
#~ "   = note: expanding `each_tt! { plee whum }`\n"
#~ "   = note: to `each_tt ! (whum) ;`\n"
#~ "   = note: expanding `each_tt! { whum }`\n"
#~ "   = note: to `each_tt ! () ;`\n"
#~ "   = note: expanding `each_tt! {  }`\n"
#~ "   = note: to ``\n"
#~ "```"
#~ msgstr ""
#~ "テキスト\n"
#~ "note: trace_macro\n"
#~ "  --> src/main.rs:11:1\n"
#~ "   |\n"
#~ "11 | each_tt!(spim wak plee whum); \n"
#~ "   \n"
#~ "   |\n"
#~ "   = 注: `each_tt！{ spim wak plee whum }`.\n"
#~ "   = 注: `each_tt ！(wak plee whum) ;`)\n"
#~ "   = note: `each_tt！(wak plee whum) }` = note: `each_tt!\n"
#~ "   = note: to `each_tt ！(plee whum) ;`\n"
#~ "   = note: `each_tt！(plee whum) }` = note: `each_tt!\n"
#~ "   = note: to `each_tt ！(whum) ;`\n"
#~ "   = note: `each_tt！(whum) ;` = note: `each_tt!\n"
#~ "   = note: `each_tt ！() ;`\n"
#~ "   = note: `each_tt！{ }`\n"
#~ "   = note: ``へ\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "#[macro_use]\n"
#~ "mod some_mod_that_defines_macros;\n"
#~ "mod some_mod_that_uses_those_macros;\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "#[macro_use]\n"
#~ "mod some_mod_that_defines_macros; \n"
#~ "mod some_mod_that_uses_those_macros; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "#[macro_use]\n"
#~ "mod macros {\n"
#~ "    macro_rules! X { () => { Y!(); } }\n"
#~ "    macro_rules! Y { () => {} }\n"
#~ "}\n"
#~ "\n"
#~ "X!();\n"
#~ "#\n"
#~ "# fn main() {}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "#[macro_use]\n"
#~ "MODマクロ\n"
#~ "    macro_rules！x { () => { y!(); }.}\n"
#~ "    macro_rules！Y { () => {} }\n"
#~ "}\n"
#~ "\n"
#~ "X!();\n"
#~ "#\n"
#~ "# fn main() {}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "# macro_rules! f { ($($tt:tt)*) => {} }\n"
#~ "f! {\n"
#~ "    fn f_u8(x: u32) -> u8;\n"
#~ "    fn f_u16(x: u32) -> u16;\n"
#~ "    fn f_u32(x: u32) -> u32;\n"
#~ "    fn f_u64(x: u64) -> u64;\n"
#~ "    fn f_u128(x: u128) -> u128;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "# macro_rules! f { ($($tt:tt)*) => {} }.\n"
#~ "f!{\n"
#~ "    fn f_u8(x: u32) -> u8; \n"
#~ "    fn f_u16(x: u32) -> u16; \n"
#~ "    fn f_u32(x: u32) -> u32; \n"
#~ "    fn f_u64(x: u64) -> u64; \n"
#~ "    fn f_u128(x: u128) -> u128; \n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "# macro_rules! f { ($($tt:tt)*) => {} }\n"
#~ "f! { fn f_u8(x: u32) -> u8; }\n"
#~ "f! { fn f_u16(x: u32) -> u16; }\n"
#~ "f! { fn f_u32(x: u32) -> u32; }\n"
#~ "f! { fn f_u64(x: u64) -> u64; }\n"
#~ "f! { fn f_u128(x: u128) -> u128; }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "# macro_rules! f { ($($tt:tt)*) => {} }.\n"
#~ "f!{ fn f_u8(x: u32) -> u8; } f!\n"
#~ "f!{ fn f_u16(x: u32) -> u16; } f!\n"
#~ "f!{ fn f_u32(x: u32) -> u32; } f!\n"
#~ "f!{ fn f_u64(x: u64) -> u64; } f!\n"
#~ "f!{ fn f_u128(x: u128) -> u128; } f!\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "#[macro_export]\n"
#~ "macro_rules! foo {\n"
#~ "    (@as_expr $e:expr) => {$e};\n"
#~ "\n"
#~ "    ($($tts:tt)*) => {\n"
#~ "        foo!(@as_expr $($tts)*)\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(foo!(42), 42);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "#[macro_export]\n"
#~ "macro_rules!\n"
#~ "    (@as_expr $e:expr) => {$e}; \n"
#~ "\n"
#~ "    ($($tts:tt)*) => { { foo!\n"
#~ "        foo！(@as_expr $($tts)*)\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(foo!(42), 42); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "#[macro_export]\n"
#~ "macro_rules! as_expr { ($e:expr) => {$e} }\n"
#~ "\n"
#~ "#[macro_export]\n"
#~ "macro_rules! foo {\n"
#~ "    ($($tts:tt)*) => {\n"
#~ "        as_expr!($($tts)*)\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(foo!(42), 42);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "#[macro_export]\n"
#~ "macro_rules! as_expr { ($e:expr) => {$e} }.\n"
#~ "\n"
#~ "#[macro_export]\n"
#~ "macro_rules!\n"
#~ "    ($($tts:tt)*) => { { {$e} } #[マクロ_エクスポート] macro_rules!\n"
#~ "        as_expr!\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(foo!(42), 42); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! init_array {\n"
#~ "    [$e:expr; $n:tt] => {\n"
#~ "        {\n"
#~ "            let e = $e;\n"
#~ "            [accum!($n, e.clone())]\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "macro_rules! accum {\n"
#~ "    (3, $e:expr) => { $e, accum!(2, $e) };\n"
#~ "    (2, $e:expr) => { $e, accum!(1, $e) };\n"
#~ "    (1, $e:expr) => { $e };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "マクロルール！ init_array { { [$e:expr; $n:tt\n"
#~ "    [$e:expr; $n:tt] => {\n"
#~ "        {\n"
#~ "            let e = $e; \n"
#~ "            [accum!($n, e.clone())]。\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "macro_rules!\n"
#~ "    (3, $e:expr) => { $e, accum!(2, $e) }; \n"
#~ "    (2, $e:expr) => { $e, accum!(1, $e) }; \n"
#~ "    (1, $e:expr) => { $e }; \n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "    [accum!(3, e.clone())]\n"
#~ "    [e.clone(), accum!(2, e.clone())]\n"
#~ "    [e.clone(), e.clone(), accum!(1, e.clone())]\n"
#~ "    [e.clone(), e.clone(), e.clone()]\n"
#~ "```"
#~ msgstr ""
#~ "ラスト,無視\n"
#~ "    [accum!(3, e.clone())].\n"
#~ "    [e.clone(), accum!(2, e.clone())].\n"
#~ "    [e.clone(), e.clone(), accum!(1, e.clone())].\n"
#~ "    [e.clone(), e.clone(), e.clone()].\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "macro_rules! replace_expr {\n"
#~ "    ($_t:tt $sub:expr) => {$sub};\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "macro_rules!\n"
#~ "    ($_t:tt $sub:expr) => {$sub}; \n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! tuple_default {\n"
#~ "    ($($tup_tys:ty),*) => {\n"
#~ "        (\n"
#~ "            $(\n"
#~ "                replace_expr!(\n"
#~ "                    ($tup_tys)\n"
#~ "                    Default::default()\n"
#~ "                ),\n"
#~ "            )*\n"
#~ "        )\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# macro_rules! replace_expr {\n"
#~ "#     ($_t:tt $sub:expr) => {$sub};\n"
#~ "# }\n"
#~ "#\n"
#~ "# assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::"
#~ "default(), String::default()));\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "マクロルール！ tuple_default {\n"
#~ "    ($($tup_tys:ty),*) => {\n"
#~ "        (\n"
#~ "            $(\n"
#~ "                replace_expr!\n"
#~ "                    ($tup_tys)\n"
#~ "                    デフォルト::default()\n"
#~ "                ),\n"
#~ "            )*\n"
#~ "        )\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# マクロルール！ replace_expr {\n"
#~ "# ($_t:tt $sub:expr) => {$sub}; \n"
#~ "# }\n"
#~ "#\n"
#~ "# assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::"
#~ "default(), String::default())); \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "# #![allow(dead_code)]\n"
#~ "macro_rules! as_expr { ($e:expr) => {$e} }\n"
#~ "macro_rules! as_item { ($i:item) => {$i} }\n"
#~ "macro_rules! as_pat  { ($p:pat)  => {$p} }\n"
#~ "macro_rules! as_stmt { ($s:stmt) => {$s} }\n"
#~ "macro_rules! as_ty   { ($t:ty)   => {$t} }\n"
#~ "\n"
#~ "as_item!{struct Dummy;}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "#![allow(dead_code)].\n"
#~ "macro_rules! as_expr { ($e:expr) => {$e} }.\n"
#~ "macro_rules! as_item { ($i:item) => {$i} }.\n"
#~ "マクロルール！ as_pat { ($p:pat) => {$p} }.\n"
#~ "マクロルール！ as_stmt { ($s:stmt) => {$s} }.\n"
#~ "\n"
#~ "\n"
#~ "as_item!\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42)); \n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! replace_expr {\n"
#~ "    ($_t:tt $sub:expr) => {$sub};\n"
#~ "}\n"
#~ "\n"
#~ "macro_rules! count_tts {\n"
#~ "    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*};\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(count_tts!(0 1 2), 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "macro_rules!\n"
#~ "    ($_t:tt $sub:expr) => {$sub}; \n"
#~ "}\n"
#~ "\n"
#~ "マクロルール!\n"
#~ "    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*}; \n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(count_tts!(0 1 2), 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! count_tts {\n"
#~ "    () => {0usize};\n"
#~ "    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(count_tts!(0 1 2), 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "マクロルール！ count_tts {\n"
#~ "    () => {0usize};\n"
#~ "    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)}; \n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(count_tts!(0 1 2), 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! replace_expr {\n"
#~ "    ($_t:tt $sub:expr) => {$sub};\n"
#~ "}\n"
#~ "\n"
#~ "macro_rules! count_tts {\n"
#~ "    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ())),*])};\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(count_tts!(0 1 2), 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "macro_rules!\n"
#~ "    ($_t:tt $sub:expr) => {$sub}; \n"
#~ "}\n"
#~ "\n"
#~ "マクロルール!\n"
#~ "    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ()),*])}; \n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(count_tts!(0 1 2), 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "const fn count_helper<const N: usize>(_: [(); N]) -> usize { N }\n"
#~ "\n"
#~ "macro_rules! replace_expr {\n"
#~ "    ($_t:tt $sub:expr) => { $sub }\n"
#~ "}\n"
#~ "\n"
#~ "macro_rules! count_tts {\n"
#~ "    ($($smth:tt)*) => {\n"
#~ "        count_helper([$(replace_expr!($smth ())),*])\n"
#~ "    }\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(count_tts!(0 1 2), 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "const fn count_helper<const N: usize>(_: [(); N]) -&gt; usize { N }.\n"
#~ "\n"
#~ "マクロルール！ replace_expr { ($_t:tt $sub:expr) =&gt; { $sub }.\n"
#~ "    ($_t:tt $sub:expr) =&gt; { $sub }.\n"
#~ "}\n"
#~ "\n"
#~ "マクロルール!\n"
#~ "    ($($smth:tt)*) =&gt; { $sub } } マクロルール!\n"
#~ "        count_helper([$(replace_expr!($smth ())),*])\n"
#~ "    }\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(count_tts!(0 1 2), 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! count_idents {\n"
#~ "    () => {0};\n"
#~ "    ($last_ident:ident, $($idents:ident),* $(,)?) => {\n"
#~ "        {\n"
#~ "            #[allow(dead_code, non_camel_case_types)]\n"
#~ "            enum Idents { $($idents,)* $last_ident }\n"
#~ "            const COUNT: u32 = Idents::$last_ident as u32 + 1;\n"
#~ "            COUNT\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     const COUNT: u32 = count_idents!(A, B, C);\n"
#~ "#     assert_eq!(COUNT, 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "マクロルール！ count_idents {\n"
#~ "    () => {0};\n"
#~ "    ($last_ident:ident, $($idents:ident),* $(,)?) => { { $(,)?\n"
#~ "        {\n"
#~ "            #[allow(dead_code, non_camel_case_types)] のようにします。\n"
#~ "            enum Idents { $($idents,)* $last_ident }.\n"
#~ "            const COUNT: u32 = Idents::$last_ident as u32 + 1; \n"
#~ "            COUNT\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# const COUNT: u32 = count_idents!(A, B, C); \n"
#~ "# assert_eq!(COUNT, 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! count_tts {\n"
#~ "    () => { 0 };\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 };\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "#     assert_eq!(count_tts!(0 1 2), 3);\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "マクロルール！ count_tts {\n"
#~ "    () => { 0 };\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 };\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 };\n"
#~ "}\n"
#~ "#\n"
#~ "# fn main() {\n"
#~ "# assert_eq!(count_tts!(0 1 2), 3); \n"
#~ "# }\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "count_tts!(0 0 0 0 0 0 0 0 0 0);\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "count_tts!(0 0 0 0 0 0 0 0 0 0); \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "count_tts!(0 0 0 0 0) << 1;\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "count_tts!(0 0 0 0 0) << 1; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "((count_tts!(0 0) << 1) | 1) << 1;\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "((count_tts!(0 0) << 1) | 1) << 1; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "((count_tts!(0) << 1 << 1) | 1) << 1;\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "((count_tts!(0) << 1 << 1) | 1) << 1; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "((((count_tts!() << 1) | 1) << 1 << 1) | 1) << 1;\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "((((count_tts!() << 1) | 1) << 1 << 1) | 1) << 1; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "((((0 << 1) | 1) << 1 << 1) | 1) << 1;\n"
#~ "```"
#~ msgstr ""
#~ "錆、無視\n"
#~ "((((0 << 1) | 1) << 1 << 1) | 1) << 1;\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```ignore\n"
#~ "macro_rules! abacus {\n"
#~ "    (-) => {-1};\n"
#~ "    (+) => {1};\n"
#~ "    ($( $moves:tt )*) => {\n"
#~ "        0 $(+ abacus!($moves))*\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "無視\n"
#~ "マクロルール\n"
#~ "    (-) => {-1};\n"
#~ "    (+) => {1};\n"
#~ "    ($( $moves:tt )*) => { { 0\n"
#~ "        0 $(+ そろばん!($moves))*) => { $(+ そろばん!($moves))*)\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "#![feature(decl_macro)]\n"
#~ "\n"
#~ "macro_rules! replace_expr_ {\n"
#~ "    ($_t:tt $sub:expr) => { $sub }\n"
#~ "}\n"
#~ "macro replace_expr($_t:tt $sub:expr) {\n"
#~ "    $sub\n"
#~ "}\n"
#~ "\n"
#~ "macro_rules! count_tts_ {\n"
#~ "    () => { 0 };\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 };\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 };\n"
#~ "}\n"
#~ "macro count_tts {\n"
#~ "    () => { 0 },\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 },\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 },\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "#特徴(decl_macro)]。\n"
#~ "\n"
#~ "macro_rules! replace_expr_ { ($_t:tt $sub:expr) => { $sub }.\n"
#~ "    ($_t:tt $sub:expr) => { $sub }.\n"
#~ "}\n"
#~ "マクロ replace_expr($_t:tt $sub:expr) { { ($_t:tt $sub:expr)\n"
#~ "    $sub\n"
#~ "}\n"
#~ "\n"
#~ "マクロルール!\n"
#~ "    () => { 0 };\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 };\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 };\n"
#~ "}\n"
#~ "マクロ count_tts {\n"
#~ "    () => { 0 },\n"
#~ "    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*)<< 1) | 1 },\n"
#~ "    ($($a:tt $even:tt)*) => { count_tts!($($a)*)<< 1 },\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```toml\n"
#~ "[lib]\n"
#~ "proc-macro = true\n"
#~ "```"
#~ msgstr ""
#~ "``toml\n"
#~ "[lib]\n"
#~ "proc-macro = true\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "#[proc_macro]\n"
#~ "pub fn my_proc_macro(input: TokenStream) -> TokenStream {\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "#[proc_macro］\n"
#~ "pub fn my_proc_macro(input: TokenStream) -> TokenStream { {.\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "#[proc_macro_attribute]\n"
#~ "pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -> "
#~ "TokenStream {\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "#[proc_macro_attribute] を参照してください。\n"
#~ "pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -> "
#~ "TokenStream { {.\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "#[proc_macro_derive(MyDerive)]\n"
#~ "pub fn my_derive(annotated_item: TokenStream) -> TokenStream {\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "#[proc_macro_derive(MyDerive)] を参照してください。\n"
#~ "pub fn my_derive(annotated_item: TokenStream) -> TokenStream { {.\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use proc_macro::TokenStream;\n"
#~ "\n"
#~ "#[proc_macro]\n"
#~ "pub fn tlborm_fn_macro(input: TokenStream) -> TokenStream {\n"
#~ "    input\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "proc_macro::TokenStream を使用します; \n"
#~ "\n"
#~ "#[proc_macro］\n"
#~ "pub fn tlborm_fn_macro(input: TokenStream) -> TokenStream { {.\n"
#~ "    input\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use tlborm_proc::tlborm_attribute;\n"
#~ "\n"
#~ "fn foo() {\n"
#~ "    tlborm_attribute!(be quick; time is mana);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "tlborm_proc::tlborm_attribute を使用します; \n"
#~ "\n"
#~ "fn foo() {\n"
#~ "    tlborm_attribute!(be quick; time is mana); \n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use proc_macro::TokenStream;\n"
#~ "\n"
#~ "#[proc_macro_attribute]\n"
#~ "pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -> "
#~ "TokenStream {\n"
#~ "    annotated_item\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "proc_macro::TokenStream を使用します; \n"
#~ "\n"
#~ "proc_macro_attribute] #[proc_macro_attribute\n"
#~ "pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -> "
#~ "TokenStream {.\n"
#~ "    注釈付き項目\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use tlborm_proc::tlborm_attribute;\n"
#~ "\n"
#~ "#[tlborm_attribute]\n"
#~ "fn foo() {}\n"
#~ "\n"
#~ "#[tlborm_attribute(attributes are pretty handsome)]\n"
#~ "fn bar() {}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "tlborm_proc::tlborm_attribute を使用します; \n"
#~ "\n"
#~ "#[tlborm_attribute］\n"
#~ "fn foo() [0］\n"
#~ "\n"
#~ "#[tlborm_attribute(attribute is pretty handsome)] fn bar() {}.\n"
#~ "fn bar() [1］\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use proc_macro::TokenStream;\n"
#~ "\n"
#~ "#[proc_macro_derive(TlbormDerive)]\n"
#~ "pub fn tlborm_derive(item: TokenStream) -> TokenStream {\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "proc_macro::TokenStream を使用します; \n"
#~ "\n"
#~ "#[proc_macro_derive(TlbormDerive)] を参照してください。\n"
#~ "pub fn tlborm_derive(item: TokenStream) -> TokenStream { 次のようにしま"
#~ "す。\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use tlborm_proc::TlbormDerive;\n"
#~ "\n"
#~ "#[derive(TlbormDerive)]\n"
#~ "struct Foo;\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "tlborm_proc::TlbormDerive を使用します; \n"
#~ "\n"
#~ "#derive(TlbormDerive)]を使用します。\n"
#~ "struct Foo; \n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use proc_macro::TokenStream;\n"
#~ "\n"
#~ "#[proc_macro_derive(TlbormDerive, attributes(tlborm_helper))]\n"
#~ "pub fn tlborm_derive(item: TokenStream) -> TokenStream {\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "rs\n"
#~ "proc_macro::TokenStream を使用します; \n"
#~ "\n"
#~ "#proc_macro_derive(TlbormDerive, attributes(tlborm_helper))].\n"
#~ "pub fn tlborm_derive(item: TokenStream) -> TokenStream "
#~ "{ [proc_macro_derive(Tlborm_helper, attributes(tlborm_helper)]] #.\n"
#~ "    TokenStream::new()\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rs\n"
#~ "use tlborm_proc::TlbormDerive;\n"
#~ "\n"
#~ "#[derive(TlbormDerive)]\n"
#~ "struct Foo {\n"
#~ "    #[tlborm_helper]\n"
#~ "    field: u32\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(TlbormDerive)]\n"
#~ "enum Bar {\n"
#~ "    #[tlborm_helper]\n"
#~ "    Variant { #[tlborm_helper] field: u32 }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "``rs\n"
#~ "tlborm_proc::TlbormDerive を使用します; \n"
#~ "\n"
#~ "#[derive(TlbormDerive)] を参照してください。\n"
#~ "struct Foo {\n"
#~ "    #[tlborm_helper］\n"
#~ "    field: u32\n"
#~ "}\n"
#~ "\n"
#~ "#derive(TlbormDerive)]。\n"
#~ "enum Bar {\n"
#~ "    #[tlborm_helper] 変数 { #[tlborm_helper] field: u32 }.\n"
#~ "    Variant { #[tlborm_helper] field: u32 }.\n"
#~ "}\n"
#~ "```"

#~ msgid "As you can see, the "
#~ msgstr "ご覧の通り、 "

#, fuzzy
#~ msgid ""
#~ " that's defined by the macro invocation is in a different context to the "
#~ msgstr " マクロの呼び出しによって定義されたコンテキストは"
