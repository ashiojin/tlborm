
msgid ""
msgstr ""
"Project-Id-Version: The Little Book of Rust Macros\n"
"POT-Creation-Date: 2023-10-29T12:05:28+09:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:5
#: src/syntax-extensions.md:1
msgid "Syntax Extensions"
msgstr ""

#: src/SUMMARY.md:6
#: src/syntax-extensions/source-analysis.md:1
msgid "Source Analysis"
msgstr ""

#: src/SUMMARY.md:7
msgid "Macros in the Ast"
msgstr ""

#: src/SUMMARY.md:8
#: src/syntax-extensions/expansion.md:1
msgid "Expansion"
msgstr ""

#: src/SUMMARY.md:9
#: src/SUMMARY.md:18
#: src/syntax-extensions/hygiene.md:1
#: src/decl-macros/minutiae/hygiene.md:1
#: src/decl-macros/macros2.md:56
msgid "Hygiene"
msgstr ""

#: src/SUMMARY.md:10
#: src/SUMMARY.md:20
#: src/syntax-extensions/debugging.md:1
#: src/decl-macros/minutiae/debugging.md:1
msgid "Debugging"
msgstr ""

#: src/SUMMARY.md:11
#: src/decl-macros.md:1
msgid "Declarative Macros"
msgstr ""

#: src/SUMMARY.md:12
#: src/SUMMARY.md:37
#: src/proc-macros/methodical.md:1
msgid "A Methodical Introduction"
msgstr ""

#: src/SUMMARY.md:13
#: src/SUMMARY.md:41
msgid "A Practical Introduction"
msgstr ""

#: src/SUMMARY.md:14
#: src/decl-macros/minutiae.md:1
msgid "Minutiae"
msgstr ""

#: src/SUMMARY.md:15
#: src/decl-macros/minutiae/fragment-specifiers.md:1
msgid "Fragment Specifiers"
msgstr ""

#: src/SUMMARY.md:16
#: src/decl-macros/minutiae/metavar-and-expansion.md:1
msgid "Metavariables and Expansion Redux"
msgstr ""

#: src/SUMMARY.md:17
#: src/decl-macros/macros-methodical.md:243
#: src/decl-macros/minutiae/metavar-expr.md:1
msgid "Metavariable Expressions"
msgstr ""

#: src/SUMMARY.md:19
#: src/decl-macros/minutiae/identifiers.md:1
msgid "Non-Identifier Identifiers"
msgstr ""

#: src/SUMMARY.md:21
#: src/decl-macros/minutiae/scoping.md:1
msgid "Scoping"
msgstr ""

#: src/SUMMARY.md:22
#: src/decl-macros/minutiae/import-export.md:1
msgid "Import and Export"
msgstr ""

#: src/SUMMARY.md:23
#: src/syntax-extensions/ast.md:103
#: src/decl-macros/patterns.md:1
msgid "Patterns"
msgstr ""

#: src/SUMMARY.md:24
#: src/decl-macros/patterns/callbacks.md:1
msgid "Callbacks"
msgstr ""

#: src/SUMMARY.md:25
#: src/decl-macros/patterns/tt-muncher.md:1
msgid "Incremental TT Munchers"
msgstr ""

#: src/SUMMARY.md:26
#: src/decl-macros/patterns/internal-rules.md:1
msgid "Internal Rules"
msgstr ""

#: src/SUMMARY.md:27
#: src/decl-macros/patterns/push-down-acc.md:1
msgid "Push-down Accumulation"
msgstr ""

#: src/SUMMARY.md:28
#: src/decl-macros/patterns/repetition-replacement.md:1
msgid "Repetition Replacement"
msgstr ""

#: src/SUMMARY.md:29
#: src/decl-macros/patterns/tt-bundling.md:1
msgid "TT Bundling"
msgstr ""

#: src/SUMMARY.md:30
#: src/decl-macros/building-blocks.md:1
msgid "Building Blocks"
msgstr ""

#: src/SUMMARY.md:31
#: src/decl-macros/building-blocks/ast-coercion.md:1
msgid "AST Coercion"
msgstr ""

#: src/SUMMARY.md:32
#: src/decl-macros/building-blocks/counting.md:1
msgid "Counting"
msgstr ""

#: src/SUMMARY.md:33
msgid "Abacus Counting"
msgstr ""

#: src/SUMMARY.md:34
#: src/decl-macros/building-blocks/parsing.md:1
msgid "Parsing Rust"
msgstr ""

#: src/SUMMARY.md:35
#: src/decl-macros/macros2.md:1
msgid "Macros 2.0"
msgstr ""

#: src/SUMMARY.md:36
#: src/proc-macros.md:1
msgid "Procedural Macros"
msgstr ""

#: src/SUMMARY.md:38
#: src/SUMMARY.md:42
#: src/proc-macros/methodical/function-like.md:1
msgid "Function-like"
msgstr ""

#: src/SUMMARY.md:39
#: src/SUMMARY.md:43
#: src/proc-macros/methodical/attr.md:1
msgid "Attribute"
msgstr ""

#: src/SUMMARY.md:40
#: src/SUMMARY.md:44
#: src/proc-macros/methodical/derive.md:1
msgid "Derive"
msgstr ""

#: src/SUMMARY.md:45
#: src/proc-macros/third-party-crates.md:1
msgid "Third-Party Crates"
msgstr ""

#: src/SUMMARY.md:46
#: src/proc-macros/hygiene.md:1
msgid "Hygiene and Spans"
msgstr ""

#: src/SUMMARY.md:47
msgid "Techniques"
msgstr ""

#: src/SUMMARY.md:48
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:50
#: src/glossary.md:1
msgid "Glossary"
msgstr ""

#: src/introduction.md:2
msgid "The Little Book of Rust Macros"
msgstr ""

#: src/introduction.md:4
msgid ""
"**Note**: This is a continuation of [Daniel Keep's "
"Book](https://github.com/DanielKeep/tlborm) which has not been updated since "
"the early summer of 2016, adapted to make use of "
"[mdBook](https://github.com/rust-lang/mdBook)."
msgstr ""

#: src/introduction.md:6
msgid ""
"View the [rendered version here](https://veykril.github.io/tlborm/) and the "
"[repository here](https://github.com/veykril/tlborm)."
msgstr ""

#: src/introduction.md:8
msgid ""
"A chinese version of this book can be found "
"[here](https://zjp-cn.github.io/tlborm/)."
msgstr ""

#: src/introduction.md:10
msgid ""
"This book is an attempt to distill the Rust community's collective knowledge "
"of Rust macros, the `Macros by Example` ones as well as procedural "
"macros(WIP). As such, both additions (in the form of pull requests) and "
"requests (in the form of issues) are very much welcome. If something's "
"unclear, opens up questions or is not understandable as written down, fear "
"not to make an issue asking for clarification. The goal is for this book to "
"become the best learning resource possible."
msgstr ""

#: src/introduction.md:15
msgid ""
"The [original Little Book of Rust "
"Macros](https://github.com/DanielKeep/tlborm) has helped me immensely with "
"understanding _**Macros by Example**_ style macros while I was still "
"learning the language. Unfortunately, the original book hasn't been updated "
"since April of 2016, while the Rust language as well as its macro-system "
"keeps evolving. Which is why I took up the task to update the book and keep "
"it updated as well as I can while also adding newfound things to it. In "
"hopes that it will help out all the fresh faces coming to Rust understanding "
"its macro systems, a part of the language a people tend to have trouble with."
msgstr ""

#: src/introduction.md:20
msgid ""
"This book expects you to have basic knowledge of Rust, it will not explain "
"language features or constructs that are irrelevant to macros. No prior "
"knowledge of macros is assumed. Having read and understood the first seven "
"chapters of the [Rust Book](https://doc.rust-lang.org/stable/book/) is a "
"must, though having read the majority of the book is recommended."
msgstr ""

#: src/introduction.md:24
msgid "Thanks"
msgstr ""

#: src/introduction.md:26
msgid ""
"A big thank you to Daniel Keep for the original work as well as all the "
"contributors that added to the original which can be found "
"[here](https://github.com/DanielKeep/tlborm)."
msgstr ""

#: src/introduction.md:28
msgid "License"
msgstr ""

#: src/introduction.md:30
msgid ""
"This work inherits the licenses of the original, hence it is licensed under "
"both the [Creative Commons Attribution-ShareAlike 4.0 International "
"License](http://creativecommons.org/licenses/by-sa/4.0/) and the [MIT "
"license](http://opensource.org/licenses/MIT)."
msgstr ""

#: src/syntax-extensions.md:3
msgid ""
"Before talking about Rust's different macro systems it is worthwhile to "
"discuss the general mechanism they are built on: _syntax extensions_."
msgstr ""

#: src/syntax-extensions.md:5
msgid ""
"To do that, we must first discuss how Rust source is processed by the "
"compiler, and the general mechanisms on which user-defined macros and "
"proc-macros are built upon."
msgstr ""

#: src/syntax-extensions.md:7
msgid ""
"**Note**: This book will use the term _syntax extension_ from now on when "
"talking about all of rust's different macro kinds in general to reduce "
"potential confusion with the upcoming [declarative macro "
"2.0](https://github.com/rust-lang/rust/issues/39412) proposal which uses the "
"`macro` keyword."
msgstr ""

#: src/syntax-extensions/source-analysis.md:3
msgid "Tokenization"
msgstr ""

#: src/syntax-extensions/source-analysis.md:5
msgid ""
"The first stage of compilation for a Rust program is "
"[tokenization](https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization). "
"This is where the source text is transformed into a sequence of tokens "
"(_i.e._ indivisible lexical units; the programming language equivalent of "
"\"words\"). Rust has various kinds of tokens, such as:"
msgstr ""

#: src/syntax-extensions/source-analysis.md:9
msgid "Identifiers: `foo`, `Bambous`, `self`, `we_can_dance`, `LaCaravane`, …"
msgstr ""

#: src/syntax-extensions/source-analysis.md:10
msgid "Literals: `42`, `72u32`, `0_______0`, `1.0e-40`, `\"ferris was here\"`, …"
msgstr ""

#: src/syntax-extensions/source-analysis.md:11
msgid "Keywords: `_`, `fn`, `self`, `match`, `yield`, `macro`, …"
msgstr ""

#: src/syntax-extensions/source-analysis.md:12
msgid "Symbols: `[`, `:`, `::`, `?`, `~`, `@`[^wither-at], …"
msgstr ""

#: src/syntax-extensions/source-analysis.md:14
msgid ""
"…among others. There are some things to note about the above: first, `self` "
"is both an identifier _and_ a keyword. In almost all cases, `self` is a "
"keyword, but it _is_ possible for it to be _treated_ as an identifier, which "
"will come up later (along with much cursing). Secondly, the list of keywords "
"includes some suspicious entries such as `yield` and `macro` that aren't "
"_actually_ in the language, but _are_ parsed by the compiler—these are "
"[reserved](https://doc.rust-lang.org/reference/keywords.html#reserved-keywords) "
"for future use. Third, the list of symbols _also_ includes entries that "
"aren't used by the language. In the case of `<-`, it is vestigial: it was "
"removed from the grammar, but not from the lexer. As a final point, note "
"that `::` is a distinct token; it is not simply two adjacent `:` tokens. The "
"same is true of all multi-character symbol tokens in Rust, as of Rust "
"1.2.[^two-lexers]"
msgstr ""

#: src/syntax-extensions/source-analysis.md:24
msgid ""
"`@` has a purpose, though most people seem to forget about it completely: it "
"is used in patterns to bind a non-terminal part of the pattern to a name."
msgstr ""

#: src/syntax-extensions/source-analysis.md:27
msgid ""
"Technically rust currently(1.46) has two lexers, "
"[`rustc_lexer`](https://github.com/rust-lang/rust/tree/master/compiler/rustc_lexer) "
"which only emits single character symbols as tokens and the "
"[lexer](https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/lexer) "
"in "
"[`rustc_parse`](https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse) "
"which sees multi-character symbols as distinct tokens."
msgstr ""

#: src/syntax-extensions/source-analysis.md:31
msgid ""
"As a point of comparison, it is at _this_ stage that some languages have "
"their macro layer, though Rust does _not_. For example, C/C++ macros are "
"_effectively_ processed at this point. [^lies-damn-lies-cpp] This is why the "
"following code works: [^cpp-it-seemed-like-a-good-idea-at-the-time]"
msgstr ""

#: src/syntax-extensions/source-analysis.md:36
msgid ""
"```c\n"
"#define SUB int\n"
"#define BEGIN {\n"
"#define END }\n"
"\n"
"SUB main() BEGIN\n"
"    printf(\"Oh, the horror!\\n"
"\");\n"
"END\n"
"```"
msgstr ""

#: src/syntax-extensions/source-analysis.md:46
msgid ""
"In fact, the C preprocessor uses a different lexical structure to C itself, "
"but the distinction is _broadly_ irrelevant."
msgstr ""

#: src/syntax-extensions/source-analysis.md:49
msgid "_Whether_ it should work is an entirely _different_ question."
msgstr ""

#: src/syntax-extensions/source-analysis.md:52
msgid "Parsing"
msgstr ""

#: src/syntax-extensions/source-analysis.md:54
msgid ""
"The next stage is parsing, where the stream of tokens is turned into an "
"[Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) "
"(AST). This involves building up the syntactic structure of the program in "
"memory. For example, the token sequence `1 + 2` is transformed into the "
"equivalent of:"
msgstr ""

#: src/syntax-extensions/source-analysis.md:69
msgid ""
"The AST contains the structure of the _entire_ program, though it is based "
"on purely _lexical_ information. For example, although the compiler may know "
"that a particular expression is referring to a variable called `a`, at this "
"stage, it has _no way_ of knowing what `a` is, or even _where_ it comes from."
msgstr ""

#: src/syntax-extensions/source-analysis.md:74
msgid ""
"It is _after_ the AST has been constructed that macros are processed. "
"However, before we can discuss that, we have to talk about token trees."
msgstr ""

#: src/syntax-extensions/source-analysis.md:77
msgid "Token trees"
msgstr ""

#: src/syntax-extensions/source-analysis.md:79
msgid ""
"Token trees are somewhere between tokens and the AST. Firstly, _almost_ all "
"tokens are also token trees; more specifically, they are _leaves_. There is "
"one other kind of thing that can be a token tree leaf, but we will come back "
"to that later."
msgstr ""

#: src/syntax-extensions/source-analysis.md:83
msgid ""
"The only basic tokens that are _not_ leaves are the \"grouping\" tokens: "
"`(...)`, `[...]`, and `{...}`. These three are the _interior nodes_ of token "
"trees, and what give them their structure. To give a concrete example, this "
"sequence of tokens:"
msgstr ""

#: src/syntax-extensions/source-analysis.md:91
msgid "would be parsed into the following token trees:"
msgstr ""

#: src/syntax-extensions/source-analysis.md:101
msgid ""
"Note that this has _no relationship_ to the AST the expression would "
"produce; instead of a single root node, there are _seven_ token trees at the "
"root level. For reference, the AST would be:"
msgstr ""

#: src/syntax-extensions/source-analysis.md:128
msgid ""
"It is important to understand the distinction between the AST and token "
"trees. When writing macros, you have to deal with _both_ as distinct things."
msgstr ""

#: src/syntax-extensions/source-analysis.md:131
msgid ""
"One other aspect of this to note: it is _impossible_ to have an unpaired "
"parenthesis, bracket or brace; nor is it possible to have incorrectly nested "
"groups in a token tree."
msgstr ""

#: src/syntax-extensions/ast.md:1
msgid "Macros in the AST"
msgstr ""

#: src/syntax-extensions/ast.md:3
msgid ""
"As previously mentioned, macro processing in Rust happens _after_ the "
"construction of the AST. As such, the syntax used to invoke a macro _must_ "
"be a proper part of the language's syntax. In fact, there are several "
"\"syntax extension\" forms which are part of Rust's syntax. Specifically, "
"the following 4 forms (by way of examples):"
msgstr ""

#: src/syntax-extensions/ast.md:8
msgid "`# [ $arg ]`; _e.g._ `#[derive(Clone)]`, `#[no_mangle]`, …"
msgstr ""

#: src/syntax-extensions/ast.md:9
msgid ""
"`# ! [ $arg ]`; _e.g._ `#![allow(dead_code)]`, `#![crate_name=\"blang\"]`, …"
msgstr ""

#: src/syntax-extensions/ast.md:10
msgid "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"
msgstr ""

#: src/syntax-extensions/ast.md:11
msgid "`$name ! $arg0 $arg1`; _e.g._ `macro_rules! dummy { () => {}; }`."
msgstr ""

#: src/syntax-extensions/ast.md:13
msgid ""
"The first two are "
"[attributes](https://doc.rust-lang.org/reference/attributes.html) which "
"annotate items, expressions and statements. They can be classified into "
"different kinds, [built-in "
"attributes](https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index), "
"[proc-macro "
"attributes](https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros) "
"and [derive "
"attributes](https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes). "
"[proc-macro "
"attributes](https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros) "
"and [derive "
"attributes](https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes) "
"can be implemented with the second macro system that Rust offers, "
"[procedural "
"macros](https://doc.rust-lang.org/reference/procedural-macros.html). "
"[built-in "
"attributes](https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index) "
"on the other hand are attributes implemented by the compiler."
msgstr ""

#: src/syntax-extensions/ast.md:19
msgid ""
"The third form `$name ! $arg` are function-like macros. It is the form "
"available for use with `macro_rules!`, `macro` and also procedural macros. "
"Note that this form is not _limited_ to `macro_rules!` macros: it is a "
"generic syntax extension form. For example, whilst "
"[`format!`](https://doc.rust-lang.org/std/macro.format.html) is a "
"`macro_rules!` macro, "
"[`format_args!`](https://doc.rust-lang.org/std/macro.format_args.html) "
"(which is used to _implement_ "
"[`format!`](https://doc.rust-lang.org/std/macro.format.html)) is _not_ as it "
"is a compiler builtin."
msgstr ""

#: src/syntax-extensions/ast.md:24
msgid ""
"The fourth form is essentially a variation which is _not_ available to "
"macros. In fact, the only case where this form is used _at all_ is with the "
"`macro_rules!` construct itself."
msgstr ""

#: src/syntax-extensions/ast.md:27
msgid ""
"So, starting with the third form, how does the Rust parser know what the "
"`$arg` in (`$name ! $arg`) looks like for every possible syntax extension? "
"The answer is that it doesn't _have to_. Instead, the argument of a syntax "
"extension invocation is a _single_ token tree. More specifically, it is a "
"single, _non-leaf_ token tree; `(...)`, `[...]`, or `{...}`. With that "
"knowledge, it should become apparent how the parser can understand all of "
"the following invocation forms:"
msgstr ""

#: src/syntax-extensions/ast.md:34
msgid ""
"```rust,ignore\n"
"bitflags! {\n"
"    struct Color: u8 {\n"
"        const RED    = 0b0001,\n"
"        const GREEN  = 0b0010,\n"
"        const BLUE   = 0b0100,\n"
"        const BRIGHT = 0b1000,\n"
"    }\n"
"}\n"
"\n"
"lazy_static! {\n"
"    static ref FIB_100: u32 = {\n"
"        fn fib(a: u32) -> u32 {\n"
"            match a {\n"
"                0 => 0,\n"
"                1 => 1,\n"
"                a => fib(a-1) + fib(a-2)\n"
"            }\n"
"        }\n"
"\n"
"        fib(100)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    use Color::*;\n"
"    let colors = vec![RED, GREEN, BLUE];\n"
"    println!(\"Hello, World!\");\n"
"}\n"
"```"
msgstr ""

#: src/syntax-extensions/ast.md:65
msgid ""
"Although the above invocations may _look_ like they contain various kinds of "
"Rust code, the parser simply sees a collection of meaningless token trees. "
"To make this clearer, we can replace all these syntactic \"black boxes\" "
"with ⬚, leaving us with:"
msgstr ""

#: src/syntax-extensions/ast.md:79
msgid ""
"Just to reiterate: the parser does not assume _anything_ about ⬚; it "
"remembers the tokens it contains, but doesn't try to _understand_ them. This "
"means ⬚ can be anything, even invalid Rust! As to why this is a good thing, "
"we will come back to that at a later point."
msgstr ""

#: src/syntax-extensions/ast.md:84
msgid ""
"So, does this also apply to `$arg` in form 1 and 2, and to the two args in "
"form 4? Kind of. The `$arg` for form 1 and 2 is a bit different in that it "
"is not directly a token tree, but a _simple path_ that is either followed by "
"an `=` token and a literal expression, or a token tree. We will explore this "
"more in-depth in the appropriate proc-macro chapter. The important part here "
"is that this form as well, makes use of token trees to describe the input. "
"The 4th form in general is more special and accepts a very specific grammar "
"that also makes use of token trees though. The specifics of this form do not "
"matter at this point so we will skip them until they become relevant."
msgstr ""

#: src/syntax-extensions/ast.md:91
msgid "The important takeaways from this are:"
msgstr ""

#: src/syntax-extensions/ast.md:93
msgid "There are multiple kinds of syntax extensions in Rust."
msgstr ""

#: src/syntax-extensions/ast.md:94
msgid ""
"Just seeing something of the form `$name! $arg`, doesn't tell you what kind "
"of syntax extension it might be. It could be a `macro_rules!` macro, a "
"`proc-macro` or maybe even a builtin."
msgstr ""

#: src/syntax-extensions/ast.md:96
msgid ""
"The input to every `!` macro invocation, that is form 3, is a single "
"non-leaf token tree."
msgstr ""

#: src/syntax-extensions/ast.md:97
msgid "Syntax extensions are parsed as _part_ of the abstract syntax tree."
msgstr ""

#: src/syntax-extensions/ast.md:99
msgid ""
"The last point is the most important, as it has _significant_ implications. "
"Because syntax extensions are parsed into the AST, they can **only** appear "
"in positions where they are explicitly supported. Specifically syntax "
"extensions can appear in place of the following:"
msgstr ""

#: src/syntax-extensions/ast.md:104
msgid "Statements"
msgstr ""

#: src/syntax-extensions/ast.md:105
msgid "Expressions"
msgstr ""

#: src/syntax-extensions/ast.md:106
msgid "Items(this includes `impl` items)"
msgstr ""

#: src/syntax-extensions/ast.md:107
msgid "Types"
msgstr ""

#: src/syntax-extensions/ast.md:109
msgid "Some things _not_ on this list:"
msgstr ""

#: src/syntax-extensions/ast.md:111
msgid "Identifiers"
msgstr ""

#: src/syntax-extensions/ast.md:112
msgid "Match arms"
msgstr ""

#: src/syntax-extensions/ast.md:113
msgid "Struct fields"
msgstr ""

#: src/syntax-extensions/ast.md:115
msgid ""
"There is absolutely, definitely _no way_ to use syntax extensions in any "
"position _not_ on the first list."
msgstr ""

#: src/syntax-extensions/expansion.md:3
msgid ""
"Expansion is a relatively simple affair. At some point _after_ the "
"construction of the AST, but before the compiler begins constructing its "
"semantic understanding of the program, it will expand all syntax extensions."
msgstr ""

#: src/syntax-extensions/expansion.md:6
msgid ""
"This involves traversing the AST, locating syntax extension invocations and "
"replacing them with their expansion."
msgstr ""

#: src/syntax-extensions/expansion.md:8
msgid ""
"Once the compiler has run a syntax extension, it expects the result to be "
"parsable as one of a limited set of syntax elements, based on context. For "
"example, if you invoke a syntax extension at module scope, the compiler will "
"parse the result into an AST node that represents an item. If you invoke a "
"syntax extension in expression position, the compiler will parse the result "
"into an expression AST node."
msgstr ""

#: src/syntax-extensions/expansion.md:12
msgid "In fact, it can turn a syntax extension result into any of the following:"
msgstr ""

#: src/syntax-extensions/expansion.md:14
msgid "an expression,"
msgstr ""

#: src/syntax-extensions/expansion.md:15
msgid "a pattern,"
msgstr ""

#: src/syntax-extensions/expansion.md:16
msgid "a type,"
msgstr ""

#: src/syntax-extensions/expansion.md:17
msgid "zero or more items, or"
msgstr ""

#: src/syntax-extensions/expansion.md:18
msgid "zero or more statements."
msgstr ""

#: src/syntax-extensions/expansion.md:20
msgid ""
"In other words, _where_ you can invoke a syntax extension determines what "
"its result will be interpreted as."
msgstr ""

#: src/syntax-extensions/expansion.md:22
msgid ""
"The compiler will take this AST node and completely replace the syntax "
"extension's invocation node with the output node. _This is a structural "
"operation_, not a textual one!"
msgstr ""

#: src/syntax-extensions/expansion.md:25
msgid "For example, consider the following:"
msgstr ""

#: src/syntax-extensions/expansion.md:31
msgid "We can visualize this partial AST as follows:"
msgstr ""

#: src/syntax-extensions/expansion.md:47
msgid ""
"From context, `four!()` _must_ expand to an expression (the initializer can "
"_only_ be an expression). Thus, whatever the actual expansion is, it will be "
"interpreted as a complete expression. In this case, we will assume `four!` "
"is defined such that it expands to the expression `1 + 3`. As a result, "
"expanding this invocation will result in the AST changing to:"
msgstr ""

#: src/syntax-extensions/expansion.md:69
msgid "This can be written out like so:"
msgstr ""

#: src/syntax-extensions/expansion.md:75
msgid ""
"Note that we added parentheses _despite_ them not being in the expansion. "
"Remember that the compiler always treats the expansion of a syntax extension "
"as a complete AST node, **not** as a mere sequence of tokens. To put it "
"another way, even if you don't explicitly wrap a complex expression in "
"parentheses, there is no way for the compiler to \"misinterpret\" the "
"result, or change the order of evaluation."
msgstr ""

#: src/syntax-extensions/expansion.md:79
msgid ""
"It is important to understand that syntax extension expansions are treated "
"as AST nodes, as this design has two further implications:"
msgstr ""

#: src/syntax-extensions/expansion.md:81
msgid ""
"In addition to there being a limited number of invocation _positions_, "
"syntax extension can _only_ expand to the kind of AST node the parser "
"_expects_ at that position."
msgstr ""

#: src/syntax-extensions/expansion.md:82
msgid ""
"As a consequence of the above, syntax extension  _absolutely cannot_ expand "
"to incomplete or syntactically invalid constructs."
msgstr ""

#: src/syntax-extensions/expansion.md:84
msgid ""
"There is one further thing to note about expansion: what happens when a "
"syntax extension expands to something that contains _another_ syntax "
"extension invocation. For example, consider an alternative definition of "
"`four!`; what happens if it expands to `1 + three!()`?"
msgstr ""

#: src/syntax-extensions/expansion.md:91
msgid "Expands to:"
msgstr ""

#: src/syntax-extensions/expansion.md:97
msgid ""
"This is resolved by the compiler checking the result of expansions for "
"additional syntax extension invocations, and expanding them. Thus, a second "
"expansion step turns the above into:"
msgstr ""

#: src/syntax-extensions/expansion.md:104
msgid ""
"The takeaway here is that expansion happens in \"passes\"; as many as is "
"needed to completely expand all invocations."
msgstr ""

#: src/syntax-extensions/expansion.md:107
msgid ""
"Well, not _quite_. In fact, the compiler imposes an upper limit on the "
"number of such recursive passes it is willing to run before giving up. This "
"is known as the syntax extension recursion limit and defaults to 128. If the "
"128th expansion contains a syntax extension invocation, the compiler will "
"abort with an error indicating that the recursion limit was exceeded."
msgstr ""

#: src/syntax-extensions/expansion.md:112
msgid ""
"This limit can be raised using the `#![recursion_limit=\"…\"]` "
"[attribute](https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute), "
"though it _must_ be done crate-wide. Generally, it is recommended to try and "
"keep syntax extension below this limit wherever possible as it may impact "
"compilation times."
msgstr ""

#: src/syntax-extensions/hygiene.md:3
msgid ""
"Hygiene is an important concept for macros. It describes the ability for a "
"macro to work in its own syntax context, not affecting nor being affected by "
"its surroundings. In other words this means that a syntax extension should "
"be invocable anywhere without interfering with its surrounding context."
msgstr ""

#: src/syntax-extensions/hygiene.md:7
msgid ""
"In a perfect world all syntax extensions in Rust would be fully hygienic, "
"unfortunately this isn't the case, so care should be taken to avoid writing "
"syntax extensions that aren't fully hygienic. We will go into general "
"hygiene concepts here which will be touched upon in the corresponding "
"hygiene chapters for the different syntax extensions Rust has to offer."
msgstr ""

#: src/syntax-extensions/hygiene.md:10
#: src/decl-macros/macros-methodical.md:265
msgid " "
msgstr ""

#: src/syntax-extensions/hygiene.md:12
msgid ""
"Hygiene mainly affects identifiers and paths emitted by syntax extensions. "
"In short, if an identifier created by a syntax extension cannot be accessed "
"by the environment where the syntax extension has been invoked it is "
"hygienic in regards to that identifier. Likewise, if an identifier used in a "
"syntax extension cannot reference something defined outside of a syntax "
"extension it is considered hygienic."
msgstr ""

#: src/syntax-extensions/hygiene.md:16
msgid ""
"**Note**: The terms `create` and `use` refer to the position the identifier "
"is in. That is the `Foo` in `struct Foo {}` or the `foo` in `let foo = …;` "
"are created in the sense that they introduce something new under the name, "
"but the `Foo` in `fn foo(_: Foo) {}` or the `foo` in `foo + 3` are usages in "
"the sense that they are referring to something existing."
msgstr ""

#: src/syntax-extensions/hygiene.md:20
msgid "This is best shown by example."
msgstr ""

#: src/syntax-extensions/hygiene.md:22
msgid ""
"Let's assume we have some syntax extension `make_local` that expands to `let "
"local = 0;`, that is it _creates_ the identifier `local`. Then given the "
"following snippet:"
msgstr ""

#: src/syntax-extensions/hygiene.md:29
msgid ""
"If the `local` in `assert_eq!(local, 0);` resolves to the local defined by "
"the syntax extension, the syntax extension is not hygienic (at least in "
"regards to local names/bindings)."
msgstr ""

#: src/syntax-extensions/hygiene.md:31
msgid ""
"Now let's assume we have some syntax extension `use_local` that expands to "
"`local = 42;`, that is it makes _use_ of the identifier `local`. Then given "
"the following snippet:"
msgstr ""

#: src/syntax-extensions/hygiene.md:38
msgid ""
"If the `local` inside of the syntax extension for the given invocation "
"resolves to the local defined before its invocation, the syntax extension is "
"not hygienic either."
msgstr ""

#: src/syntax-extensions/hygiene.md:40
msgid ""
"This is a rather short introduction to the general concept of hygiene. It "
"will be explained in more depth in the corresponding [`macro_rules!` "
"`hygiene`](../decl-macros/minutiae/hygiene.md) and [proc-macro "
"`hygiene`](../proc-macros/hygiene.md) chapters, with their specific "
"peculiarities."
msgstr ""

#: src/syntax-extensions/debugging.md:3
msgid ""
"`rustc` provides a number of tools to debug general syntax extensions, as "
"well as some more specific ones tailored towards declarative and procedural "
"macros respectively."
msgstr ""

#: src/syntax-extensions/debugging.md:6
msgid ""
"Sometimes, it is what the extension _expands to_ that proves problematic as "
"you do not usually see the expanded code. Fortunately `rustc` offers the "
"ability to look at the expanded code via the unstable `-Zunpretty=expanded` "
"argument. Given the following code:"
msgstr ""

#: src/syntax-extensions/debugging.md:10
msgid ""
"```rust,ignore\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S {\n"
"    ($e:expr) => {String::from($e)};\n"
"}\n"
"\n"
"fn main() {\n"
"    let world = S!(\"World\");\n"
"    println!(\"Hello, {}!\", world);\n"
"}\n"
"```"
msgstr ""

#: src/syntax-extensions/debugging.md:22
msgid "compiled with the following command:"
msgstr ""

#: src/syntax-extensions/debugging.md:28
msgid "produces the following output (modified for formatting):"
msgstr ""

#: src/syntax-extensions/debugging.md:30
msgid ""
"```rust,ignore\n"
"#![feature(prelude_import)]\n"
"#[prelude_import]\n"
"use std::prelude::rust_2018::*;\n"
"#[macro_use]\n"
"extern crate std;\n"
"// Shorthand for initializing a `String`.\n"
"macro_rules! S { ($e : expr) => { String :: from($e) } ; }\n"
"\n"
"fn main() {\n"
"    let world = String::from(\"World\");\n"
"    {\n"
"        ::std::io::_print(\n"
"            ::core::fmt::Arguments::new_v1(\n"
"                &[\"Hello, \", \"!\\n"
"\"],\n"
"                &match (&world,) {\n"
"                    (arg0,) => [\n"
"                        ::core::fmt::ArgumentV1::new(arg0, "
"::core::fmt::Display::fmt)\n"
"                    ],\n"
"                }\n"
"            )\n"
"        );\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/syntax-extensions/debugging.md:56
msgid ""
"But not just `rustc` exposes means to aid in debugging syntax extensions. "
"For the aforementioned `-Zunpretty=expanded` option, there exists a nice "
"`cargo` plugin called "
"[`cargo-expand`](https://github.com/dtolnay/cargo-expand) made by "
"[`dtolnay`](https://github.com/dtolnay) which is basically just a wrapper "
"around it."
msgstr ""

#: src/syntax-extensions/debugging.md:59
msgid ""
"You can also use the [playground](https://play.rust-lang.org/), clicking on "
"its `TOOLS` button in the top right gives you the option to expand syntax "
"extensions as well!"
msgstr ""

#: src/decl-macros.md:3
msgid ""
"This chapter will introduce Rust's declarative macro system: "
"[`macro_rules!`](https://doc.rust-lang.org/reference/macros-by-example.html)."
msgstr ""

#: src/decl-macros.md:5
msgid ""
"There are two different introductions in this chapter, a "
"[methodical](./decl-macros/macros-methodical.md) and a "
"[practical](./decl-macros/macros-practical.md)."
msgstr ""

#: src/decl-macros.md:7
msgid ""
"The former will attempt to give you a complete and thorough explanation of "
"_how_ the system works, while the latter one will cover more practical "
"examples. As such, the [methodical "
"introduction](./decl-macros/macros-methodical.md) is intended for people who "
"just want the system as a whole explained, while the [practical "
"introduction](./decl-macros/macros-practical.md) guides one through the "
"implementation of a single macro."
msgstr ""

#: src/decl-macros.md:10
msgid ""
"Following up the two introductions it offers some generally very useful "
"[patterns](./decl-macros/patterns.md) and [building "
"blocks](./decl-macros/building-blocks.md) for creating feature-rich macros."
msgstr ""

#: src/decl-macros.md:12
msgid ""
"Other resources about declarative macros include the [Macros chapter of the "
"Rust Book](https://doc.rust-lang.org/book/ch19-06-macros.html) which is a "
"more approachable, high-level explanation as well as the reference "
"[chapter](https://doc.rust-lang.org/reference/macros-by-example.html) which "
"goes more into the precise details of things."
msgstr ""

#: src/decl-macros.md:14
msgid ""
"**Note**: This book will usually use the term "
"_mbe_(**M**acro-**B**y-**E**xample), _mbe macro_ or `macro_rules!` macro "
"when talking about `macro_rules!` macros."
msgstr ""

#: src/decl-macros/macros-methodical.md:1
msgid "Macros, A Methodical Introduction"
msgstr ""

#: src/decl-macros/macros-methodical.md:3
msgid ""
"This chapter will introduce Rust's declarative "
"[Macro-By-Example](https://doc.rust-lang.org/reference/macros-by-example.html) "
"system by explaining the system as a whole. It will do so by first going "
"into the construct's syntax and its key parts and then following it up with "
"more general information that one should at least be aware of."
msgstr ""

#: src/decl-macros/macros-methodical.md:9
msgid "`macro_rules!`"
msgstr ""

#: src/decl-macros/macros-methodical.md:11
msgid ""
"With all that in mind, we can introduce `macro_rules!` itself. As noted "
"previously, `macro_rules!` is _itself_ a syntax extension, meaning it is "
"_technically_ not part of the Rust syntax. It uses the following forms:"
msgstr ""

#: src/decl-macros/macros-methodical.md:15
msgid ""
"```rust,ignore\n"
"macro_rules! $name {\n"
"    $rule0 ;\n"
"    $rule1 ;\n"
"    // …\n"
"    $ruleN ;\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-methodical.md:24
msgid ""
"There must be _at least_ one rule, and you can omit the semicolon after the "
"last rule. You can use brackets(`[]`), parentheses(`()`) or braces(`{}`)."
msgstr ""

#: src/decl-macros/macros-methodical.md:27
msgid "Each _\"rule\"_ looks like the following:"
msgstr ""

#: src/decl-macros/macros-methodical.md:33
msgid ""
"Like before, the types of parentheses used can be any kind, but parentheses "
"around the matcher and braces around the expansion are somewhat "
"conventional. The expansion part of a rule is also called its _transcriber_."
msgstr ""

#: src/decl-macros/macros-methodical.md:36
msgid ""
"Note that the choice of the parentheses does not matter in regards to how "
"the mbe macro may be invoked. In fact, function-like macros can be invoked "
"with any kind of parentheses as well, but invocations with `{ .. }` and `( "
"... );`, notice the trailing semicolon, are special in that their expansion "
"will _always_ be parsed as an _item_."
msgstr ""

#: src/decl-macros/macros-methodical.md:39
msgid ""
"If you are wondering, the `macro_rules!` invocation expands to... _nothing_. "
"At least, nothing that appears in the AST; rather, it manipulates "
"compiler-internal structures to register the mbe macro. As such, you can "
"_technically_ use `macro_rules!` in any position where an empty expansion is "
"valid."
msgstr ""

#: src/decl-macros/macros-methodical.md:43
msgid "Matching"
msgstr ""

#: src/decl-macros/macros-methodical.md:45
msgid ""
"When a `macro_rules!` macro is invoked, the `macro_rules!` interpreter goes "
"through the rules one by one, in declaration order. For each rule, it tries "
"to match the contents of the input token tree against that rule's `matcher`. "
"A matcher must match the _entirety_ of the input to be considered a match."
msgstr ""

#: src/decl-macros/macros-methodical.md:49
msgid ""
"If the input matches the matcher, the invocation is replaced by the "
"`expansion`; otherwise, the next rule is tried. If all rules fail to match, "
"the expansion fails with an error."
msgstr ""

#: src/decl-macros/macros-methodical.md:52
msgid "The simplest example is of an empty matcher:"
msgstr ""

#: src/decl-macros/macros-methodical.md:60
msgid ""
"This matches if and only if the input is also empty (_i.e._ `four!()`, "
"`four![]` or `four!{}`)."
msgstr ""

#: src/decl-macros/macros-methodical.md:62
msgid ""
"Note that the specific grouping tokens you use when you invoke the "
"function-like macro _are not_ matched, they are in fact not passed to the "
"invocation at all. That is, you can invoke the above macro as `four![]` and "
"it will still match. Only the _contents_ of the input token tree are "
"considered."
msgstr ""

#: src/decl-macros/macros-methodical.md:66
msgid ""
"Matchers can also contain literal token trees, which must be matched "
"exactly. This is done by simply writing the token trees normally. For "
"example, to match the sequence `4 fn ['spang \"whammo\"] @_@`, you would "
"write:"
msgstr ""

#: src/decl-macros/macros-methodical.md:70
msgid ""
"```rust,ignore\n"
"macro_rules! gibberish {\n"
"    (4 fn ['spang \"whammo\"] @_@) => {...};\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-methodical.md:76
msgid "You can use any token tree that you can write."
msgstr ""

#: src/decl-macros/macros-methodical.md:78
msgid "Metavariables"
msgstr ""

#: src/decl-macros/macros-methodical.md:80
msgid ""
"Matchers can also contain captures. These allow input to be matched based on "
"some general grammar category, with the result captured to a metavariable "
"which can then be substituted into the output."
msgstr ""

#: src/decl-macros/macros-methodical.md:83
msgid ""
"Captures are written as a dollar (`$`) followed by an identifier, a colon "
"(`:`), and finally the kind of capture which is also called the "
"fragment-specifier, which must be one of the following:"
msgstr ""

#: src/decl-macros/macros-methodical.md:85
msgid ""
"[`block`](./minutiae/fragment-specifiers.md#block): a block (i.e. a block of "
"statements and/or an expression, surrounded by braces)"
msgstr ""

#: src/decl-macros/macros-methodical.md:86
msgid "[`expr`](./minutiae/fragment-specifiers.md#expr): an expression"
msgstr ""

#: src/decl-macros/macros-methodical.md:87
msgid ""
"[`ident`](./minutiae/fragment-specifiers.md#ident): an identifier (this "
"includes keywords)"
msgstr ""

#: src/decl-macros/macros-methodical.md:88
msgid ""
"[`item`](./minutiae/fragment-specifiers.md#item): an item, like a function, "
"struct, module, impl, etc."
msgstr ""

#: src/decl-macros/macros-methodical.md:89
msgid ""
"[`lifetime`](./minutiae/fragment-specifiers.md#lifetime): a lifetime (e.g. "
"`'foo`, `'static`, ...)"
msgstr ""

#: src/decl-macros/macros-methodical.md:90
msgid ""
"[`literal`](./minutiae/fragment-specifiers.md#literal): a literal (e.g. "
"`\"Hello World!\"`, `3.14`, `'🦀'`, ...)"
msgstr ""

#: src/decl-macros/macros-methodical.md:91
msgid ""
"[`meta`](./minutiae/fragment-specifiers.md#meta): a meta item; the things "
"that go inside the `#[...]` and `#![...]` attributes"
msgstr ""

#: src/decl-macros/macros-methodical.md:92
msgid "[`pat`](./minutiae/fragment-specifiers.md#pat): a pattern"
msgstr ""

#: src/decl-macros/macros-methodical.md:93
msgid ""
"[`path`](./minutiae/fragment-specifiers.md#path): a path (e.g. `foo`, "
"`::std::mem::replace`, `transmute::<_, int>`, …)"
msgstr ""

#: src/decl-macros/macros-methodical.md:94
msgid "[`stmt`](./minutiae/fragment-specifiers.md#stmt): a statement"
msgstr ""

#: src/decl-macros/macros-methodical.md:95
msgid "[`tt`](./minutiae/fragment-specifiers.md#tt): a single token tree"
msgstr ""

#: src/decl-macros/macros-methodical.md:96
msgid "[`ty`](./minutiae/fragment-specifiers.md#ty): a type"
msgstr ""

#: src/decl-macros/macros-methodical.md:97
msgid ""
"[`vis`](./minutiae/fragment-specifiers.md#vis): a possible empty visibility "
"qualifier (e.g. `pub`, `pub(in crate)`, ...)"
msgstr ""

#: src/decl-macros/macros-methodical.md:99
msgid ""
"For more in-depth description of the fragment specifiers, check out the "
"[Fragment Specifiers](./minutiae/fragment-specifiers.md) chapter."
msgstr ""

#: src/decl-macros/macros-methodical.md:101
msgid ""
"For example, here is a `macro_rules!` macro which captures its input as an "
"expression under the metavariable `$e`:"
msgstr ""

#: src/decl-macros/macros-methodical.md:109
msgid ""
"These metavariables leverage the Rust compiler's parser, ensuring that they "
"are always \"correct\". An `expr` metavariables will _always_ capture a "
"complete, valid expression for the version of Rust being compiled."
msgstr ""

#: src/decl-macros/macros-methodical.md:112
msgid ""
"You can mix literal token trees and metavariables, within limits (explained "
"in [Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md))."
msgstr ""

#: src/decl-macros/macros-methodical.md:114
msgid ""
"To refer to a metavariable you simply write `$name`, as the type of the "
"variable is already specified in the matcher. For example:"
msgstr ""

#: src/decl-macros/macros-methodical.md:122
msgid ""
"Much like macro expansion, metavariables are substituted as complete AST "
"nodes. This means that no matter what sequence of tokens is captured by "
"`$e`, it will be interpreted as a single, complete expression."
msgstr ""

#: src/decl-macros/macros-methodical.md:125
msgid "You can also have multiple metavariables in a single matcher:"
msgstr ""

#: src/decl-macros/macros-methodical.md:133
msgid "And use them as often as you like in the expansion:"
msgstr ""

#: src/decl-macros/macros-methodical.md:144
msgid ""
"There is also a special metavariable called "
"[`$crate`](./minutiae/hygiene.md#crate) which can be used to refer to the "
"current crate."
msgstr ""

#: src/decl-macros/macros-methodical.md:149
msgid "Repetitions"
msgstr ""

#: src/decl-macros/macros-methodical.md:151
msgid ""
"Matchers can contain repetitions. These allow a sequence of tokens to be "
"matched. These have the general form `$ ( ... ) sep rep`."
msgstr ""

#: src/decl-macros/macros-methodical.md:154
msgid "`$` is a literal dollar token."
msgstr ""

#: src/decl-macros/macros-methodical.md:155
msgid "`( ... )` is the paren-grouped matcher being repeated."
msgstr ""

#: src/decl-macros/macros-methodical.md:156
msgid ""
"`sep` is an _optional_ separator token. It may not be a delimiter or one of "
"the repetition operators. Common examples are `,` and `;`."
msgstr ""

#: src/decl-macros/macros-methodical.md:158
msgid "`rep` is the _required_ repeat operator. Currently, this can be:"
msgstr ""

#: src/decl-macros/macros-methodical.md:159
msgid "`?`: indicating at most one repetition"
msgstr ""

#: src/decl-macros/macros-methodical.md:160
msgid "`*`: indicating zero or more repetitions"
msgstr ""

#: src/decl-macros/macros-methodical.md:161
msgid "`+`: indicating one or more repetitions"
msgstr ""

#: src/decl-macros/macros-methodical.md:163
msgid ""
"Since `?` represents at most one occurrence, it cannot be used with a "
"separator."
msgstr ""

#: src/decl-macros/macros-methodical.md:165
msgid ""
"Repetitions can contain any other valid matcher, including literal token "
"trees, metavariables, and other repetitions allowing arbitrary nesting."
msgstr ""

#: src/decl-macros/macros-methodical.md:167
msgid ""
"Repetitions use the same syntax in the expansion and repeated metavariables "
"can only be accessed inside of repetitions in the expansion."
msgstr ""

#: src/decl-macros/macros-methodical.md:169
msgid ""
"For example, below is a mbe macro which formats each element as a string. It "
"matches zero or more comma-separated expressions and expands to an "
"expression that constructs a vector."
msgstr ""

#: src/decl-macros/macros-methodical.md:172
msgid ""
"```rust\n"
"macro_rules! vec_strs {\n"
"    (\n"
"        // Start a repetition:\n"
"        $(\n"
"            // Each repeat must contain an expression...\n"
"            $element:expr\n"
"        )\n"
"        // ...separated by commas...\n"
"        ,\n"
"        // ...zero or more times.\n"
"        *\n"
"    ) => {\n"
"        // Enclose the expansion in a block so that we can use\n"
"        // multiple statements.\n"
"        {\n"
"            let mut v = Vec::new();\n"
"\n"
"            // Start a repetition:\n"
"            $(\n"
"                // Each repeat will contain the following statement, with\n"
"                // $element replaced with the corresponding expression.\n"
"                v.push(format!(\"{}\", $element));\n"
"            )*\n"
"\n"
"            v\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let s = vec_strs![1, \"a\", true, 3.14159f32];\n"
"    assert_eq!(s, &[\"1\", \"a\", \"true\", \"3.14159\"]);\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-methodical.md:208
msgid ""
"You can repeat multiple metavariables in a single repetition as long as all "
"metavariables repeat equally often. So this invocation of the following "
"macro works:"
msgstr ""

#: src/decl-macros/macros-methodical.md:221
msgid "But this does not:"
msgstr ""

#: src/decl-macros/macros-methodical.md:233
msgid "failing with the following error"
msgstr ""

#: src/decl-macros/macros-methodical.md:245
#: src/decl-macros/minutiae/metavar-expr.md:3
msgid ""
"_RFC_: "
"[rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md) "
" \n"
"_Tracking Issue_: "
"[rust#83527](https://github.com/rust-lang/rust/issues/83527)  \n"
"_Feature_: `#![feature(macro_metavar_expr)]`"
msgstr ""

#: src/decl-macros/macros-methodical.md:249
msgid ""
"Transcriber can contain what is called metavariable expressions. "
"Metavariable expressions provide transcribers with information about "
"metavariables that are otherwise not easily obtainable. With the exception "
"of the `$$` expression, these have the general form `$ { op(...) }`. "
"Currently all metavariable expressions but `$$` deal with repetitions."
msgstr ""

#: src/decl-macros/macros-methodical.md:254
msgid ""
"The following expressions are available with `ident` being the name of a "
"bound metavariable and `depth` being an integer literal:"
msgstr ""

#: src/decl-macros/macros-methodical.md:256
msgid ""
"`${count(ident)}`: The number of times `$ident` repeats in the inner-most "
"repetition in total. This is equivalent to `${count(ident, 0)}`."
msgstr ""

#: src/decl-macros/macros-methodical.md:257
msgid ""
"`${count(ident, depth)}`: The number of times `$ident` repeats in the "
"repetition at `depth`."
msgstr ""

#: src/decl-macros/macros-methodical.md:258
msgid ""
"`${index()}`: The current repetition index of the inner-most repetition. "
"This is equivalent to `${index(0)}`."
msgstr ""

#: src/decl-macros/macros-methodical.md:259
msgid ""
"`${index(depth)}`: The current index of the repetition at `depth`, counting "
"outwards."
msgstr ""

#: src/decl-macros/macros-methodical.md:260
msgid ""
"`${length()}`: The number of times the inner-most repetition will repeat "
"for. This is equivalent to `${length(0)}`."
msgstr ""

#: src/decl-macros/macros-methodical.md:261
msgid ""
"`${length(depth)}`: The number of times the repetition at `depth` will "
"repeat for, counting outwards."
msgstr ""

#: src/decl-macros/macros-methodical.md:262
msgid ""
"`${ignore(ident)}`: Binds `$ident` for repetition, while expanding to "
"nothing."
msgstr ""

#: src/decl-macros/macros-methodical.md:263
msgid ""
"`$$`:\tExpands to a single `$`, effectively escaping the `$` token so it "
"won't be transcribed."
msgstr ""

#: src/decl-macros/macros-methodical.md:267
msgid ""
"For the complete grammar definition you may want to consult the [Macros By "
"Example](https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-example) "
"chapter of the Rust reference."
msgstr ""

#: src/decl-macros/macros-practical.md:1
msgid "Macros, A Practical Introduction"
msgstr ""

#: src/decl-macros/macros-practical.md:3
msgid ""
"This chapter will introduce Rust's declarative "
"[Macro-By-Example](https://doc.rust-lang.org/reference/macros-by-example.html) "
"system using a relatively simple, practical example. It does _not_ attempt "
"to explain all of the intricacies of the system; its goal is to get you "
"comfortable with how and why macros are written."
msgstr ""

#: src/decl-macros/macros-practical.md:6
msgid ""
"There is also the [Macros chapter of the Rust "
"Book](https://doc.rust-lang.org/book/ch19-06-macros.html) which is another "
"high-level explanation, and the [methodical introduction](../decl-macros.md) "
"chapter of this book, which explains the macro system in detail."
msgstr ""

#: src/decl-macros/macros-practical.md:8
msgid "A Little Context"
msgstr ""

#: src/decl-macros/macros-practical.md:10
msgid ""
"**Note**: don't panic! What follows is the only math that will be talked "
"about. You can quite safely skip this section if you just want to get to the "
"meat of the article."
msgstr ""

#: src/decl-macros/macros-practical.md:13
msgid ""
"If you aren't familiar, a recurrence relation is a sequence where each value "
"is defined in terms of one or more _previous_ values, with one or more "
"initial values to get the whole thing started. For example, the [Fibonacci "
"sequence](https://en.wikipedia.org/wiki/Fibonacci_number) can be defined by "
"the relation:"
msgstr ""

#: src/decl-macros/macros-practical.md:16
msgid "\\\\\\[F\\_{n} = 0, 1, ..., F\\_{n-2} + F\\_{n-1}\\\\\\]"
msgstr ""

#: src/decl-macros/macros-practical.md:18
msgid ""
"Thus, the first two numbers in the sequence are 0 and 1, with the third "
"being \\\\( F\\_{0} + F\\_{1} = 0 + 1 = 1\\\\), the fourth \\\\( F\\_{1} + "
"F\\_{2} = 1 + 1 = 2\\\\), and so on forever."
msgstr ""

#: src/decl-macros/macros-practical.md:20
msgid ""
"Now, _because_ such a sequence can go on forever, that makes defining a "
"`fibonacci` function a little tricky, since you obviously don't want to try "
"returning a complete vector. What you _want_ is to return something which "
"will lazily compute elements of the sequence as needed."
msgstr ""

#: src/decl-macros/macros-practical.md:23
msgid ""
"In Rust, that means producing an "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html). This "
"is not especially _hard_, but there is a fair amount of boilerplate "
"involved: you need to define a custom type, work out what state needs to be "
"stored in it, then implement the "
"[`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) trait "
"for it."
msgstr ""

#: src/decl-macros/macros-practical.md:26
msgid ""
"However, recurrence relations are simple enough that almost all of these "
"details can be abstracted out with a little `macro_rules!` macro-based code "
"generation."
msgstr ""

#: src/decl-macros/macros-practical.md:28
msgid "So, with all that having been said, let's get started."
msgstr ""

#: src/decl-macros/macros-practical.md:32
msgid "Construction"
msgstr ""

#: src/decl-macros/macros-practical.md:34
msgid ""
"Usually, when working on a new `macro_rules!` macro, the first thing I do is "
"decide what the invocation should look like. In this specific case, my first "
"attempt looked like this:"
msgstr ""

#: src/decl-macros/macros-practical.md:37
msgid ""
"```rust,ignore\n"
"let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:43
msgid ""
"From that, we can take a stab at how the `macro_rules!` macro should be "
"defined, even if we aren't sure of the actual expansion. This is useful "
"because if you can't figure out how to parse the input syntax, then _maybe_ "
"you need to change it."
msgstr ""

#: src/decl-macros/macros-practical.md:53
msgid ""
"Assuming you aren't familiar with the syntax, allow me to elucidate. This is "
"defining a syntax extension, using the "
"[`macro_rules!`](./macros-methodical.md) system, called `recurrence!`. This "
"`macro_rules!` macro has a single parsing rule. That rule says the input to "
"the invocation must match:"
msgstr ""

#: src/decl-macros/macros-practical.md:58
msgid "the literal token sequence `a` `[` `n` `]` `=`,"
msgstr ""

#: src/decl-macros/macros-practical.md:59
msgid ""
"a [repeating](./macros-methodical.md#repetitions) (the `$( ... )`) sequence, "
"using `,` as a separator, and one or more (`+`) repeats of:"
msgstr ""

#: src/decl-macros/macros-practical.md:60
msgid ""
"a valid _expression_ captured into the "
"[metavariable](./macros-methodical.md#metavariables) `inits` (`$inits:expr`)"
msgstr ""

#: src/decl-macros/macros-practical.md:61
msgid "the literal token sequence `,` `...` `,`,"
msgstr ""

#: src/decl-macros/macros-practical.md:62
msgid ""
"a valid _expression_ captured into the "
"[metavariable](./macros-methodical.md#metavariables) `recur` (`$recur:expr`)."
msgstr ""

#: src/decl-macros/macros-practical.md:67
msgid ""
"Finally, the rule says that _if_ the input matches this rule, then the "
"invocation should be replaced by the token sequence `/* ... */`."
msgstr ""

#: src/decl-macros/macros-practical.md:69
msgid ""
"It's worth noting that `inits`, as implied by the name, actually contains "
"_all_ the expressions that match in this position, not just the first or "
"last. What's more, it captures them _as a sequence_ as opposed to, say, "
"irreversibly pasting them all together. Also note that you can do \"zero or "
"more\" with a repetition by using `*` instead of `+` and even optional, "
"\"zero or one\" with `?`."
msgstr ""

#: src/decl-macros/macros-practical.md:73
msgid ""
"As an exercise, let's take the proposed input and feed it through the rule, "
"to see how it is processed. The \"Position\" column will show which part of "
"the syntax pattern needs to be matched against next, denoted by a \"⌂\". "
"Note that in some cases, there might be more than one possible \"next\" "
"element to match against. \"Input\" will contain all of the tokens that have "
"_not_ been consumed yet. `inits` and `recur` will contain the contents of "
"those bindings."
msgstr ""

#: src/decl-macros/macros-practical.md:265
msgid ""
"The key take-away from this is that the macro system will _try_ to "
"incrementally match the tokens provided as input to the macro against the "
"provided rules. We'll come back to the \"try\" part."
msgstr ""

#: src/decl-macros/macros-practical.md:268
msgid ""
"Now, let's begin writing the final, fully expanded form. For this expansion, "
"I was looking for something like:"
msgstr ""

#: src/decl-macros/macros-practical.md:279
msgid ""
"This will be the actual iterator type. `mem` will be the memo buffer to hold "
"the last few values so the recurrence can be computed. `pos` is to keep "
"track of the value of `n`."
msgstr ""

#: src/decl-macros/macros-practical.md:283
msgid ""
"**Aside**: I've chosen `u64` as a \"sufficiently large\" type for the "
"elements of this sequence. Don't worry about how this will work out for "
"_other_ sequences; we'll come to it."
msgstr ""

#: src/decl-macros/macros-practical.md:297
msgid ""
"We need a branch to yield the initial values of the sequence; nothing tricky."
msgstr ""

#: src/decl-macros/macros-practical.md:314
msgid ""
"This is a bit harder; we'll come back and look at _how_ exactly to define "
"`a`. Also, `TODO_shuffle_down_and_append` is another placeholder; I want "
"something that places `next_val` on the end of the array, shuffling the rest "
"down by one space, dropping the 0th element."
msgstr ""

#: src/decl-macros/macros-practical.md:318
msgid ""
"```rust,ignore\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:326
msgid ""
"Lastly, return an instance of our new structure, which can then be iterated "
"over. To summarize, the complete expansion is:"
msgstr ""

#: src/decl-macros/macros-practical.md:329
msgid ""
"```rust,ignore\n"
"let fib = {\n"
"    struct Recurrence {\n"
"        mem: [u64; 2],\n"
"        pos: usize,\n"
"    }\n"
"\n"
"    impl Iterator for Recurrence {\n"
"        type Item = u64;\n"
"\n"
"        fn next(&mut self) -> Option<u64> {\n"
"            if self.pos < 2 {\n"
"                let next_val = self.mem[self.pos];\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            } else {\n"
"                let a = /* something */;\n"
"                let n = self.pos;\n"
"                let next_val = (a[n-2] + a[n-1]);\n"
"\n"
"                self.mem.TODO_shuffle_down_and_append(next_val.clone());\n"
"\n"
"                self.pos += 1;\n"
"                Some(next_val)\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    Recurrence { mem: [0, 1], pos: 0 }\n"
"};\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:363
msgid ""
"**Aside**: Yes, this _does_ mean we're defining a different `Recurrence` "
"struct and its implementation for each invocation. Most of this will "
"optimise away in the final binary."
msgstr ""

#: src/decl-macros/macros-practical.md:366
msgid ""
"It's also useful to check your expansion as you're writing it. If you see "
"anything in the expansion that needs to vary with the invocation, but "
"_isn't_ in the actual accepted syntax of our macro, you should work out "
"where to introduce it. In this case, we've added `u64`, but that's not "
"necessarily what the user wants, nor is it in the macro syntax. So let's fix "
"that."
msgstr ""

#: src/decl-macros/macros-practical.md:370
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ "
"};\n"
"}\n"
"\n"
"/*\n"
"let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"for e in fib.take(10) { println!(\"{}\", e) }\n"
"*/\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:383
msgid "Here, I've added a new metavariable: `sty` which should be a type."
msgstr ""

#: src/decl-macros/macros-practical.md:385
msgid ""
"**Aside**: if you're wondering, the bit after the colon in a metavariable "
"can be one of several kinds of syntax matchers. The most common ones are "
"`item`, `expr`, and `ty`. A complete explanation can be found in [Macros, A "
"Methodical Introduction; `macro_rules!` "
"(Matchers)](./macros-methodical.md#metavariables)."
msgstr ""

#: src/decl-macros/macros-practical.md:389
msgid ""
"There's one other thing to be aware of: in the interests of future-proofing "
"the language, the compiler restricts what tokens you're allowed to put "
"_after_ a matcher, depending on what kind it is. Typically, this comes up "
"when trying to match expressions or statements; those can _only_ be followed "
"by one of `=>`, `,`, and `;`."
msgstr ""

#: src/decl-macros/macros-practical.md:393
msgid ""
"A complete list can be found in [Macros, A Methodical Introduction; "
"Minutiae; Metavariables and Expansion "
"Redux](./minutiae/metavar-and-expansion.md)."
msgstr ""

#: src/decl-macros/macros-practical.md:395
msgid "Indexing and Shuffling"
msgstr ""

#: src/decl-macros/macros-practical.md:397
msgid ""
"I will skim a bit over this part, since it's effectively tangential to the "
"macro-related stuff. We want to make it so that the user can access previous "
"values in the sequence by indexing `a`; we want it to act as a sliding "
"window keeping the last few (in this case, 2) elements of the sequence."
msgstr ""

#: src/decl-macros/macros-practical.md:401
msgid "We can do this pretty easily with a wrapper type:"
msgstr ""

#: src/decl-macros/macros-practical.md:425
msgid ""
"**Aside**: since lifetimes come up _a lot_ with people new to Rust, a quick "
"explanation: `'a` and `'b` are lifetime parameters that are used to track "
"where a reference (_i.e._ a borrowed pointer to some data) is valid. In this "
"case, `IndexOffset` borrows a reference to our iterator's data, so it needs "
"to keep track of how long it's allowed to hold that reference for, using "
"`'a`."
msgstr ""

#: src/decl-macros/macros-practical.md:428
msgid ""
"`'b` is used because the `Index::index` function (which is how subscript "
"syntax is actually implemented) is _also_ parameterized on a lifetime, on "
"account of returning a borrowed reference. `'a` and `'b` are not necessarily "
"the same thing in all cases. The borrow checker will make sure that even "
"though we don't explicitly relate `'a` and `'b` to one another, we don't "
"accidentally violate memory safety."
msgstr ""

#: src/decl-macros/macros-practical.md:432
msgid "This changes the definition of `a` to:"
msgstr ""

#: src/decl-macros/macros-practical.md:438
msgid ""
"The only remaining question is what to do about "
"`TODO_shuffle_down_and_append`. I wasn't able to find a method in the "
"standard library with exactly the semantics I wanted, but it isn't hard to "
"do by hand."
msgstr ""

#: src/decl-macros/macros-practical.md:452
msgid ""
"This swaps the new value into the end of the array, swapping the other "
"elements down one space."
msgstr ""

#: src/decl-macros/macros-practical.md:454
msgid ""
"**Aside**: doing it this way means that this code will work for non-copyable "
"types, as well."
msgstr ""

#: src/decl-macros/macros-practical.md:456
msgid "The working code thus far now looks like this:"
msgstr ""

#: src/decl-macros/macros-practical.md:458
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ "
"};\n"
"}\n"
"\n"
"fn main() {\n"
"    /*\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"    */\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"\n"
"        struct Recurrence {\n"
"            mem: [u64; 2],\n"
"            pos: usize,\n"
"        }\n"
"\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; 2],\n"
"            offset: usize,\n"
"        }\n"
"\n"
"        impl<'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(2);\n"
"\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < 2 {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset { slice: &self.mem, offset: n "
"};\n"
"                        a[n-2] + a[n-1]\n"
"                    };\n"
"\n"
"                    {\n"
"                        use std::mem::swap;\n"
"\n"
"                        let mut swap_tmp = next_val;\n"
"                        for i in [1,0] {\n"
"                            swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                        }\n"
"                    }\n"
"\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Recurrence { mem: [0, 1], pos: 0 }\n"
"    };\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:536
msgid ""
"Note that I've changed the order of the declarations of `n` and `a`, as well "
"as wrapped them(along with the recurrence expression) in a block. The reason "
"for the first should be obvious(`n` needs to be defined first so I can use "
"it for `a`). The reason for the second is that the borrowed reference "
"`&self.mem` will prevent the swaps later on from happening (you cannot "
"mutate something that is aliased elsewhere). The block ensures that the "
"`&self.mem` borrow expires before then."
msgstr ""

#: src/decl-macros/macros-practical.md:540
msgid ""
"Incidentally, the only reason the code that does the `mem` swaps is in a "
"block is to narrow the scope in which `std::mem::swap` is available, for the "
"sake of being tidy."
msgstr ""

#: src/decl-macros/macros-practical.md:542
msgid "If we take this code and run it, we get:"
msgstr ""

#: src/decl-macros/macros-practical.md:557
msgid ""
"Success! Now, let's copy & paste this into the macro expansion, and replace "
"the expanded code with an invocation. This gives us:"
msgstr ""

#: src/decl-macros/macros-practical.md:561
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) => {\n"
"        {\n"
"            /*\n"
"                What follows here is *literally* the code from before,\n"
"                cut and pasted into a new position. No other changes\n"
"                have been made.\n"
"            */\n"
"\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [u64; 2],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [u64; 2],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = u64;\n"
"\n"
"                fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = u64;\n"
"\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < 2 {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..2).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:640
msgid ""
"Obviously, we aren't _using_ the metavariables yet, but we can change that "
"fairly easily. However, if we try to compile this, `rustc` aborts, telling "
"us:"
msgstr ""

#: src/decl-macros/macros-practical.md:651
msgid ""
"Here, we've run into a limitation of the `macro_rules` system. The problem "
"is that second comma. When it sees it during expansion, `macro_rules` can't "
"decide if it's supposed to parse _another_ expression for `inits`, or `...`. "
"Sadly, it isn't quite clever enough to realise that `...` isn't a valid "
"expression, so it gives up. Theoretically, this _should_ work as desired, "
"but currently doesn't."
msgstr ""

#: src/decl-macros/macros-practical.md:657
msgid ""
"**Aside**: I _did_ fib a little about how our rule would be interpreted by "
"the macro system. In general, it _should_ work as described, but doesn't in "
"this case. The `macro_rules` machinery, as it stands, has its foibles, and "
"its worthwhile remembering that on occasion, you'll need to contort a little "
"to get it to work."
msgstr ""

#: src/decl-macros/macros-practical.md:661
msgid ""
"In this _particular_ case, there are two issues. First, the macro system "
"doesn't know what does and does not constitute the various grammar elements "
"(_e.g._ an expression); that's the parser's job. As such, it doesn't know "
"that `...` isn't an expression. Secondly, it has no way of trying to capture "
"a compound grammar element (like an expression) without 100% committing to "
"that capture."
msgstr ""

#: src/decl-macros/macros-practical.md:666
msgid ""
"In other words, it can ask the parser to try and parse some input as an "
"expression, but the parser will respond to any problems by aborting. The "
"only way the macro system can currently deal with this is to just try to "
"forbid situations where this could be a problem."
msgstr ""

#: src/decl-macros/macros-practical.md:669
msgid ""
"On the bright side, this is a state of affairs that exactly _no one_ is "
"enthusiastic about. The `macro` keyword has already been reserved for a more "
"rigorously-defined future [macro "
"system](https://github.com/rust-lang/rust/issues/39412). Until then, needs "
"must."
msgstr ""

#: src/decl-macros/macros-practical.md:673
msgid ""
"Thankfully, the fix is relatively simple: we remove the comma from the "
"syntax. To keep things balanced, we'll remove _both_ commas around `...`:"
msgstr ""

#: src/decl-macros/macros-practical.md:676
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) => {\n"
"//                                     ^~~ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];\n"
"//                                         ^~~ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:694
msgid ""
"Success! ... or so we thought. Turns out this is being rejected by the "
"compiler nowadays, while it was fine back when this was written. The reason "
"for this is that the compiler now recognizes the `...` as a token, and as we "
"know we may only use `=>`, `,` or `;` after an expression fragment. So "
"unfortunately we are now out of luck as our dreamed up syntax will not work "
"out this way, so let us just choose one that looks the most befitting that "
"we are allowed to use instead, I'd say replacing `,` with `;` works."
msgstr ""

#: src/decl-macros/macros-practical.md:699
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"//                                     ^~~~~~^ changed\n"
"        /* ... */\n"
"#         // Cheat :D\n"
"#         (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"//                                        ^~~~~^ changed\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:717
msgid "Success! But for real this time."
msgstr ""

#: src/decl-macros/macros-practical.md:720
msgid "Substitution"
msgstr ""

#: src/decl-macros/macros-practical.md:722
msgid ""
"Substituting something you've captured in a macro is quite simple; you can "
"insert the contents of a metavariable `$sty:ty` by using `$sty`. So, let's "
"go through and fix the `u64`s:"
msgstr ""

#: src/decl-macros/macros-practical.md:725
msgid ""
"```rust\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; 2],\n"
"//                    ^~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; 2],\n"
"//                          ^~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"//                            ^~~~ changed\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"//                                                          ^~~~ changed\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(2);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"//                          ^~~~ changed\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"//                                           ^~~~ changed\n"
"                    /* ... */\n"
"#                     if self.pos < 2 {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let n = self.pos;\n"
"#                             let a = IndexOffset { slice: &self.mem, "
"offset: n };\n"
"#                             (a[n-2] + a[n-1])\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..2).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [0, 1], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:807
msgid ""
"Let's tackle a harder one: how to turn `inits` into both the array literal "
"`[0, 1]` _and_ the array type, `[$sty; 2]`. The first one we can do like so:"
msgstr ""

#: src/decl-macros/macros-practical.md:810
msgid ""
"```rust,ignore\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"//                             ^~~~~~~~~~~ changed\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:815
msgid ""
"This effectively does the opposite of the capture: repeat `inits` one or "
"more times, separating each with a comma. This expands to the expected "
"sequence of tokens: `0, 1`."
msgstr ""

#: src/decl-macros/macros-practical.md:818
msgid ""
"Somehow turning `inits` into a literal `2` is a little trickier. It turns "
"out that there's no direct way to do this, but we _can_ do it by using a "
"second `macro_rules!` macro. Let's take this one step at a time."
msgstr ""

#: src/decl-macros/macros-practical.md:830
msgid ""
"The obvious case is: given zero expressions, you would expect `count_exprs` "
"to expand to a literal `0`."
msgstr ""

#: src/decl-macros/macros-practical.md:833
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"//  ^~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     assert_eq!(_0, 0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:844
msgid ""
"**Aside**: You may have noticed I used parentheses here instead of curly "
"braces for the expansion. `macro_rules` really doesn't care _what_ you use, "
"so long as it's one of the \"matcher\" pairs: `( )`, `{ }` or `[ ]`. In "
"fact, you can switch out the matchers on the macro itself(_i.e._ the "
"matchers right after the macro name), the matchers around the syntax rule, "
"and the matchers around the corresponding expansion."
msgstr ""

#: src/decl-macros/macros-practical.md:848
msgid ""
"You can also switch out the matchers used when you _invoke_ a macro, but in "
"a more limited fashion: a macro invoked as `{ ... }` or `( ... );` will "
"_always_ be parsed as an _item_ (_i.e._ like a `struct` or `fn` "
"declaration). This is important when using macros in a function body; it "
"helps disambiguate between \"parse like an expression\" and \"parse like a "
"statement\"."
msgstr ""

#: src/decl-macros/macros-practical.md:851
msgid "What if you have _one_ expression? That should be a literal `1`."
msgstr ""

#: src/decl-macros/macros-practical.md:854
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"//  ^~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:868
msgid "Two?"
msgstr ""

#: src/decl-macros/macros-practical.md:870
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (2);\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:887
msgid ""
"We can \"simplify\" this a little by re-expressing the case of two "
"expressions recursively."
msgstr ""

#: src/decl-macros/macros-practical.md:889
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"//                           ^~~~~~~~~~~~~~~~~~~~~ changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:906
msgid ""
"This is fine since Rust can fold `1 + 1` into a constant value. What if we "
"have three expressions?"
msgstr ""

#: src/decl-macros/macros-practical.md:909
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($e:expr) => (1);\n"
"    ($e0:expr, $e1:expr) => (1 + count_exprs!($e1));\n"
"    ($e0:expr, $e1:expr, $e2:expr) => (1 + count_exprs!($e1, $e2));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:929
msgid ""
"**Aside**: You might be wondering if we could reverse the order of these "
"rules. In this particular case, _yes_, but the macro system can sometimes be "
"picky about what it is and is not willing to recover from. If you ever find "
"yourself with a multi-rule macro that you _swear_ should work, but gives you "
"errors about unexpected tokens, try changing the order of the rules."
msgstr ""

#: src/decl-macros/macros-practical.md:933
msgid ""
"Hopefully, you can see the pattern here. We can always reduce the list of "
"expressions by matching one expression, followed by zero or more "
"expressions, expanding that into 1 + a count."
msgstr ""

#: src/decl-macros/macros-practical.md:936
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ "
"changed\n"
"}\n"
"# fn main() {\n"
"#     const _0: usize = count_exprs!();\n"
"#     const _1: usize = count_exprs!(x);\n"
"#     const _2: usize = count_exprs!(x, y);\n"
"#     const _3: usize = count_exprs!(x, y, z);\n"
"#     assert_eq!(_0, 0);\n"
"#     assert_eq!(_1, 1);\n"
"#     assert_eq!(_2, 2);\n"
"#     assert_eq!(_3, 3);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid "**"
msgstr ""

#: src/decl-macros/macros-practical.md:955
#: src/decl-macros/patterns/repetition-replacement.md:34
#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid "JFTE"
msgstr ""

#: src/decl-macros/macros-practical.md:955
msgid ""
"**: this is not the _only_, or even the _best_ way of counting things. You "
"may wish to peruse the [Counting](./building-blocks/counting.md) section "
"later for a more efficient way."
msgstr ""

#: src/decl-macros/macros-practical.md:958
msgid ""
"With this, we can now modify `recurrence` to determine the necessary size of "
"`mem`."
msgstr ""

#: src/decl-macros/macros-practical.md:960
msgid ""
"```rust\n"
"// added:\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"//                          ^~~~~~~~ changed\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"//                                ^~~~~~~~ changed\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"//                                        ^~~~~~~~ changed\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"//                                ^~~~~~~~ changed\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            (a[n-2] + a[n-1])\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"//                                       ^~~~~~~~ changed\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"/* ... */\n"
"#\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"#\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:1051
msgid ""
"With that done, we can now substitute the last thing: the `recur` expression."
msgstr ""

#: src/decl-macros/macros-practical.md:1053
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr $(, $tail:expr)*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"# macro_rules! recurrence {\n"
"#     ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#             impl Iterator for Recurrence {\n"
"#               type Item = $sty;\n"
"/* ... */\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<u64> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let n = self.pos;\n"
"                            let a = IndexOffset { slice: &self.mem, offset: "
"n };\n"
"                            $recur\n"
"//                          ^~~~~~ changed\n"
"                        };\n"
"                        {\n"
"                            use std::mem::swap;\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"/* ... */\n"
"#             }\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"# fn main() {\n"
"#     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];\n"
"#     for e in fib.take(10) { println!(\"{}\", e) }\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:1126
msgid "And, when we compile our finished `macro_rules!` macro..."
msgstr ""

#: src/decl-macros/macros-practical.md:1154
msgid ""
"... wait, what? That can't be right... let's check what the macro is "
"expanding to."
msgstr ""

#: src/decl-macros/macros-practical.md:1161
msgid ""
"The `-Zunpretty=expanded` argument tells `rustc` to perform macro expansion, "
"then turn the resulting AST back into source code. The output (after "
"cleaning up some formatting) is shown below; in particular, note the place "
"in the code where `$recur` was substituted:"
msgstr ""

#: src/decl-macros/macros-practical.md:1165
msgid ""
"```rust,ignore\n"
"#![feature(no_std)]\n"
"#![no_std]\n"
"#[prelude_import]\n"
"use std::prelude::v1::*;\n"
"#[macro_use]\n"
"extern crate std as std;\n"
"fn main() {\n"
"    let fib = {\n"
"        use std::ops::Index;\n"
"        const MEM_SIZE: usize = 1 + 1;\n"
"        struct Recurrence {\n"
"            mem: [u64; MEM_SIZE],\n"
"            pos: usize,\n"
"        }\n"
"        struct IndexOffset<'a> {\n"
"            slice: &'a [u64; MEM_SIZE],\n"
"            offset: usize,\n"
"        }\n"
"        impl <'a> Index<usize> for IndexOffset<'a> {\n"
"            type Output = u64;\n"
"            #[inline(always)]\n"
"            fn index<'b>(&'b self, index: usize) -> &'b u64 {\n"
"                use std::num::Wrapping;\n"
"                let index = Wrapping(index);\n"
"                let offset = Wrapping(self.offset);\n"
"                let window = Wrapping(MEM_SIZE);\n"
"                let real_index = index - offset + window;\n"
"                &self.slice[real_index.0]\n"
"            }\n"
"        }\n"
"        impl Iterator for Recurrence {\n"
"            type Item = u64;\n"
"            #[inline]\n"
"            fn next(&mut self) -> Option<u64> {\n"
"                if self.pos < MEM_SIZE {\n"
"                    let next_val = self.mem[self.pos];\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                } else {\n"
"                    let next_val = {\n"
"                        let n = self.pos;\n"
"                        let a = IndexOffset{slice: &self.mem, offset: n,};\n"
"                        a[n - 1] + a[n - 2]\n"
"                    };\n"
"                    {\n"
"                        use std::mem::swap;\n"
"                        let mut swap_tmp = next_val;\n"
"                        {\n"
"                            let result =\n"
"                                match "
"::std::iter::IntoIterator::into_iter((0..MEM_SIZE).rev()) {\n"
"                                    mut iter => loop {\n"
"                                        match "
"::std::iter::Iterator::next(&mut iter) {\n"
"                                            ::std::option::Option::Some(i) "
"=> {\n"
"                                                swap(&mut swap_tmp, &mut "
"self.mem[i]);\n"
"                                            }\n"
"                                            ::std::option::Option::None => "
"break,\n"
"                                        }\n"
"                                    },\n"
"                                };\n"
"                            result\n"
"                        }\n"
"                    }\n"
"                    self.pos += 1;\n"
"                    Some(next_val)\n"
"                }\n"
"            }\n"
"        }\n"
"        Recurrence{mem: [0, 1], pos: 0,}\n"
"    };\n"
"    {\n"
"        let result =\n"
"            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {\n"
"                mut iter => loop {\n"
"                    match ::std::iter::Iterator::next(&mut iter) {\n"
"                        ::std::option::Option::Some(e) => {\n"
"                            "
"::std::io::_print(::std::fmt::Arguments::new_v1(\n"
"                                {\n"
"                                    static __STATIC_FMTSTR: &'static "
"[&'static str] = &[\"\", \"\\n"
"\"];\n"
"                                    __STATIC_FMTSTR\n"
"                                },\n"
"                                &match (&e,) {\n"
"                                    (__arg0,) => "
"[::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],\n"
"                                }\n"
"                            ))\n"
"                        }\n"
"                        ::std::option::Option::None => break,\n"
"                    }\n"
"                },\n"
"            };\n"
"        result\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:1260
msgid ""
"But that looks fine! If we add a few missing `#![feature(...)]` attributes "
"and feed it to a nightly build of `rustc`, it even compiles!  ... _what?!_"
msgstr ""

#: src/decl-macros/macros-practical.md:1263
msgid ""
"**Aside**: You can't compile the above with a non-nightly build of `rustc`. "
"This is because the expansion of the `println!` macro depends on internal "
"compiler details which are _not_ publicly stabilized."
msgstr ""

#: src/decl-macros/macros-practical.md:1266
msgid "Being Hygienic"
msgstr ""

#: src/decl-macros/macros-practical.md:1268
msgid ""
"The issue here is that identifiers in Rust syntax extensions are _hygienic_. "
"That is, identifiers from two different contexts _cannot_ collide. To show "
"the difference, let's take a simpler example."
msgstr ""

#: src/decl-macros/macros-practical.md:1286
msgid ""
"This macro simply takes an expression, then wraps it in a block with a "
"variable `a` defined. We then use this as a round-about way of computing "
"`4`. There are actually _two_ syntax contexts involved in this example, but "
"they're invisible. So, to help with this, let's give each context a "
"different colour. Let's start with the unexpanded code, where there is only "
"a single context:"
msgstr ""

#: src/decl-macros/macros-practical.md:1294
msgid "Now, let's expand the invocation."
msgstr ""

#: src/decl-macros/macros-practical.md:1298
msgid ""
"As you can see, the `a` that's defined by the macro invocation is in a "
"different context to the `a` we provided in our invocation. As such, the "
"compiler treats them as completely different identifiers, _even though they "
"have the same lexical appearance_."
msgstr ""

#: src/decl-macros/macros-practical.md:1301
msgid ""
"This is something to be _really_ careful of when working on `macro_rules!` "
"macros, syntax extensions in general even: they can produce ASTs which will "
"not compile, but which _will_ compile if written out by hand, or dumped "
"using `-Zunpretty=expanded`."
msgstr ""

#: src/decl-macros/macros-practical.md:1304
msgid ""
"The solution to this is to capture the identifier _with the appropriate "
"syntax context_. To do that, we need to again adjust our macro syntax. To "
"continue with our simpler example:"
msgstr ""

#: src/decl-macros/macros-practical.md:1310
msgid "This now expands to:"
msgstr ""

#: src/decl-macros/macros-practical.md:1314
msgid ""
"Now, the contexts match, and the code will compile. We can make this "
"adjustment to our `recurrence!` macro by explicitly capturing `a` and `n`. "
"After making the necessary changes, we have:"
msgstr ""

#: src/decl-macros/macros-practical.md:1318
msgid ""
"```rust\n"
"macro_rules! count_exprs {\n"
"    () => (0);\n"
"    ($head:expr) => (1);\n"
"    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"}\n"
"\n"
"macro_rules! recurrence {\n"
"    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; "
"$recur:expr ) => {\n"
"//    ^~~~~~~~~~   ^~~~~~~~~~ changed\n"
"        {\n"
"            use std::ops::Index;\n"
"\n"
"            const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"\n"
"            struct Recurrence {\n"
"                mem: [$sty; MEM_SIZE],\n"
"                pos: usize,\n"
"            }\n"
"\n"
"            struct IndexOffset<'a> {\n"
"                slice: &'a [$sty; MEM_SIZE],\n"
"                offset: usize,\n"
"            }\n"
"\n"
"            impl<'a> Index<usize> for IndexOffset<'a> {\n"
"                type Output = $sty;\n"
"\n"
"                #[inline(always)]\n"
"                fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"                    use std::num::Wrapping;\n"
"\n"
"                    let index = Wrapping(index);\n"
"                    let offset = Wrapping(self.offset);\n"
"                    let window = Wrapping(MEM_SIZE);\n"
"\n"
"                    let real_index = index - offset + window;\n"
"                    &self.slice[real_index.0]\n"
"                }\n"
"            }\n"
"\n"
"            impl Iterator for Recurrence {\n"
"                type Item = $sty;\n"
"\n"
"                #[inline]\n"
"                fn next(&mut self) -> Option<$sty> {\n"
"                    if self.pos < MEM_SIZE {\n"
"                        let next_val = self.mem[self.pos];\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    } else {\n"
"                        let next_val = {\n"
"                            let $ind = self.pos;\n"
"//                              ^~~~ changed\n"
"                            let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"//                              ^~~~ changed\n"
"                            $recur\n"
"                        };\n"
"\n"
"                        {\n"
"                            use std::mem::swap;\n"
"\n"
"                            let mut swap_tmp = next_val;\n"
"                            for i in (0..MEM_SIZE).rev() {\n"
"                                swap(&mut swap_tmp, &mut self.mem[i]);\n"
"                            }\n"
"                        }\n"
"\n"
"                        self.pos += 1;\n"
"                        Some(next_val)\n"
"                    }\n"
"                }\n"
"            }\n"
"\n"
"            Recurrence { mem: [$($inits),+], pos: 0 }\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];\n"
"\n"
"    for e in fib.take(10) { println!(\"{}\", e) }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:1404
msgid "And it compiles! Now, let's try with a different sequence."
msgstr ""

#: src/decl-macros/macros-practical.md:1407
msgid ""
"```rust\n"
"# macro_rules! count_exprs {\n"
"#     () => (0);\n"
"#     ($head:expr) => (1);\n"
"#     ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));\n"
"# }\n"
"#\n"
"# macro_rules! recurrence {\n"
"#     ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; "
"$recur:expr ) => {\n"
"#         {\n"
"#             use std::ops::Index;\n"
"#\n"
"#             const MEM_SIZE: usize = count_exprs!($($inits),+);\n"
"#\n"
"#             struct Recurrence {\n"
"#                 mem: [$sty; MEM_SIZE],\n"
"#                 pos: usize,\n"
"#             }\n"
"#\n"
"#             struct IndexOffset<'a> {\n"
"#                 slice: &'a [$sty; MEM_SIZE],\n"
"#                 offset: usize,\n"
"#             }\n"
"#\n"
"#             impl<'a> Index<usize> for IndexOffset<'a> {\n"
"#                 type Output = $sty;\n"
"#\n"
"#                 #[inline(always)]\n"
"#                 fn index<'b>(&'b self, index: usize) -> &'b $sty {\n"
"#                     use std::num::Wrapping;\n"
"#\n"
"#                     let index = Wrapping(index);\n"
"#                     let offset = Wrapping(self.offset);\n"
"#                     let window = Wrapping(MEM_SIZE);\n"
"#\n"
"#                     let real_index = index - offset + window;\n"
"#                     &self.slice[real_index.0]\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             impl Iterator for Recurrence {\n"
"#                 type Item = $sty;\n"
"#\n"
"#                 #[inline]\n"
"#                 fn next(&mut self) -> Option<$sty> {\n"
"#                     if self.pos < MEM_SIZE {\n"
"#                         let next_val = self.mem[self.pos];\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     } else {\n"
"#                         let next_val = {\n"
"#                             let $ind = self.pos;\n"
"#                             let $seq = IndexOffset { slice: &self.mem, "
"offset: $ind };\n"
"#                             $recur\n"
"#                         };\n"
"#\n"
"#                         {\n"
"#                             use std::mem::swap;\n"
"#\n"
"#                             let mut swap_tmp = next_val;\n"
"#                             for i in (0..MEM_SIZE).rev() {\n"
"#                                 swap(&mut swap_tmp, &mut self.mem[i]);\n"
"#                             }\n"
"#                         }\n"
"#\n"
"#                         self.pos += 1;\n"
"#                         Some(next_val)\n"
"#                     }\n"
"#                 }\n"
"#             }\n"
"#\n"
"#             Recurrence { mem: [$($inits),+], pos: 0 }\n"
"#         }\n"
"#     };\n"
"# }\n"
"#\n"
"# fn main() {\n"
"for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {\n"
"    println!(\"{}\", e)\n"
"}\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/macros-practical.md:1490
msgid "Which gives us:"
msgstr ""

#: src/decl-macros/macros-practical.md:1505
msgid "Success!"
msgstr ""

#: src/decl-macros/minutiae.md:3
msgid ""
"This section goes through some of the finer details of the `macro_rules!` "
"system. At a minimum, you should try to be at least _aware_ of these details "
"and issues."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:3
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md) "
"chapter, Rust, as of 1.60, has 14 fragment specifiers. This section will go "
"a bit more into detail for some of them and shows a few example inputs of "
"what each matcher matches."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:6
msgid ""
"**Note**: Capturing with anything but the `ident`, `lifetime` and `tt` "
"fragments will render the captured AST opaque, making it impossible to "
"further match it with other fragment specifiers in future macro invocations."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:8
msgid "[`block`](#block)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:9
msgid "[`expr`](#expr)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:10
msgid "[`ident`](#ident)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:11
msgid "[`item`](#item)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:12
msgid "[`lifetime`](#lifetime)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:13
msgid "[`literal`](#literal)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:14
msgid "[`meta`](#meta)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:15
msgid "[`pat`](#pat)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:16
msgid "[`pat_param`](#pat_param)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:17
msgid "[`path`](#path)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:18
msgid "[`stmt`](#stmt)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:19
msgid "[`tt`](#tt)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:20
msgid "[`ty`](#ty)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:21
msgid "[`vis`](#vis)"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:23
msgid "`block`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:25
msgid ""
"The `block` fragment solely matches a [block "
"expression](https://doc.rust-lang.org/reference/expressions/block-expr.html), "
"which consists of an opening `{` brace, followed by any number of statements "
"and finally followed by a closing `}` brace."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:42
msgid "`expr`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:44
msgid ""
"The `expr` fragment matches any kind of "
"[expression](https://doc.rust-lang.org/reference/expressions.html) (Rust has "
"a lot of them, given it _is_ an expression orientated language)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:46
msgid ""
"```rust\n"
"macro_rules! expressions {\n"
"    ($($expr:expr)*) => ();\n"
"}\n"
"\n"
"expressions! {\n"
"    \"literal\"\n"
"    funcall()\n"
"    future.await\n"
"    break 'foo bar\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:60
msgid "`ident`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:62
msgid ""
"The `ident` fragment matches an "
"[identifier](https://doc.rust-lang.org/reference/identifiers.html) or "
"_keyword_."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:64
msgid ""
"```rust\n"
"macro_rules! idents {\n"
"    ($($ident:ident)*) => ();\n"
"}\n"
"\n"
"idents! {\n"
"    // _ <- This is not an ident, it is a pattern\n"
"    foo\n"
"    async\n"
"    O_________O\n"
"    _____O_____\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:79
msgid "`item`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:81
msgid ""
"The `item` fragment simply matches any of Rust's "
"[item](https://doc.rust-lang.org/reference/items.html) _definitions_, not "
"identifiers that refer to items. This includes visibility modifiers."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:101
msgid "`lifetime`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:103
msgid ""
"The `lifetime` fragment matches a [lifetime or "
"label](https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels). "
"It's quite similar to [`ident`](#ident) but with a prepended `'`."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:119
msgid "`literal`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:121
msgid ""
"The `literal` fragment matches any [literal "
"expression](https://doc.rust-lang.org/reference/expressions/literal-expr.html)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:123
msgid ""
"```rust\n"
"macro_rules! literals {\n"
"    ($($literal:literal)*) => ();\n"
"}\n"
"\n"
"literals! {\n"
"    -1\n"
"    \"hello world\"\n"
"    2.3\n"
"    b'b'\n"
"    true\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:138
msgid "`meta`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:140
msgid ""
"The `meta` fragment matches the contents of an "
"[attribute](https://doc.rust-lang.org/reference/attributes.html). That is, "
"it will match a simple path, one without generic arguments followed by a "
"delimited token tree or an `=` followed by a literal expression."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:143
msgid ""
"**Note**: You will usually see this fragment being used in a matcher like "
"`#[$meta:meta]` or `#![$meta:meta]` to actually capture an attribute."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:145
msgid ""
"```rust\n"
"macro_rules! metas {\n"
"    ($($meta:meta)*) => ();\n"
"}\n"
"\n"
"metas! {\n"
"    ASimplePath\n"
"    super::man\n"
"    path = \"home\"\n"
"    foo(bar)\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:159
msgid ""
"**Doc-Comment Fact**: Doc-Comments like `/// ...` and `//! ...` are actually "
"syntax sugar for attributes! They desugar to `#[doc=\"...\"]` and "
"`#![doc=\"...\"]` respectively, meaning you can match on them like with "
"attributes!"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:161
msgid "`pat`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:163
msgid ""
"The `pat` fragment matches any kind of "
"[pattern](https://doc.rust-lang.org/reference/patterns.html), including "
"or-patterns starting with the 2021 edition."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:165
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($($pat:pat)*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:180
msgid "`pat_param`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:182
msgid ""
"In the 2021 edition, the behavior for the `pat` fragment type has been "
"changed to allow or-patterns to be parsed. This changes the follow list of "
"the fragment, preventing such fragment from being followed by a `|` token. "
"To avoid this problem or to get the old fragment behavior back one can use "
"the `pat_param` fragment which allows `|` to follow it, as it disallows top "
"level or-patterns."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:186
msgid ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($( $( $pat:pat_param )|+ )*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:201
msgid "`path`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:203
msgid ""
"The `path` fragment matches a so called "
"[TypePath](https://doc.rust-lang.org/reference/paths.html#paths-in-types) "
"style path. This includes the function style trait forms, `Fn() -> ()`."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:220
msgid "`stmt`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:222
msgid ""
"The `statement` fragment solely matches a "
"[statement](https://doc.rust-lang.org/reference/statements.html) without its "
"trailing semicolon, unless it is an item statement that requires one (such "
"as a Unit-Struct)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:224
msgid ""
"Let's use a simple example to show exactly what is meant with this. We use a "
"macro that merely emits what it captures:"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:247
msgid ""
"Expanding this, via the [playground](https://play.rust-lang.org/) for "
"example[^debugging], gives us roughly the following:"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:266
msgid "From this we can tell a few things."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:268
msgid ""
"The first you should be able to see immediately is that while the `stmt` "
"fragment doesn't capture trailing semicolons, it still emits them when "
"required, even if the statement is already followed by one. The simple "
"reason for that is that semicolons on their own are already valid statements "
"which the fragment captures eagerly. So our macro isn't capturing 8 times, "
"but 10! This can be important when doing multiples repetitions and expanding "
"these in one repetition expansion, as the repetition numbers have to match "
"in those cases."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:273
msgid ""
"Another thing you should be able to notice here is that the trailing "
"semicolon of the `struct Foo;` item statement is being matched, otherwise we "
"would've seen an extra one like in the other cases. This makes sense as we "
"already said, that for item statements that require one, the trailing "
"semicolon will be matched with."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:276
msgid ""
"A last observation is that expressions get emitted back with a trailing "
"semicolon, unless the expression solely consists of only a block expression "
"or control flow expression."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:278
msgid ""
"The fine details of what was just mentioned here can be looked up in the "
"[reference](https://doc.rust-lang.org/reference/statements.html)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:280
msgid ""
"Fortunately, these fine details here are usually not of importance "
"whatsoever, with the small exception that was mentioned earlier in regards "
"to repetitions which by itself shouldn't be a common problem to run into."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:282
msgid "See the [debugging chapter](./debugging.md) for tips on how to do this."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:284
msgid "`tt`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:286
msgid ""
"The `tt` fragment matches a TokenTree. If you need a refresher on what "
"exactly a TokenTree was you may want to revisit the [TokenTree "
"chapter](../../syntax-extensions/source-analysis.md#token-trees) of this "
"book. The `tt` fragment is one of the most powerful fragments, as it can "
"match nearly anything while still allowing you to inspect the contents of it "
"at a later state in the macro."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:290
msgid ""
"This allows one to make use of very powerful patterns like the "
"[tt-muncher](../patterns/tt-muncher.md) or the "
"[push-down-accumulator](../patterns/push-down-acc.md)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:292
msgid "`ty`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:294
msgid ""
"The `ty` fragment matches any kind of [type "
"expression](https://doc.rust-lang.org/reference/types.html#type-expressions)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:310
msgid "`vis`"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:312
msgid ""
"The `vis` fragment matches a _possibly empty_ [Visibility "
"qualifier](https://doc.rust-lang.org/reference/visibility-and-privacy.html)."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:314
msgid ""
"```rust\n"
"macro_rules! visibilities {\n"
"    //         ∨~~Note this comma, since we cannot repeat a `vis` fragment "
"on its own\n"
"    ($($vis:vis,)*) => ();\n"
"}\n"
"\n"
"visibilities! {\n"
"    , // no vis is fine, due to the implicit `?`\n"
"    pub,\n"
"    pub(crate),\n"
"    pub(in super),\n"
"    pub(in some_path),\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:329
msgid ""
"While able to match empty sequences of tokens, the fragment specifier still "
"acts quite different from [optional "
"repetitions](../macros-methodical.md#repetitions) which is described in the "
"following:"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:331
msgid ""
"If it is being matched against no left over tokens the entire macro matching "
"fails."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:332
msgid ""
"```rust\n"
"macro_rules! non_optional_vis {\n"
"    ($vis:vis) => ();\n"
"}\n"
"non_optional_vis!();\n"
"// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:340
msgid ""
"`$vis:vis $ident:ident` matches fine, unlike `$(pub)? $ident:ident` which is "
"ambiguous, as `pub` denotes a valid identifier."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:341
msgid ""
"```rust\n"
"macro_rules! vis_ident {\n"
"    ($vis:vis $ident:ident) => ();\n"
"}\n"
"vis_ident!(pub foo); // this works fine\n"
"\n"
"macro_rules! pub_ident {\n"
"    ($(pub)? $ident:ident) => ();\n"
"}\n"
"pub_ident!(pub foo);\n"
"        // ^^^ error: local ambiguity when calling macro `pub_ident`: "
"multiple parsing options: built-in NTs ident ('ident') or 1 other option.\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:354
msgid ""
"Being a fragment that matches the empty token sequence also gives it a very "
"interesting quirk in combination with `tt` fragments and recursive "
"expansions."
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:356
msgid ""
"When matching the empty token sequence, the metavariable will still count as "
"a capture and since it is not a `tt`, `ident` or `lifetime` fragment it will "
"become opaque to further expansions. This means if this capture is passed "
"onto another macro invocation that captures it as a `tt` you effectively end "
"up with token tree that contains nothing!"
msgstr ""

#: src/decl-macros/minutiae/fragment-specifiers.md:359
msgid ""
"```rust\n"
"macro_rules! it_is_opaque {\n"
"    (()) => { \"()\" };\n"
"    (($tt:tt)) => { concat!(\"$tt is \", stringify!($tt)) };\n"
"    ($vis:vis ,) => { it_is_opaque!( ($vis) ); }\n"
"}\n"
"fn main() {\n"
"    // this prints \"$tt is \", as the recursive calls hits the second "
"branch with\n"
"    // an empty tt, opposed to matching with the first branch!\n"
"    println!(\"{}\", it_is_opaque!(,));\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:3
msgid ""
"Once the parser begins consuming tokens for a metavariable, _it cannot stop "
"or backtrack_. This means that the second rule of the following macro "
"_cannot ever match_, no matter what input is provided:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:13
msgid ""
"Consider what happens if this macro is invoked as `dead_rule!(x+)`. The "
"interpreter will start at the first rule, and attempt to parse the input as "
"an expression. The first token `x` is valid as an expression. The second "
"token is _also_ valid in an expression, forming a binary addition node."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:18
msgid ""
"At this point, given that there is no right-hand side of the addition, you "
"might expect the parser to give up and try the next rule. Instead, the "
"parser will panic and abort the entire compilation, citing a syntax error."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:21
msgid ""
"As such, it is important in general that you write macro rules from "
"most-specific to least-specific."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:23
msgid ""
"To defend against future syntax changes altering the interpretation of macro "
"input, `macro_rules!` restricts what can follow various metavariables. The "
"complete list, showing what may follow what fragment specifier, as of Rust "
"1.46 is as follows:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:27
msgid ""
"[`stmt`](./fragment-specifiers.md#stmt) and "
"[`expr`](./fragment-specifiers.md#expr): `=>`, `,`, or `;`"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:28
msgid ""
"[`pat`](./fragment-specifiers.md#pat): `=>`, `,`, `=`, `if`, "
"`in`[^pat-edition]"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:29
msgid ""
"[`pat_param`](./fragment-specifiers.md#pat_param): `=>`, `,`, `=`, `|`, "
"`if`, `in`"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:30
msgid ""
"[`path`](./fragment-specifiers.md#path) and "
"[`ty`](./fragment-specifiers.md#ty):`=>`, `,`, `=`, `|`, `;`, `:`, `>`, "
"`>>`, `[`, `{`, `as`, `where`, or a macro variable of the "
"[`block`](./fragment-specifiers.md#block) fragment specifier."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:32
msgid ""
"[`vis`](./fragment-specifiers.md#vis): `,`, an identifier other than a "
"non-raw `priv`, any token that can begin a type or a metavariable with an "
"[`ident`](./fragment-specifiers.md#ident), "
"[`ty`](./fragment-specifiers.md#ty), or "
"[`path`](./fragment-specifiers.md#path) fragment specifier."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:34
msgid "All other fragment specifiers have no restrictions."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:36
msgid ""
"**Edition Differences**: Before the 2021 edition, `pat` may also be followed "
"by `|`."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:38
msgid ""
"Repetitions also adhere to these restrictions, meaning if a repetition can "
"repeat multiple times(`*` or `+`), then the contents must be able to follow "
"themselves. If a repetition can repeat zero times (`?` or `*`) then what "
"comes after the repetition must be able to follow what comes before."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:41
msgid ""
"The parser also does not perform any kind of lookahead. That means if the "
"compiler cannot unambiguously determine how to parse the macro invocation "
"one token at a time, it will abort with an ambiguity error. A simple example "
"that triggers this:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:45
msgid ""
"```rust\n"
"macro_rules! ambiguity {\n"
"    ($($i:ident)* $i2:ident) => { };\n"
"}\n"
"\n"
"// error:\n"
"//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or "
"ident ('i2').\n"
"ambiguity!(an_identifier);\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:55
msgid ""
"The parser does not look ahead past the identifier to see if the following "
"token is a `)`, which would allow it to parse properly."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:57
msgid ""
"One aspect of substitution that often surprises people is that substitution "
"is _not_ token-based, despite very much _looking_ like it."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:59
msgid "Consider the following:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:61
msgid ""
"```rust\n"
"macro_rules! capture_then_match_tokens {\n"
"    ($e:expr) => {match_tokens!($e)};\n"
"}\n"
"\n"
"macro_rules! match_tokens {\n"
"    ($a:tt + $b:tt) => {\"got an addition\"};\n"
"    (($i:ident)) => {\"got an identifier\"};\n"
"    ($($other:tt)*) => {\"got something else\"};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\\n"
"{}\\n"
"{}\\n"
"\",\n"
"        match_tokens!((caravan)),\n"
"        match_tokens!(3 + 6),\n"
"        match_tokens!(5));\n"
"    println!(\"{}\\n"
"{}\\n"
"{}\",\n"
"        capture_then_match_tokens!((caravan)),\n"
"        capture_then_match_tokens!(3 + 6),\n"
"        capture_then_match_tokens!(5));\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:84
#: src/decl-macros/minutiae/metavar-and-expansion.md:123
#: src/decl-macros/minutiae/debugging.md:26
msgid "The output is:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:96
msgid ""
"By parsing the input into an AST node, the substituted result becomes "
"_un-destructible_; _i.e._ you cannot examine the contents or match against "
"it ever again."
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:99
msgid "Here is _another_ example which can be particularly confusing:"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:101
msgid ""
"```rust\n"
"macro_rules! capture_then_what_is {\n"
"    (#[$m:meta]) => {what_is!(#[$m])};\n"
"}\n"
"\n"
"macro_rules! what_is {\n"
"    (#[no_mangle]) => {\"no_mangle attribute\"};\n"
"    (#[inline]) => {\"inline attribute\"};\n"
"    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), "
"\")\")};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\n"
"        \"{}\\n"
"{}\\n"
"{}\\n"
"{}\",\n"
"        what_is!(#[no_mangle]),\n"
"        what_is!(#[inline]),\n"
"        capture_then_what_is!(#[no_mangle]),\n"
"        capture_then_what_is!(#[inline]),\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-and-expansion.md:132
msgid ""
"The only way to avoid this is to capture using the "
"[`tt`](./fragment-specifiers.md#tt), "
"[`ident`](./fragment-specifiers.md#ident) or "
"[`lifetime`](./fragment-specifiers.md#lifetime) kinds. Once you capture with "
"anything else, the only thing you can do with the result from then on is "
"substitute it directly into the output."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:7
msgid ""
"Note: The example code snippets are very bare bones, trying to show off how "
"they work. If you think you got small snippets with proper isolated usage of "
"these expression please submit them!"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:9
msgid ""
"As mentioned in the [`methodical introduction`](../macros-methodical.md), "
"Rust has special expressions that can be used by macro transcribers to "
"obtain information about metavariables that are otherwise difficult or even "
"impossible to get. This chapter will introduce them more in-depth together "
"with usage examples."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:12
msgid "[`$$`](#dollar-dollar-)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:13
msgid "[`${count(ident, depth)}`](#countident-depth)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:14
msgid "[`${index(depth)}`](#indexdepth)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:15
msgid "[`${length(depth)}`](#lengthdepth)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:16
msgid "[`${ignore(ident)}`](#ignoreident)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:18
msgid "Dollar Dollar (`$$`)"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:20
msgid ""
"The `$$` expression expands to a single `$`, making it effectively an "
"escaped `$`. This enables the ability in writing macros emitting new macros "
"as the former macro won't transcribe metavariables, repetitions and "
"metavariable expressions that have an escaped `$`."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:23
msgid "We can see the problem without using `$$` in the following snippet:"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:24
msgid ""
"```rust\n"
"macro_rules! foo {\n"
"    () => {\n"
"        macro_rules! bar {\n"
"            ( $( $any:tt )* ) => { $( $any )* };\n"
"            // ^^^^^^^^^^^ error: attempted to repeat an expression "
"containing no syntax variables matched as repeating at this depth\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"foo!();\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:38
msgid ""
"The problem is obvious, the transcriber of foo sees a repetition and tries "
"to repeat it when transcribing, but there is no `$any` metavariable in its "
"scope causing it to fail. With `$$` we can get around this as the "
"transcriber of `foo` will no longer try to do the repetition.[^tt-$]"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:57
msgid ""
"Before `$$` occurs, users must resort to a tricky and not so well-known hack "
"to declare nested macros with repetitions [via using `$tt` like "
"this](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=9ce18fc79ce17c77d20e74f3c46ee13c)."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:60
msgid "`count(ident, depth)`"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:62
msgid ""
"The `count` metavariable expression expands to the repetition count of the "
"metavariable `$ident` up to the given repetition depth."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:64
#: src/decl-macros/minutiae/metavar-expr.md:167
msgid ""
"The `ident` argument must be a declared metavariable in the scope of the "
"rule."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:65
msgid ""
"The `depth` argument must be an integer literal of value less or equal to "
"the maximum repetition depth that the `$ident` metavariable appears in."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:66
#: src/decl-macros/minutiae/metavar-expr.md:96
#: src/decl-macros/minutiae/metavar-expr.md:132
msgid "The expression expands to an unsuffixed integer literal token."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:68
msgid ""
"The `count(ident)` expression defaults `depth` to the maximum valid depth, "
"making it count the total repetitions for the given metavariable."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:70
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! foo {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        println!(\"count(outer, 0): $outer repeats {} times\", "
"${count(outer)});\n"
"        println!(\"count(inner, 0): The $inner repetition repeats {} times "
"in the outer repetition\", ${count(inner, 0)});\n"
"        println!(\"count(inner, 1): $inner repeats {} times in the inner "
"repetitions\", ${count(inner, 1)});\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    foo! {\n"
"        outer () ;\n"
"        outer ( inner , inner ) ;\n"
"        outer () ;\n"
"        outer ( inner ) ;\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:91
msgid "`index(depth)`"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:93
msgid ""
"The `index(depth)` metavariable expression expands to the current iteration "
"index of the repetition at the given depth."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:95
#: src/decl-macros/minutiae/metavar-expr.md:131
msgid ""
"The `depth` argument targets the repetition at `depth` counting outwards "
"from the inner-most repetition where the expression is invoked."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:98
msgid ""
"The `index()` expression defaults `depth` to `0`, making it a shorthand for "
"`index(0)`."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:100
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! attach_iteration_counts {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ( $(\n"
"            $((\n"
"                stringify!($inner),\n"
"                ${index(1)}, // this targets the outer repetition\n"
"                ${index()}  // and this, being an alias for `index(0)` "
"targets the inner repetition\n"
"            ),)*\n"
"        )* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let v = attach_iteration_counts! {\n"
"        ( hello ) ;\n"
"        ( indices , of ) ;\n"
"        () ;\n"
"        ( these, repetitions ) ;\n"
"    };\n"
"    println!(\"{v:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:127
msgid "`length(depth)`"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:129
msgid ""
"The `length(depth)` metavariable expression expands to the iteration count "
"of the repetition at the given depth."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:134
msgid ""
"The `length()` expression defaults `depth` to `0`, making it a shorthand for "
"`length(0)`."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:137
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! lets_count {\n"
"    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {\n"
"        $(\n"
"            $(\n"
"                println!(\n"
"                    \"'{}' in inner iteration {}/{} with '{}' in outer "
"iteration {}/{} \",\n"
"                    stringify!($inner), ${index()}, ${length()},\n"
"                    stringify!($outer), ${index(1)}, ${length(1)},\n"
"                );\n"
"            )*\n"
"        )*\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    lets_count!(\n"
"        many (small , things) ;\n"
"        none () ;\n"
"        exactly ( one ) ;\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:163
msgid "`ignore(ident)`"
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:165
msgid ""
"The `ignore(ident)` metavariable expression expands to nothing, making it "
"possible to expand something as often as a metavariable repeats without "
"expanding the metavariable."
msgstr ""

#: src/decl-macros/minutiae/metavar-expr.md:169
msgid ""
"```rust\n"
"#![feature(macro_metavar_expr)]\n"
"\n"
"macro_rules! repetition_tuples {\n"
"    ( $( ( $( $inner:ident ),* ) ; )* ) => {\n"
"        ($(\n"
"            $(\n"
"                (\n"
"                    ${index()},\n"
"                    ${index(1)}\n"
"                    ${ignore(inner)} // without this metavariable "
"expression, compilation would fail\n"
"                ),\n"
"            )*\n"
"        )*)\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let tuple = repetition_tuples!(\n"
"        ( one, two ) ;\n"
"        () ;\n"
"        ( one ) ;\n"
"        ( one, two, three ) ;\n"
"    );\n"
"    println!(\"{tuple:?}\");\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:3
msgid ""
"`macro_rules!` macros in Rust are _partially_ hygienic, also called mixed "
"hygiene. Specifically, they are hygienic when it comes to _local variables_, "
"_labels_ and `$crate`, but nothing else."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:6
msgid ""
"Hygiene works by attaching an invisible \"syntax context\" value to all "
"identifiers. When two identifiers are compared, _both_ the identifiers' "
"textual names _and_ syntax contexts must be identical for the two to be "
"considered equal."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:9
msgid "To illustrate this, consider the following code:"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:13
msgid ""
"We will use the background colour to denote the syntax context. Now, let's "
"expand the macro invocation:"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:18
msgid ""
"First, recall that `macro_rules!` invocations effectively _disappear_ during "
"expansion."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:20
msgid ""
"Second, if you attempt to compile this code, the compiler will respond with "
"something along the following lines:"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:30
msgid ""
"Note that the background colour (_i.e._ syntax context) for the expanded "
"macro _changes_ as part of expansion. Each `macro_rules!` macro expansion is "
"given a new, unique syntax context for its contents. As a result, there are "
"_two different `a`s_ in the expanded code: one in the first syntax context, "
"the second in the other. In other words, `a` is not the same identifier as "
"`a`, however similar they may appear."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:35
msgid ""
"That said, tokens that were substituted _into_ the expanded output _retain_ "
"their original syntax context (by virtue of having been provided to the "
"macro as opposed to being part of the macro itself). Thus, the solution is "
"to modify the macro as follows:"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:40
msgid "Which, upon expansion becomes:"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:44
msgid ""
"The compiler will accept this code because there is only one `a` being used."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:46
msgid "`$crate`"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:48
msgid ""
"Hygiene is also the reason that we need the `$crate` metavariable when our "
"macro needs access to other items in the defining crate. What this special "
"metavariable does is that it expands to an absolute path to the defining "
"crate."
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:51
msgid ""
"```rust,ignore\n"
"//// Definitions in the `helper_macro` crate.\n"
"#[macro_export]\n"
"macro_rules! helped {\n"
"    // () => { helper!() } // This might lead to an error due to 'helper' "
"not being in scope.\n"
"    () => { $crate::helper!() }\n"
"}\n"
"\n"
"#[macro_export]\n"
"macro_rules! helper {\n"
"    () => { () }\n"
"}\n"
"\n"
"//// Usage in another crate.\n"
"// Note that `helper_macro::helper` is not imported!\n"
"use helper_macro::helped;\n"
"\n"
"fn unit() {\n"
"   // but it still works due to `$crate` properly expanding to the crate "
"path `helper_macro`\n"
"   helped!();\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/hygiene.md:74
msgid ""
"Note that, because `$crate` refers to the current crate, it must be used "
"with a fully qualified module path when referring to non-macro items:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:3
msgid ""
"There are two tokens which you are likely to run into eventually that _look_ "
"like identifiers, but aren't. Except when they are."
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:6
msgid ""
"First is `self`. This is _very definitely_ a keyword. However, it also "
"happens to fit the definition of an identifier. In regular Rust code, "
"there's no way for `self` to be interpreted as an identifier, but it _can_ "
"happen with `macro_rules!` macros:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:11
msgid ""
"```rust\n"
"macro_rules! what_is {\n"
"    (self) => {\"the keyword `self`\"};\n"
"    ($i:ident) => {concat!(\"the identifier `\", stringify!($i), \"`\")};\n"
"}\n"
"\n"
"macro_rules! call_with_ident {\n"
"    ($c:ident($i:ident)) => {$c!($i)};\n"
"}\n"
"\n"
"fn main() {\n"
"    println!(\"{}\", what_is!(self));\n"
"    println!(\"{}\", call_with_ident!(what_is(self)));\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:27
msgid "The above outputs:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:34
msgid ""
"But that makes no sense; `call_with_ident!` required an identifier, matched "
"one, and substituted it! So `self` is both a keyword and not a keyword at "
"the same time. You might wonder how this is in any way important. Take this "
"example:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:39
msgid ""
"```rust\n"
"macro_rules! make_mutable {\n"
"    ($i:ident) => {let mut $i = $i;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_mutable!(self);\n"
"        self.0 *= 2;\n"
"        self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:59
msgid "This fails to compile with:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:74
msgid ""
"So the macro will happily match `self` as an identifier, allowing you to use "
"it in cases where you can't actually use it. But, fine; it somehow remembers "
"that `self` is a keyword even when it's an identifier, so you _should_ be "
"able to do this, right?"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:77
msgid ""
"```rust\n"
"macro_rules! make_self_mutable {\n"
"    ($i:ident) => {let mut $i = self;};\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    fn double(self) -> Dummy {\n"
"        make_self_mutable!(mut_self);\n"
"        mut_self.0 *= 2;\n"
"        mut_self\n"
"    }\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:97
msgid "This fails with:"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:116
msgid ""
"Now the compiler thinks we refer to our module with `self`, but that doesn't "
"make sense. We already have a `self` right there, in the function signature "
"which is definitely not a module. It's almost like it's complaining that the "
"`self` it's trying to use isn't the _same_ `self`... as though the `self` "
"keyword has hygiene, like an... identifier."
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:120
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($body:expr) => {\n"
"        fn double(mut self) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {{\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:143
msgid "Same error.  What about..."
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:145
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double(mut $self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {self, {\n"
"        self.0 *= 2;\n"
"        self\n"
"    }}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:168
msgid ""
"At last, _this works_. So `self` is both a keyword _and_ an identifier when "
"it feels like it. Surely this works for other, similar constructs, right?"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:172
msgid ""
"```rust\n"
"macro_rules! double_method {\n"
"    ($self_:ident, $body:expr) => {\n"
"        fn double($self_) -> Dummy {\n"
"            $body\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"struct Dummy(i32);\n"
"\n"
"impl Dummy {\n"
"    double_method! {_, 0}\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     println!(\"{:?}\", Dummy(4).double().0);\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:203
msgid ""
"No, of course not. `_` is a keyword that is valid in patterns and "
"expressions, but somehow _isn't_ an identifier like the keyword `self` is, "
"despite matching the definition of an identifier just the same."
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:206
msgid ""
"You might think you can get around this by using `$self_:pat` instead; that "
"way, `_` will match! Except, no, because `self` isn't a pattern. Joy."
msgstr ""

#: src/decl-macros/minutiae/identifiers.md:209
msgid ""
"The only work around for this (in cases where you want to accept some "
"combination of these tokens) is to use a [`tt`](./fragment-specifiers.md#tt) "
"matcher instead."
msgstr ""

#: src/decl-macros/minutiae/debugging.md:3
msgid ""
"**Note**: This is a list of debugging tools specifically tailored towards "
"declarative macros, additional means of debugging these can be found in the "
"[debugging chapter](../../syntax-extensions/debugging.md) of syntax "
"extensions."
msgstr ""

#: src/decl-macros/minutiae/debugging.md:5
msgid ""
"One of the most useful is "
"[`trace_macros!`](https://doc.rust-lang.org/std/macro.trace_macros.html), "
"which is a directive to the compiler instructing it to dump every "
"`macro_rules!` macro invocation prior to expansion. For example, given the "
"following:"
msgstr ""

#: src/decl-macros/minutiae/debugging.md:8
msgid ""
"```rust,ignore\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(trace_macros)]\n"
"\n"
"macro_rules! each_tt {\n"
"    () => {};\n"
"    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};\n"
"}\n"
"\n"
"each_tt!(foo bar baz quux);\n"
"trace_macros!(true);\n"
"each_tt!(spim wak plee whum);\n"
"trace_macros!(false);\n"
"each_tt!(trom qlip winp xod);\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/debugging.md:47
msgid ""
"This is _particularly_ invaluable when debugging deeply recursive "
"`macro_rules!` macros. You can also enable this from the command-line by "
"adding `-Z trace-macros` to the compiler command line."
msgstr ""

#: src/decl-macros/minutiae/debugging.md:50
msgid ""
"Secondly, there is "
"[`log_syntax!`](https://doc.rust-lang.org/std/macro.log_syntax.html) which "
"causes the compiler to output all tokens passed to it. For example, this "
"makes the compiler sing a song:"
msgstr ""

#: src/decl-macros/minutiae/debugging.md:53
msgid ""
"```rust\n"
"# // Note: make sure to use a nightly channel compiler.\n"
"#![feature(log_syntax)]\n"
"\n"
"macro_rules! sing {\n"
"    () => {};\n"
"    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};\n"
"}\n"
"\n"
"sing! {\n"
"    ^ < @ < . @ *\n"
"    '\\x08' '{' '\"' _ # ' '\n"
"    - @ '$' && / _ %\n"
"    ! ( '\\t' @ | = >\n"
"    ; '\\x08' '\\'' + '$' ? '\\x7f'\n"
"    , # '\"' ~ | ) '\\x07'\n"
"}\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/debugging.md:74
msgid ""
"This can be used to do slightly more targeted debugging than "
"[`trace_macros!`](https://doc.rust-lang.org/std/macro.trace_macros.html)."
msgstr ""

#: src/decl-macros/minutiae/debugging.md:76
msgid ""
"Another amazing tool is [`lukaslueg`'s](https://github.com/lukaslueg) "
"[`macro_railroad`](https://github.com/lukaslueg/macro_railroad), a tool that "
"allows you visualize and generate syntax diagrams for Rust's `macro_rules!` "
"macros. It visualizes the accepted macro's grammar as an automata."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:3
msgid ""
"The way in which mbe macros are scoped can be somewhat unintuitive. They use "
"two forms of scopes: textual scope, and path-based scope."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:6
msgid ""
"When such a macro is invoked by an unqualified identifier(an identifier that "
"isn't part of a multi-segment path), it is first looked up in textual "
"scoping and then in path-based scoping should the first lookup not yield any "
"results. If it is invoked by a qualified identifier it will skip the textual "
"scoping lookup and instead only do a look up in the path-based scoping."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:9
msgid "Textual Scope"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:11
msgid ""
"Firstly, unlike everything else in the language, function-like macros will "
"remain visible in sub-modules."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:13
msgid ""
"```rust\n"
"macro_rules! X { () => {}; }\n"
"mod a {\n"
"    X!(); // defined\n"
"}\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:27
msgid ""
"**Note**: In these examples, remember that all of them have the _same "
"behavior_ when the module contents are in separate files."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:29
msgid ""
"Secondly, _also_ unlike everything else in the language, `macro_rules!` "
"macros are only accessible _after_ their definition. Also note that this "
"example demonstrates how `macro_rules!` macros do not \"leak\" out of their "
"defining scope:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:32
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"mod b {\n"
"    // X!(); // undefined\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    // X!(); // undefined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:47
msgid ""
"To be clear, this lexical order dependency applies even if you move the "
"macro to an outer scope:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:49
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => {}; }\n"
"mod b {\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:63
msgid "However, this dependency _does not_ apply to macros themselves:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:65
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"macro_rules! X { () => { Y!(); }; }\n"
"mod b {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:80
msgid ""
"Defining `macro_rules!` macros multiple times is allowed and the most recent "
"declaration will simply shadow previous ones unless it has gone out of scope."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:82
msgid ""
"```rust\n"
"macro_rules! X { (1) => {}; }\n"
"X!(1);\n"
"macro_rules! X { (2) => {}; }\n"
"// X!(1); // Error: no rule matches `1`\n"
"X!(2);\n"
"\n"
"mod a {\n"
"    macro_rules! X { (3) => {}; }\n"
"    // X!(2); // Error: no rule matches `2`\n"
"    X!(3);\n"
"}\n"
"// X!(3); // Error: no rule matches `3`\n"
"X!(2);\n"
"\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:99
msgid ""
"`macro_rules!` macros can be exported from a module using the `#[macro_use]` "
"attribute. Using this on a module is similar to saying that you do not want "
"to have the module's macro's scope end with the module."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:102
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // defined\n"
"}\n"
"mod c {\n"
"    X!(); // defined\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:117
msgid ""
"Note that this can interact in somewhat bizarre ways due to the fact that "
"identifiers in a `macro_rules!` macro (including other macros) are only "
"resolved upon expansion:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:119
msgid ""
"```rust\n"
"mod a {\n"
"    // X!(); // undefined\n"
"}\n"
"#[macro_use]\n"
"mod b {\n"
"    macro_rules! X { () => { Y!(); }; }\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:135
msgid ""
"Another complication is that `#[macro_use]` applied to an `extern crate` "
"_does not_ behave this way: such declarations are effectively _hoisted_ to "
"the top of the module. Thus, assuming `X!` is defined in an external crate "
"called `macs`, the following holds:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:137
msgid ""
"```rust,ignore\n"
"mod a {\n"
"    // X!(); // defined, but Y! is undefined\n"
"}\n"
"macro_rules! Y { () => {}; }\n"
"mod b {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"#[macro_use] extern crate macs;\n"
"mod c {\n"
"    X!(); // defined, and so is Y!\n"
"}\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:152
msgid ""
"Finally, note that these scoping behaviors apply to _functions_ as well, "
"with the exception of `#[macro_use]` (which isn't applicable):"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:154
msgid ""
"```rust\n"
"macro_rules! X {\n"
"    () => { Y!() };\n"
"}\n"
"\n"
"fn a() {\n"
"    macro_rules! Y { () => {\"Hi!\"} }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"    {\n"
"        assert_eq!(X!(), \"Hi!\");\n"
"        macro_rules! Y { () => {\"Bye!\"} }\n"
"        assert_eq!(X!(), \"Bye!\");\n"
"    }\n"
"    assert_eq!(X!(), \"Hi!\");\n"
"}\n"
"\n"
"fn b() {\n"
"    macro_rules! Y { () => {\"One more\"} }\n"
"    assert_eq!(X!(), \"One more\");\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     a();\n"
"#     b();\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:181
msgid ""
"These scoping rules are why a common piece of advice is to place all "
"`macro_rules!` macros which should be accessible \"crate wide\" at the very "
"top of your root module, before any other modules. This ensures they are "
"available _consistently_. This also applies to `mod` definitions for files, "
"as in:"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:191
msgid ""
"The order here is important, swap the declaration order and it won't compile."
msgstr ""

#: src/decl-macros/minutiae/scoping.md:193
msgid "Path-Based Scope"
msgstr ""

#: src/decl-macros/minutiae/scoping.md:195
msgid ""
"By default, a `macro_rules!` macro has no path-based scope. However, if it "
"has the `#[macro_export]` attribute, then it is declared in the crate root "
"scope and can be referred to similar to how you refer to any other item. The "
"[Import and Export](./import-export.html) chapter goes more in-depth into "
"said attribute."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:3
msgid ""
"Importing `macro_rules!` macros differs between the two Rust Editions, 2015 "
"and 2018. It is recommended to read both parts nevertheless, as the 2018 "
"Edition can still use the constructs that are explained in the 2015 Edition."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:6
msgid "Edition 2015"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:8
msgid ""
"In Edition 2015 you have to use the `#[macro_use]` attribute that has "
"already been introduced in the [scoping chapter](./scoping.md). This can be "
"applied to _either_ modules or external crates. For example:"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:24
msgid ""
"`macro_rules!` macros can be exported from the current crate using "
"`#[macro_export]`. Note that this _ignores_ all visibility."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:27
msgid "Given the following definition for a library package `macs`:"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:29
msgid ""
"```rust,ignore\n"
"mod macros {\n"
"    #[macro_export] macro_rules! X { () => { Y!(); } }\n"
"    #[macro_export] macro_rules! Y { () => {} }\n"
"}\n"
"\n"
"// X! and Y! are *not* defined here, but *are* exported,\n"
"// despite `macros` being private.\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:39
msgid "The following code will work as expected:"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:41
msgid ""
"```rust,ignore\n"
"X!(); // X is defined\n"
"#[macro_use] extern crate macs;\n"
"X!();\n"
"#\n"
"# fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:49
msgid ""
"This works, as said in the [scoping chapter](./scoping.md), because "
"`#[macro_use]` works slightly different on extern crates, as it basically "
"_hoists_ the exported macros out of the crate to the top of the module."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:51
msgid ""
"Note: you can _only_ `#[macro_use]` an external crate from the root module."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:53
msgid ""
"Finally, when importing `macro_rules!` macros from an external crate, you "
"can control _which_ macros you import. You can use this to limit namespace "
"pollution, or to override specific macros, like so:"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:56
msgid ""
"```rust,ignore\n"
"// Import *only* the `X!` macro.\n"
"#[macro_use(X)] extern crate macs;\n"
"\n"
"// X!(); // X is defined, but Y! is undefined\n"
"\n"
"macro_rules! Y { () => {} }\n"
"\n"
"X!(); // X is defined, and so is Y!\n"
"\n"
"fn main() {}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:69
msgid ""
"When exporting `macro_rules!` macros, it is often useful to refer to "
"non-macro symbols in the defining crate. Because crates can be renamed, "
"there is a special substitution variable available: "
"[`$crate`](./hygiene.md#crate). This will _always_ expand to an absolute "
"path prefix to the containing crate (_e.g._ `:: macs`)."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:73
msgid ""
"Note that unless your compiler version is >= 1.30, this does _not_ work for "
"`macro_rules!` macros, because `macro_rules!` macros do not interact with "
"regular name resolution in any way. Otherwise, you cannot use something like "
"`$crate::Y!` to refer to a particular macro within your crate. The "
"implication, combined with selective imports via `#[macro_use]` is that "
"there is currently _no way_ to guarantee any given macro will be available "
"when imported by another crate."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:77
msgid ""
"It is recommended that you _always_ use absolute paths to non-macro names, "
"to avoid conflicts, _including_ names in the standard library."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:81
msgid "Edition 2018"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:83
msgid ""
"The 2018 Edition made our lives a lot easier when it comes to `macro_rules!` "
"macros. Why you ask? Quite simply because it managed to make them feel more "
"like proper items than some special thing in the language. What this means "
"is that we can properly import and use them in a namespaced fashion!"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:88
msgid ""
"So instead of using `#[macro_use]` to import every exported macro from a "
"crate into the global namespace we can now do the following:"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:90
msgid ""
"```rs\n"
"use some_crate::some_macro;\n"
"\n"
"fn main() {\n"
"    some_macro!(\"hello\");\n"
"    // as well as\n"
"    some_crate::some_other_macro!(\"macro world\");\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/minutiae/import-export.md:100
msgid ""
"Unfortunately, this only applies for external crates, if you use "
"`macro_rules!` macros that you have defined in your own crate you are still "
"required to go with `#[macro_use]` on the defining modules. So scoping "
"applies there the same way as before as well."
msgstr ""

#: src/decl-macros/minutiae/import-export.md:103
msgid ""
"The `$crate` prefix works in this version for everything, macros and items "
"alike since this Edition came out with Rust 1.31."
msgstr ""

#: src/decl-macros/patterns.md:3
msgid "Parsing and expansion patterns."
msgstr ""

#: src/decl-macros/patterns/callbacks.md:3
msgid ""
"Due to the order that macros are expanded in, it is (as of Rust 1.2) "
"impossible to pass information to a macro from the expansion of _another_ "
"macro:"
msgstr ""

#: src/decl-macros/patterns/callbacks.md:5
msgid ""
"```rust\n"
"macro_rules! recognize_tree {\n"
"    (larch) => { println!(\"#1, the Larch.\") };\n"
"    (redwood) => { println!(\"#2, the Mighty Redwood.\") };\n"
"    (fir) => { println!(\"#3, the Fir.\") };\n"
"    (chestnut) => { println!(\"#4, the Horse Chestnut.\") };\n"
"    (pine) => { println!(\"#5, the Scots Pine.\") };\n"
"    ($($other:tt)*) => { println!(\"I don't know; some kind of birch "
"maybe?\") };\n"
"}\n"
"\n"
"macro_rules! expand_to_larch {\n"
"    () => { larch };\n"
"}\n"
"\n"
"fn main() {\n"
"    recognize_tree!(expand_to_larch!());\n"
"    // first expands to:  recognize_tree! { expand_to_larch ! (  ) }\n"
"    // and then:          println! { \"I don't know; some kind of birch "
"maybe?\" }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/patterns/callbacks.md:26
msgid "This can make modularizing macros very difficult."
msgstr ""

#: src/decl-macros/patterns/callbacks.md:28
msgid "An alternative is to use recursion and pass a callback:"
msgstr ""

#: src/decl-macros/patterns/callbacks.md:30
msgid ""
"```rust\n"
"// ...\n"
"\n"
"macro_rules! call_with_larch {\n"
"    ($callback:ident) => { $callback!(larch) };\n"
"}\n"
"\n"
"fn main() {\n"
"    call_with_larch!(recognize_tree);\n"
"    // first expands to:  call_with_larch! { recognize_tree }\n"
"    // then:              recognize_tree! { larch }\n"
"    // and finally:       println! { \"#1, the Larch.\" }\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/patterns/callbacks.md:45
msgid ""
"Using a `tt` repetition, one can also forward arbitrary arguments to a "
"callback."
msgstr ""

#: src/decl-macros/patterns/callbacks.md:47
msgid ""
"```rust\n"
"macro_rules! callback {\n"
"    ($callback:ident( $($args:tt)* )) => {\n"
"        $callback!( $($args)* )\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    callback!(callback(println(\"Yes, this *was* unnecessary.\")));\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/patterns/callbacks.md:59
msgid "You can, of course, insert additional tokens in the arguments as needed."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:3
msgid ""
"```rust\n"
"macro_rules! mixed_rules {\n"
"    () => {};\n"
"    (trace $name:ident; $($tail:tt)*) => {\n"
"        {\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"    (trace $name:ident = $init:expr; $($tail:tt)*) => {\n"
"        {\n"
"            let $name = $init;\n"
"            println!(concat!(stringify!($name), \" = {:?}\"), $name);\n"
"            mixed_rules!($($tail)*);\n"
"        }\n"
"    };\n"
"}\n"
"#\n"
"# fn main() {\n"
"#     let a = 42;\n"
"#     let b = \"Ho-dee-oh-di-oh-di-oh!\";\n"
"#     let c = (false, 2, 'c');\n"
"#     mixed_rules!(\n"
"#         trace a;\n"
"#         trace b;\n"
"#         trace c;\n"
"#         trace b = \"They took her where they put the crazies.\";\n"
"#         trace b;\n"
"#     );\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:35
msgid ""
"This pattern is perhaps the _most powerful_ macro parsing technique "
"available, allowing one to parse grammars of significant complexity. "
"However, it can increase compile times if used excessively, so should be "
"used with care."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:39
msgid ""
"A _TT muncher_ is a recursive `macro_rules!` macro that works by "
"incrementally processing its input one step at a time. At each step, it "
"matches and removes (munches) some sequence of tokens from the start of its "
"input, generates some intermediate output, then recurses on the input tail."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:42
msgid ""
"The reason for \"TT\" in the name specifically is that the unprocessed part "
"of the input is _always_ captured as `$($tail:tt)*`. This is done as a "
"[`tt`](../minutiae/fragment-specifiers.html#tt) repetition is the only way "
"to _losslessly_ capture part of a macro's input."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:45
msgid ""
"The only hard restrictions on TT munchers are those imposed on the "
"`macro_rules!` macro system as a whole:"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:47
msgid ""
"You can only match against literals and grammar constructs which can be "
"captured by `macro_rules!`."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:48
msgid "You cannot match unbalanced groups."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:50
msgid ""
"It is important, however, to keep the macro recursion limit in mind. "
"`macro_rules!` does not have _any_ form of tail recursion elimination or "
"optimization. It is recommended that, when writing a TT muncher, you make "
"reasonable efforts to keep recursion as limited as possible. This can be "
"done by adding additional rules to account for variation in the input (as "
"opposed to recursion into an intermediate layer), or by making compromises "
"on the input syntax to make using standard repetitions more tractable."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:57
#: src/decl-macros/patterns/internal-rules.md:84
#: src/decl-macros/patterns/push-down-acc.md:78
msgid "Performance"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:59
msgid ""
"TT munchers are inherently quadratic. Consider a TT muncher rule that "
"consumes one token tree and then recursively calls itself on the remaining "
"input. If it is passed 100 token trees:"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:62
msgid "The initial invocation will match against all 100 token trees."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:63
msgid "The first recursive invocation will match against 99 token trees."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:64
msgid "The next recursive invocation will match against 98 token trees."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:66
msgid ""
"And so on, down to 1. This is a classic quadratic pattern, and long inputs "
"can cause macro expansion to blow out compile times."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:69
msgid ""
"Try to avoid using TT munchers too much, especially with long inputs. The "
"default value of the `recursion_limit` attribute is a good sanity check; if "
"you have to exceed it, you might be heading for trouble."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:72
msgid ""
"If you have the choice between writing a TT muncher that can be called once "
"to handle multiple things, or a simpler macro that can be called multiple "
"times to handle a single thing, prefer the latter. For example, you could "
"change a macro that is called like this:"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:84
msgid "To one that is called like this:"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:93
msgid "The longer the input, the more likely this will improve compile times."
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:95
msgid ""
"Also, if a TT muncher macro has many rules, put the most frequently matched "
"rules as early as possible. This avoids unnecessary matching failures. (In "
"fact, this is good advice for any kind of declarative macro, not just TT "
"munchers.)"
msgstr ""

#: src/decl-macros/patterns/tt-muncher.md:100
msgid ""
"Finally, if you can write a macro using normal repetition via `*` or `+`, "
"that should be preferred to a TT muncher. This is most likely if each "
"invocation of the TT muncher would only process one token at a time. In more "
"complicated cases, there is an advanced technique used within the `quote` "
"crate that can avoid the quadratic behaviour, at the cost of some conceptual "
"complexity. See [this "
"comment](https://github.com/dtolnay/quote/blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746) "
"for details."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:18
msgid ""
"Internal rules can be used to unify multiple `macro_rules!` macros into one, "
"or to make it easier to read and write [TT Munchers](./tt-muncher.html) by "
"explicitly naming what rule you wish to call in a macro."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:20
msgid ""
"So why is it useful to unify multiple macros-by-example into one? The main "
"reasoning for this is how they are handled in the 2015 Edition of Rust due "
"to `macro_rules!` macros not being namespaced in said edition. This gives "
"one the troubles of having to re-export all the internal `macro_rules!` "
"macros as well as polluting the global macro namespace or even worse, macro "
"name collisions with other crates. In short, it's quite a hassle. This "
"fortunately isn't really a problem anymore nowadays with a rustc version >= "
"1.30, for more information consult the [Import and Export "
"chapter](../minutiae/import-export.html)."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:26
msgid ""
"Nevertheless, let's talk about how we can unify multiple `macro_rules!` "
"macros into one with this technique and what exactly this technique even is."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:28
msgid ""
"We have two `macro_rules!` macros, the common [`as_expr!` "
"macro](../building-blocks/ast-coercion.html) and a `foo` macro that makes "
"use of the first one:"
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:46
msgid ""
"This is definitely not the nicest solution we could have for this macro, as "
"it pollutes the global macro namespace as mentioned earlier. In this "
"specific case `as_expr` is also a very simple macro that we only used once, "
"so let's \"embed\" this macro in our `foo` macro with internal rules! To do "
"so, we simply prepend a new matcher for our macro, which consists of the "
"matcher used in the `as_expr` macro, but with a small addition. We prepend a "
"tokentree that makes it match only when specifically asked to. In this case "
"we can for example use `@as_expr`, so our matcher becomes `(@as_expr "
"$e:expr) => {$e};`. With this we get the macro that was defined at the very "
"top of this page:"
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:68
msgid ""
"You see how we embedded the `as_expr` macro in the `foo` one? All that "
"changed is that instead of invoking the `as_expr` macro, we now invoke `foo` "
"recursively but with a special token tree prepended to the arguments, "
"`foo!(@as_expr $($tts)*)`. If you look closely you might even see that this "
"pattern can be combined quite nicely with [TT Munchers](./tt-muncher.html)!"
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:72
msgid ""
"The reason for using `@` was that, as of Rust 1.2, the `@` token is _not_ "
"used in prefix position; as such, it cannot conflict with anything. This "
"reasoning became obsolete later on when in Rust 1.7 macro matchers got "
"future proofed by emitting a warning to prevent certain tokens from being "
"allowed to follow certain fragments[^ambiguity-restrictions], which in Rust "
"1.12 became a hard-error. Other symbols or unique prefixes may be used as "
"desired, but use of `@` has started to become widespread, so using it may "
"aid readers in understanding your macro."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:76
msgid "[ambiguity-restrictions](../minutiae/metavar-and-expansion.html)"
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:78
msgid ""
"**Note**: in the early days of Rust the `@` token was previously used in "
"prefix position to denote a garbage-collected pointer, back when the "
"language used sigils to denote pointer types. Its only _current_ purpose is "
"for binding names to patterns. For this, however, it is used as an _infix_ "
"operator, and thus does not conflict with its use here."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:82
msgid ""
"Additionally, internal rules will often come _before_ any \"bare\" rules, to "
"avoid issues with `macro_rules!` incorrectly attempting to parse an internal "
"invocation as something it cannot possibly be, such as an expression."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:86
msgid ""
"One downside of internal rules is that they can hurt compile times. Only one "
"macro rule can match any (valid) macro invocation, but the compiler must try "
"to match all rules in order. If a macro has many rules, there can be many "
"such failures, and the use of internal rules will increase the number of "
"such failures."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:90
msgid ""
"Also, the `@as_expr`\\-style identifier makes rules longer, slightly "
"increasing the amount of work the compiler must do when matching."
msgstr ""

#: src/decl-macros/patterns/internal-rules.md:93
msgid ""
"Therefore, for best performance, avoiding internal rules is best. Avoiding "
"them often makes complex macros easier to read, too."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:3
msgid "The following macro uses _push-down accumulation_."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:5
msgid ""
"```rust\n"
"macro_rules! init_array {\n"
"    [$e:expr; $n:tt] => { \n"
"        {   \n"
"            let e = $e; \n"
"            accum!([$n, e.clone()] -> [])\n"
"        }\n"
"    };\n"
"}\n"
"macro_rules! accum {\n"
"    ([3, $e:expr] -> [$($body:tt)*]) => { accum!([2, $e] -> [$($body)* $e,]) "
"};\n"
"    ([2, $e:expr] -> [$($body:tt)*]) => { accum!([1, $e] -> [$($body)* $e,]) "
"};\n"
"    ([1, $e:expr] -> [$($body:tt)*]) => { accum!([0, $e] -> [$($body)* $e,]) "
"};\n"
"    ([0, $_:expr] -> [$($body:tt)*]) => { [$($body)*] };\n"
"}\n"
"\n"
"let strings: [String; 3] = init_array![String::from(\"hi!\"); 3];\n"
"# assert_eq!(format!(\"{:?}\", strings), \"[\\\"hi!\\\", \\\"hi!\\\", "
"\\\"hi!\\\"]\");\n"
"```"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:25
msgid ""
"All syntax extensions in Rust **must** result in a complete, supported "
"syntax element (such as an expression, item, _etc._). This means that it is "
"impossible to have a syntax extension expand to a partial construct."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:28
msgid ""
"One might hope that the above example could be more directly expressed like "
"so:"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:46
msgid ""
"The expectation is that the expansion of the array literal would proceed as "
"follows:"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:55
msgid ""
"However, this would require each intermediate step to expand to an "
"incomplete expression. Even though the intermediate results will never be "
"used _outside_ of a macro context, it is still forbidden."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:58
msgid ""
"Push-down, however, allows us to incrementally build up a sequence of tokens "
"without needing to actually have a complete construct at any point prior to "
"completion. In the example given at the top, the sequence of invocations "
"proceeds as follows:"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:61
msgid ""
"```rust,ignore\n"
"init_array!(String::from(\"hi!\"); 3)\n"
"accum!([3, e.clone()] -> [])\n"
"accum!([2, e.clone()] -> [e.clone(),])\n"
"accum!([1, e.clone()] -> [e.clone(), e.clone(),])\n"
"accum!([0, e.clone()] -> [e.clone(), e.clone(), e.clone(),])\n"
"[e.clone(), e.clone(), e.clone(),]\n"
"```"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:70
msgid ""
"As you can see, each layer adds to the accumulated output until the "
"terminating rule finally emits it as a complete construct."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:72
msgid ""
"The only critical part of the above formulation is the use of `$($body:tt)*` "
"to preserve the output without triggering parsing. The use of `($input) -> "
"($output)` is simply a convention adopted to help clarify the behavior of "
"such macros."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:75
msgid ""
"Push-down accumulation is frequently used as part of [incremental TT "
"munchers](./tt-muncher.md), as it allows arbitrarily complex intermediate "
"results to be constructed. [Internal Rules](./internal-rules.md) were of use "
"here as well, as they simplify creating such macros."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:80
msgid ""
"Push-down accumulation is inherently quadratic. Consider a push-down "
"accumulation rule that builds up an accumulator of 100 token trees, one "
"token tree per invocation."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:82
msgid "The initial invocation will match against the empty accumulator."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:83
msgid ""
"The first recursive invocation will match against the accumulator of 1 token "
"tree."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:84
msgid ""
"The next recursive invocation will match against the accumulator of 2 token "
"trees."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:86
msgid ""
"And so on, up to 100. This is a classic quadratic pattern, and long inputs "
"can cause macro expansion to blow out compile times. Furthermore, TT "
"munchers are also inherently quadratic over their input, so a macro that "
"uses both TT munching _and_ push-down accumulation will be doubly quadratic!"
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:90
msgid ""
"All the [performance advice](./tt-muncher.md#performance) about TT munchers "
"holds for push-down accumulation.  In general, avoid using them too much, "
"and keep them as simple as possible."
msgstr ""

#: src/decl-macros/patterns/push-down-acc.md:93
msgid ""
"Finally, make sure you put the accumulator at the _end_ of rules, rather "
"than the beginning. That way, if a rule fails, the compiler won't have had "
"to match the (potentially long) accumulator before hitting the part of the "
"rule that fails to match. This can make a large difference to compile times."
msgstr ""

#: src/decl-macros/patterns/repetition-replacement.md:9
msgid ""
"This pattern is where a matched repetition sequence is simply discarded, "
"with the variable being used to instead drive some repeated pattern that is "
"related to the input only in terms of length."
msgstr ""

#: src/decl-macros/patterns/repetition-replacement.md:11
msgid ""
"For example, consider constructing a default instance of a tuple with more "
"than 12 elements (the limit as of Rust 1.2)."
msgstr ""

#: src/decl-macros/patterns/repetition-replacement.md:34
msgid "**: we _could_ have simply used `$tup_tys::default()`."
msgstr ""

#: src/decl-macros/patterns/repetition-replacement.md:36
msgid ""
"Here, we are not actually _using_ the matched types. Instead, we throw them "
"away and replace them with a single, repeated expression. To put it another "
"way, we don't care _what_ the types are, only _how many_ there are."
msgstr ""

#: src/decl-macros/patterns/tt-bundling.md:3
msgid ""
"```rust\n"
"macro_rules! call_a_or_b_on_tail {\n"
"    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) => {\n"
"        $a(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) => {\n"
"        $b(stringify!($($tail)*))\n"
"    };\n"
"\n"
"    ($ab:tt, $_skip:tt $($tail:tt)*) => {\n"
"        call_a_or_b_on_tail!($ab, $($tail)*)\n"
"    };\n"
"}\n"
"\n"
"fn compute_len(s: &str) -> Option<usize> {\n"
"    Some(s.len())\n"
"}\n"
"\n"
"fn show_tail(s: &str) -> Option<usize> {\n"
"    println!(\"tail: {:?}\", s);\n"
"    None\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            the recursive part that skips over all these\n"
"            tokens does not much care whether we will call a\n"
"            or call b: only the terminal rules care.\n"
"        ),\n"
"        None\n"
"    );\n"
"    assert_eq!(\n"
"        call_a_or_b_on_tail!(\n"
"            (a: compute_len, b: show_tail),\n"
"            and now, to justify the existence of two paths\n"
"            we will also call a: its input should somehow\n"
"            be self-referential, so let us make it return\n"
"            some ninety-one!\n"
"        ),\n"
"        Some(91)\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/patterns/tt-bundling.md:50
msgid ""
"In particularly complex recursive macros, a large number of arguments may be "
"needed in order to carry identifiers and expressions to successive layers. "
"However, depending on the implementation there may be many intermediate "
"layers which need to forward these arguments, but do not need to _use_ them."
msgstr ""

#: src/decl-macros/patterns/tt-bundling.md:53
msgid ""
"As such, it can be very useful to bundle all such arguments together into a "
"single TT by placing them in a group. This allows layers which do not need "
"to use the arguments to simply capture and substitute a single "
"[`tt`](../minutiae/fragment-specifiers.html#tt), rather than having to "
"exactly capture and substitute the entire argument group."
msgstr ""

#: src/decl-macros/patterns/tt-bundling.md:56
msgid ""
"The example above bundles the `$a` and `$b` expressions into a group which "
"can then be forwarded as a single "
"[`tt`](../minutiae/fragment-specifiers.html#tt) by the recursive rule. This "
"group is then destructured by the terminal rules to access the expressions."
msgstr ""

#: src/decl-macros/building-blocks.md:3
msgid "Reusable snippets of `macro_rules!` macro code."
msgstr ""

#: src/decl-macros/building-blocks/ast-coercion.md:3
msgid ""
"The Rust parser is not very robust in the face of `tt` substitutions. "
"Problems can arise when the parser is expecting a particular grammar "
"construct and _instead_ finds a lump of substituted `tt` tokens. Rather than "
"attempt to parse them, it will often just _give up_. In these cases, it is "
"necessary to employ an AST coercion."
msgstr ""

#: src/decl-macros/building-blocks/ast-coercion.md:22
msgid ""
"These coercions are often used with [push-down "
"accumulation](../patterns/push-down-acc.md) macros in order to get the "
"parser to treat the final `tt` sequence as a particular kind of grammar "
"construct."
msgstr ""

#: src/decl-macros/building-blocks/ast-coercion.md:24
msgid ""
"Note that this specific set of macros is determined by what macros are "
"allowed to expand to, _not_ what they are able to capture."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:3
msgid ""
"What follows are several techniques for counting in `macro_rules!` macros:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:5
msgid ""
"**Note**: If you are just interested in the most efficient way [look "
"here](./counting.md#bit-twiddling)"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:7
msgid "Repetition with replacement"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:9
msgid ""
"Counting things in a macro is a surprisingly tricky task. The simplest way "
"is to use replacement with a repetition match."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:26
msgid ""
"This is a fine approach for smallish numbers, but will likely _crash the "
"compiler_ with inputs of around 500 or so tokens. Consider that the output "
"will look something like this:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:33
msgid ""
"The compiler must parse this into an AST, which will produce what is "
"effectively a perfectly unbalanced binary tree 500+ levels deep."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:35
msgid "Recursion"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:37
msgid "An older approach is to use recursion."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:50
msgid ""
"**Note**: As of `rustc` 1.2, the compiler has _grievous_ performance "
"problems when large numbers of integer literals of unknown type must undergo "
"inference. We are using explicitly `usize`\\-typed literals here to avoid "
"that."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:53
msgid ""
"If this is not suitable (such as when the type must be substitutable), you "
"can help matters by using `as` (_e.g._ `0 as $ty`, `1 as $ty`, _etc._)."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:55
msgid ""
"This _works_, but will trivially exceed the recursion limit. Unlike the "
"repetition approach, you can extend the input size by matching multiple "
"tokens at once."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:58
msgid ""
"```rust\n"
"macro_rules! count_tts {\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt\n"
"     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt\n"
"     $($tail:tt)*)\n"
"        => {20usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt\n"
"     $($tail:tt)*)\n"
"        => {10usize + count_tts!($($tail)*)};\n"
"    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt\n"
"     $($tail:tt)*)\n"
"        => {5usize + count_tts!($($tail)*)};\n"
"    ($_a:tt\n"
"     $($tail:tt)*)\n"
"        => {1usize + count_tts!($($tail)*)};\n"
"    () => {0usize};\n"
"}\n"
"\n"
"fn main() {\n"
"    assert_eq!(700, count_tts!(\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        // Repetition breaks somewhere after this\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,\n"
"    ));\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:106
msgid "This particular formulation will work up to ~1,200 tokens."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:108
msgid "Slice length"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:110
msgid ""
"A third approach is to help the compiler construct a shallow AST that won't "
"lead to a stack overflow. This can be done by constructing an array literal "
"and calling the `len` method."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:127
msgid ""
"This has been tested to work up to 10,000 tokens, and can probably go much "
"higher."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:129
msgid "Array length"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:131
msgid ""
"Another modification of the previous approach is to use const generics "
"stabilized in Rust 1.51. It's only slightly slower than slice length method "
"on 20,000 tokens and works in const contexts."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:152
msgid "Enum counting"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:154
msgid ""
"This approach can be used where you need to count a set of mutually distinct "
"identifiers."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:175
msgid ""
"This method does have two drawbacks. As implied above, it can _only_ count "
"valid identifiers (which are also not keywords), and it does not allow those "
"identifiers to repeat."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:178
msgid "Bit twiddling"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:180
msgid "Another recursive approach using bit operations:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:194
msgid ""
"This approach is pretty smart as it effectively halves its input whenever "
"its even and then multiplying the counter by 2 (or in this case shifting 1 "
"bit to the left which is equivalent). If the input is uneven it simply takes "
"one token tree from the input `or`s the token tree to the previous counter "
"which is equivalent to adding 1 as the lowest bit has to be a 0 at this "
"point due to the previous shifting. Rinse and repeat until we hit the base "
"rule `() => 0`."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:198
msgid ""
"The benefit of this is that the constructed AST expression that makes up the "
"counter value will grow with a complexity of `O(log(n))` instead of `O(n)` "
"like the other approaches. Be aware that you can still hit the recursion "
"limit with this if you try hard enough. Credits for this method go to Reddit "
"user "
"[`YatoRust`](https://www.reddit.com/r/rust/comments/d3yag8/the_little_book_of_rust_macros/)."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:203
msgid "Let's go through the procedure by hand once:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:208
msgid ""
"This invocation will match the third rule due to the fact that we have an "
"even number of token trees(10). The matcher names the odd token trees in the "
"sequence `$a` and the even ones `$even` but the expansion only makes use of "
"`$a`, which means it effectively discards all the even elements cutting the "
"input in half. So the invocation now becomes:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:214
msgid ""
"This invocation will now match the second rule as its input is an uneven "
"amount of token trees. In this case the first token tree is discarded to "
"make the input even again, then we also do the halving step in this "
"invocation again since we know the input would be even now anyways. "
"Therefore we can count 1 for the uneven discard and multiply by 2 again "
"since we also halved."
msgstr ""

#: src/decl-macros/building-blocks/counting.md:230
msgid ""
"Now to check if we expanded correctly manually we can use a one of the tools "
"we introduced for [`debugging`](../minutiae/debugging.md). When expanding "
"the macro there we should get:"
msgstr ""

#: src/decl-macros/building-blocks/counting.md:236
msgid "That's the same so we didn't make any mistakes, great!"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:1
msgid "Abacus Counters"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:3
msgid ""
"**Provisional**: needs a more compelling example. Matching nested groups "
"that are _not_ denoted by Rust groups is sufficiently unusual that it may "
"not merit inclusion."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:6
msgid ""
"**Note**: this section assumes understanding of [push-down "
"accumulation](#push-down-accumulation) and [incremental TT "
"munchers](#incremental-tt-munchers)."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:8
msgid ""
"```rust\n"
"macro_rules! abacus {\n"
"    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((- $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (- $($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> ($($count)*))\n"
"    };\n"
"    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {\n"
"        abacus!(($($moves)*) -> (+ $($count)*))\n"
"    };\n"
"\n"
"    // Check if the final result is zero.\n"
"    (() -> ()) => { true };\n"
"    (() -> ($($count:tt)+)) => { false };\n"
"}\n"
"\n"
"fn main() {\n"
"    let equals_zero = abacus!((++-+-+++--++---++----+) -> ());\n"
"    assert_eq!(equals_zero, true);\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:34
msgid ""
"This technique can be used in cases where you need to keep track of a "
"varying counter that starts at or near zero, and must support the following "
"operations:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:36
msgid "Increment by one."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:37
msgid "Decrement by one."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:38
msgid "Compare to zero (or any other fixed, finite value)."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:40
msgid ""
"A value of _n_ is represented by _n_ instances of a specific token stored in "
"a group. Modifications are done using recursion and [push-down "
"accumulation](#push-down-accumulation). Assuming the token used is `x`, the "
"operations above are implemented as follows:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:44
msgid "Increment by one: match `($($count:tt)*)`, substitute `(x $($count)*)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:45
msgid "Decrement by one: match `(x $($count:tt)*)`, substitute `($($count)*)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:46
msgid "Compare to zero: match `()`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:47
msgid "Compare to one: match `(x)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:48
msgid "Compare to two: match `(x x)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:49
#: src/decl-macros/building-blocks/abacus-counting.md:78
msgid "_(and so on...)_"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:51
msgid ""
"In this way, operations on the counter are like flicking tokens back and "
"forth like an abacus.[^abacus]"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:53
msgid ""
"This desperately thin reasoning conceals the _real_ reason for this name: to "
"avoid having _yet another_ thing with \"token\" in the name. Talk to your "
"writer about avoiding [semantic "
"satiation](https://en.wikipedia.org/wiki/Semantic_satiation) today!  \n"
"In fairness, it could _also_ have been called [\"unary "
"counting\"](https://en.wikipedia.org/wiki/Unary_numeral_system)."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:58
msgid ""
"In cases where you want to represent negative values, _\\-n_ can be "
"represented as _n_ instances of a _different_ token. In the example given "
"above, _+n_ is stored as _n_ `+` tokens, and _\\-m_ is stored as _m_ `-` "
"tokens."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:62
msgid ""
"In this case, the operations become slightly more complicated; increment and "
"decrement effectively reverse their usual meanings when the counter is "
"negative. To which given `+` and `-` for the positive and negative tokens "
"respectively, the operations change to:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:65
msgid "Increment by one:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:66
msgid "match `()`, substitute `(+)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:67
msgid "match `(- $($count:tt)*)`, substitute `($($count)*)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:68
msgid "match `($($count:tt)+)`, substitute `(+ $($count)+)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:69
msgid "Decrement by one:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:70
msgid "match `()`, substitute `(-)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:71
msgid "match `(+ $($count:tt)*)`, substitute `($($count)*)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:72
msgid "match `($($count:tt)+)`, substitute `(- $($count)+)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:73
msgid "Compare to 0: match `()`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:74
msgid "Compare to +1: match `(+)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:75
msgid "Compare to -1: match `(-)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:76
msgid "Compare to +2: match `(++)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:77
msgid "Compare to -2: match `(--)`."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:80
msgid ""
"Note that the example at the top combines some of the rules together (for "
"example, it combines increment on `()` and `($($count:tt)+)` into an "
"increment on `($($count:tt)*)`)."
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:82
msgid ""
"If you want to extract the actual _value_ of the counter, this can be done "
"using a regular [counter macro](./counting.md). For the example above, the "
"terminal rules can be replaced with the following:"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:85
msgid ""
"```rust,ignore\n"
"macro_rules! abacus {\n"
"    // ...\n"
"\n"
"    // This extracts the counter as an integer expression.\n"
"    (() -> ()) => {0};\n"
"    (() -> (- $($count:tt)*)) => {\n"
"        - ( count_tts!($( $count_tts:tt )*) )\n"
"    };\n"
"    (() -> (+ $($count:tt)*)) => {\n"
"        count_tts!($( $count_tts:tt )*)\n"
"    };\n"
"}\n"
"\n"
"// One of the many token tree counting macros in the counting chapter\n"
"macro_rules! count_tts {\n"
"    // ...\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/building-blocks/abacus-counting.md:105
msgid ""
"**: strictly speaking, the above formulation of `abacus!` is needlessly "
"complex. It can be implemented much more efficiently using repetition, "
"provided you _do not_ need to match against the counter's value in a macro:"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:3
msgid ""
"Parsing some of Rust's items can be useful in certain situations. This "
"section will show a few macros that can parse some of Rust's more complex "
"items like structs and functions to a certain extent. The goal of these "
"macros is not to be able to parse the entire grammar of the items but to "
"parse parts that are in general quite useful without being too complex to "
"parse. This means we ignore things like generics and such."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:7
msgid ""
"The main points of interest of these macros are their `matchers`. The "
"transcribers are only there for example purposes and are usually not that "
"impressive."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:10
msgid "Function"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:12
msgid ""
"```rust\n"
"macro_rules! function_item_matcher {\n"
"    (\n"
"\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? "
")\n"
"    //                          ^~~~~~~~~~~~~~~~argument "
"list!~~~~~~~~~~~~~~^\n"
"            $( -> $ret_ty:ty )?\n"
"    //      ^~~~return type~~~^\n"
"            { $($tt:tt)* }\n"
"    //      ^~~~~body~~~~^\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )? { "
"$($tt)* }\n"
"    }\n"
"}\n"
"\n"
"#function_item_matcher!(\n"
"#    #[inline]\n"
"#    #[cold]\n"
"#    pub fn foo(bar: i32, baz: i32, ) -> String {\n"
"#        format!(\"{} {}\", bar, baz)\n"
"#    }\n"
"#);\n"
"#\n"
"# fn main() {\n"
"#     assert_eq!(foo(13, 37), \"13 37\");\n"
"# }\n"
"```"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:43
msgid ""
"A simple function matcher that ignores qualifiers like `unsafe`, `async`, "
"... as well as generics and where clauses. If parsing those is required it "
"is likely that you are better off using a proc-macro instead."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:46
msgid ""
"This lets you for example, inspect the function signature, generate some "
"extra things from it and then re-emit the entire function again. Kind of "
"like a `Derive` proc-macro but weaker and for functions."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:49
msgid ""
"Ideally we would like to use a pattern fragment specifier instead of an "
"ident for the arguments but this is currently not allowed. Fortunately "
"people don't use non-identifier patterns in function signatures that often "
"so this is okay(a shame, really)."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:52
msgid "Method"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:54
msgid ""
"The macro for parsing basic functions is nice and all, but sometimes we "
"would like to also parse methods, functions that refer to their object via "
"some form of `self` usage. This makes things a bit trickier:"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:56
msgid "WIP"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:58
msgid "Struct"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:60
msgid ""
"```rust\n"
"macro_rules! struct_item_matcher {\n"
"    // Unit-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident;\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name;\n"
"    };\n"
"\n"
"    // Tuple-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident (\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~~^\n"
"                $field_vis:vis $field_ty:ty\n"
"    //          ^~~~~~a single field~~~~~~^\n"
"            ),*\n"
"        $(,)? );\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name (\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_ty\n"
"            ),*\n"
"        );\n"
"    };\n"
"\n"
"    // Named-Struct\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"    //  ^~~~attributes~~~~^\n"
"        $vis:vis struct $name:ident {\n"
"            $(\n"
"                $( #[$field_meta:meta] )*\n"
"    //          ^~~~field attributes~~~!^\n"
"                $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"            ),*\n"
"        $(,)? }\n"
"    ) => {\n"
"        $( #[$meta] )*\n"
"        $vis struct $name {\n"
"            $(\n"
"                $( #[$field_meta] )*\n"
"                $field_vis $field_name : $field_ty\n"
"            ),*\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Foo {\n"
"#       pub bar: i32,\n"
"#       baz: &'static str,\n"
"#       qux: f32\n"
"#    }\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) struct Bar;\n"
"#);\n"
"#struct_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) struct Baz (i32, pub f32, String);\n"
"#);\n"
"#fn main() {\n"
"#    let _: Foo = Foo { bar: 42, baz: \"macros can be nice\", qux: 3.14, };\n"
"#    let _: Bar = Bar;\n"
"#    let _: Baz = Baz(2, 0.1234, String::new());\n"
"#}\n"
"```"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:140
msgid "Enum"
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:142
msgid ""
"Parsing enums is a bit more complex than structs so we will finally make use "
"of some of the [patterns](../patterns.md) we have discussed, [Incremental TT "
"Muncher](../patterns/tt-muncher.md) and [Internal "
"Rules](../patterns/internal-rules.md). Instead of just building the parsed "
"enum again we will merely visit all the tokens of the enum, as rebuilding "
"the enum would require us to collect all the parsed tokens temporarily again "
"via a [Push Down Accumulator](../patterns/push-down-acc.md)."
msgstr ""

#: src/decl-macros/building-blocks/parsing.md:145
msgid ""
"```rust\n"
"macro_rules! enum_item_matcher {\n"
"    // tuple variant\n"
"    (@variant $variant:ident (\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~~^\n"
"            $field_vis:vis $field_ty:ty\n"
"    //      ^~~~~~a single field~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    ) $(, $($tt:tt)* )? ) => {\n"
"\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // named variant\n"
"    (@variant $variant:ident {\n"
"        $(\n"
"            $( #[$field_meta:meta] )*\n"
"    //      ^~~~field attributes~~~!^\n"
"            $field_vis:vis $field_name:ident : $field_ty:ty\n"
"    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^\n"
"        ),* $(,)?\n"
"    //∨~~rest of input~~∨\n"
"    } $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // unit variant\n"
"    (@variant $variant:ident $(, $($tt:tt)* )? ) => {\n"
"        // process rest of the enum\n"
"        $( enum_item_matcher!(@variant $( $tt )*) )?\n"
"    };\n"
"    // trailing comma\n"
"    (@variant ,) => {};\n"
"    // base case\n"
"    (@variant) => {};\n"
"    // entry point\n"
"    (\n"
"        $( #[$meta:meta] )*\n"
"        $vis:vis enum $name:ident {\n"
"            $($tt:tt)*\n"
"        }\n"
"    ) => {\n"
"        enum_item_matcher!(@variant $($tt)*)\n"
"    };\n"
"}\n"
"\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Foo {\n"
"#        Bar,\n"
"#        Baz,\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Copy, Clone)]\n"
"#    pub(crate) enum Bar {\n"
"#        Foo(i32, f32),\n"
"#        Bar,\n"
"#        Baz(),\n"
"#    }\n"
"#);\n"
"#enum_item_matcher!(\n"
"#    #[derive(Clone)]\n"
"#    pub(crate) enum Baz {}\n"
"#);\n"
"```"
msgstr ""

#: src/decl-macros/macros2.md:3
msgid ""
"_RFC_: "
"[rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md) "
" \n"
"_Tracking Issue_: "
"[rust#39412](https://github.com/rust-lang/rust/issues/39412)  \n"
"_Feature_: `#![feature(decl_macro)]`"
msgstr ""

#: src/decl-macros/macros2.md:7
msgid ""
"While not yet stable(or rather far from being finished), there is proposal "
"for a new declarative macro system that is supposed to replace "
"`macro_rules!` dubbed declarative macros 2.0, `macro`, `decl_macro` or "
"confusingly also `macros-by-example`."
msgstr ""

#: src/decl-macros/macros2.md:9
msgid ""
"This chapter is only meant to quickly glance over the current state, showing "
"how to use this macro system and where it differs. Nothing described here is "
"final or complete, and may be subject to change."
msgstr ""

#: src/decl-macros/macros2.md:12
msgid "Syntax"
msgstr ""

#: src/decl-macros/macros2.md:14
msgid ""
"We'll do a comparison between the `macro` and `macro_rules` syntax for two "
"macros we have implemented in previous chapters:"
msgstr ""

#: src/decl-macros/macros2.md:38
msgid ""
"As can be seen, they look very similar, with just a few differences as well "
"as that `macro`s have two different forms."
msgstr ""

#: src/decl-macros/macros2.md:40
msgid ""
"Let's inspect the `count_tts` macro first, as that one looks more like what "
"we are used to. As can be seen, it practically looks identical to the "
"`macro_rules` version with two exceptions, it uses the `macro` keyword and "
"the rule separator is a `,` instead of a `;`."
msgstr ""

#: src/decl-macros/macros2.md:43
msgid ""
"There is a second form to this though, which is a shorthand for macros that "
"only have one rule. Taking a look at `replace_expr` we can see that in this "
"case we can write the definition in a way that more resembles an ordinary "
"function. We can write the matcher directly after the name followed by the "
"transcriber, dropping a pair of braces and the `=>` token."
msgstr ""

#: src/decl-macros/macros2.md:47
msgid ""
"Syntax for invoking `macro`s is the same as for `macro_rules` and "
"function-like procedural macros, the name followed by a `!` followed by the "
"macro input token tree."
msgstr ""

#: src/decl-macros/macros2.md:49
msgid "`macro` are proper items"
msgstr ""

#: src/decl-macros/macros2.md:51
msgid ""
"Unlike with `macro_rules` macros, which are textually scoped and require "
"`#[macro_export]`(and potentially a re-export) to be treated as an item, "
"`macro` macros behave like proper rust items by default."
msgstr ""

#: src/decl-macros/macros2.md:53
msgid ""
"As such, you can properly qualify them with visibility specifiers like "
"`pub`, `pub(crate)`, `pub(in path)` and the like."
msgstr ""

#: src/decl-macros/macros2.md:58
msgid ""
"Hygiene is by far the biggest difference between the two declarative macro "
"systems. Unlike `macro_rules` which have [mixed site "
"hygiene](./minutiae/hygiene.md), `macro` have definition site hygiene, "
"meaning they do not leak identifiers outside of their invocation."
msgstr ""

#: src/decl-macros/macros2.md:61
msgid ""
"As such the following compiles with a `macro_rules` macro, but fails with a "
"`macro` definition:"
msgstr ""

#: src/decl-macros/macros2.md:63
msgid ""
"```rust\n"
"#![feature(decl_macro)]\n"
"// try uncommenting the following line, and commenting out the line right "
"after\n"
"\n"
"macro_rules! foo {\n"
"// macro foo {\n"
"    ($name: ident) => {\n"
"        pub struct $name;\n"
"\n"
"        impl $name {\n"
"            pub fn new() -> $name {\n"
"                $name\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"foo!(Foo);\n"
"\n"
"fn main() {\n"
"    // this fails with a `macro`, but succeeds with a `macro_rules`\n"
"    let foo = Foo::new();\n"
"}\n"
"```"
msgstr ""

#: src/decl-macros/macros2.md:88
msgid ""
"There may be plans to allow escaping hygiene for identifiers(hygiene "
"bending) in the future."
msgstr ""

#: src/proc-macros.md:3
msgid "Note: This section is still very incomplete!"
msgstr ""

#: src/proc-macros.md:5
msgid ""
"This chapter will introduce Rust's second syntax extension type, _procedural "
"macros_."
msgstr ""

#: src/proc-macros.md:7
msgid ""
"As with the [declarative macros](./decl-macros.md) chapter, this one is also "
"split into a [methodical](./proc-macros/methodical.md) and a (WIP) practical "
"subchapter with the former being a more formal introduction and the latter "
"being a more practical oriented one."
msgstr ""

#: src/proc-macros.md:9
msgid ""
"A lot of the basic information covered has been sourced from the [rust "
"reference](https://doc.rust-lang.org/nightly/reference/introduction.html), "
"as most knowledge about procedural macros is currently located there."
msgstr ""

#: src/proc-macros/methodical.md:3
msgid ""
"This chapter will introduce Rust's procedural macro system by explaining the "
"system as a whole."
msgstr ""

#: src/proc-macros/methodical.md:5
msgid ""
"Unlike a [declarative macro](../decl-macros.md), a procedural macro takes "
"the form of a Rust function taking in a token stream(or two) and outputting "
"a token stream."
msgstr ""

#: src/proc-macros/methodical.md:7
msgid ""
"A proc-macro is at its core just a function exported from a crate with the "
"`proc-macro` [crate type](https://doc.rust-lang.org/reference/linkage.html), "
"so when writing multiple proc macros you can have them all live in one crate."
msgstr ""

#: src/proc-macros/methodical.md:9
msgid ""
"**Note**: When using Cargo, to define a `proc-macro` crate you define and "
"set the `lib.proc-macro` key in the `Cargo.toml` to true."
msgstr ""

#: src/proc-macros/methodical.md:15
msgid ""
"A `proc-macro` type crate implicitly links to the compiler-provided "
"[proc_macro](https://doc.rust-lang.org/proc_macro/index.html) crate, which "
"contains all the things you need to get going with developing procedural "
"macros. The two most important types exposed by the crate are the "
"[`TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html), "
"which are the proc-macro variant of the already familiar token trees as well "
"as the [`Span`](https://doc.rust-lang.org/proc_macro/struct.Span.html), "
"which describes a part of source code used primarily for error reporting and "
"hygiene. See the [Hygiene and Spans](./hygiene.md) chapter for more "
"information."
msgstr ""

#: src/proc-macros/methodical.md:18
msgid ""
"As proc-macros therefore are functions living in a crate, they can be "
"addressed as all the other items in a Rust project. All thats required to "
"add the crate to the dependency graph of a project and bring the desired "
"item into scope."
msgstr ""

#: src/proc-macros/methodical.md:21
msgid ""
"**Note**: Procedural macros invocations still run at the same stage in the "
"compiler expansion-wise as declarative macros, just that they are standalone "
"Rust programs that the compiler compiles, runs, and finally either replaces "
"or appends to."
msgstr ""

#: src/proc-macros/methodical.md:24
msgid "Types of procedural macros"
msgstr ""

#: src/proc-macros/methodical.md:26
msgid ""
"With procedural macros, there actually exists 3 different kinds with each "
"having slightly different properties."
msgstr ""

#: src/proc-macros/methodical.md:27
msgid ""
"_function-like_ proc-macros which are used to implement `$name ! $arg` "
"invocable macros"
msgstr ""

#: src/proc-macros/methodical.md:28
msgid "_attribute_ proc-macros which are used to implement `#[$arg]` attributes"
msgstr ""

#: src/proc-macros/methodical.md:29
msgid ""
"_derive_ proc-macros which are used to implement a derive, an _input_ to a "
"`#[derive(…)]` attribute"
msgstr ""

#: src/proc-macros/methodical.md:31
msgid ""
"At their core, all 3 work almost the same with a few differences in their "
"inputs and output reflected by their function definition. As mentioned all a "
"procedural macro really is, is a function that maps a token stream so let's "
"take a quick look at each basic definition and their differences."
msgstr ""

#: src/proc-macros/methodical.md:34
msgid "_function-like_"
msgstr ""

#: src/proc-macros/methodical.md:42
msgid "_attribute_"
msgstr ""

#: src/proc-macros/methodical.md:50
msgid "_derive_"
msgstr ""

#: src/proc-macros/methodical.md:58
msgid ""
"As shown, the basic structure is the same for each, a public function marked "
"with an attribute defining its procedural macro type returning a "
"`TokenStream`. Note how the return type is a `TokenStream` and not a result "
"or something else that gives the notion of being fallible. This does not "
"mean that proc-macros cannot fail though, in fact they have two ways of "
"reporting errors, the first one being to panic and the second to emit a "
"[`compile_error!`](https://doc.rust-lang.org/std/macro.compile_error.html) "
"invocation. If a proc-macro panics the compiler will catch it and emit the "
"payload as an error coming from the macro invocation."
msgstr ""

#: src/proc-macros/methodical.md:63
msgid ""
"**Beware**: The compiler will happily hang on endless loops spun up inside "
"proc-macros causing the compilation of crates using the proc-macro to hang "
"as well."
msgstr ""

#: src/proc-macros/methodical/function-like.md:3
msgid ""
"Function-like procedural macros are invoked like declarative macros that is "
"`makro!(…)`."
msgstr ""

#: src/proc-macros/methodical/function-like.md:5
msgid ""
"This type of macro is the simplest of the three though. It is also the only "
"one which you can't differentiate from declarative macros when solely "
"looking at the invocation."
msgstr ""

#: src/proc-macros/methodical/function-like.md:8
msgid ""
"A simple skeleton of a function-like procedural macro looks like the "
"following:"
msgstr ""

#: src/proc-macros/methodical/function-like.md:18
msgid ""
"As one can see this is in fact just a mapping from one "
"[`TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html) "
"to another where the `input` will be the tokens inside of the invocation "
"delimiters, e.g. for an example invocation `foo!(bar)` the input token "
"stream would consist of the `bar` token. The returned token stream will "
"**replace** the macro invocation."
msgstr ""

#: src/proc-macros/methodical/function-like.md:21
msgid ""
"For this macro type the same placement and expansion rules apply as for "
"declarative macros, that is the macro must output a correct token stream for "
"the invocation location. Unlike with declarative macros though, "
"function-like procedural macros do not have certain restrictions imposed on "
"their inputs though. That is the restrictions for what may follow fragment "
"specifiers listed in the [Metavariables and Expansion "
"Redux](../../decl-macros/minutiae/metavar-and-expansion.md) chapter listed "
"is not applicable here, as the procedural macros work on the tokens directly "
"instead of matching them against fragment specifiers or similar."
msgstr ""

#: src/proc-macros/methodical/function-like.md:25
msgid ""
"With that said it is apparent that the procedural counter part to these "
"macros is more powerful as they can arbitrarily modify their input, and "
"produce any output desired as long as its within the bounds of the language "
"syntax."
msgstr ""

#: src/proc-macros/methodical/function-like.md:29
#: src/proc-macros/methodical/attr.md:26
#: src/proc-macros/methodical/derive.md:20
#: src/proc-macros/methodical/derive.md:50
msgid "Usage example:"
msgstr ""

#: src/proc-macros/methodical/attr.md:3
msgid ""
"Attribute procedural macros define new _outer_ attributes which can be "
"attached to items. This type can be invoked with the `#[attr]` or "
"`#[attr(…)]` syntax where `…` is an arbitrary token tree."
msgstr ""

#: src/proc-macros/methodical/attr.md:6
msgid ""
"A simple skeleton of an attribute procedural macro looks like the following:"
msgstr ""

#: src/proc-macros/methodical/attr.md:16
msgid ""
"Of note here is that unlike the other two procedural macro kinds, this one "
"has two input parameters instead of one."
msgstr ""

#: src/proc-macros/methodical/attr.md:17
msgid ""
"The first parameter is the delimited token tree following the attribute's "
"name, excluding the delimiters around it. It is empty if the attribute is "
"written bare, that is just a name without a `(TokenTree)` following it, e.g. "
"`#[attr]`."
msgstr ""

#: src/proc-macros/methodical/attr.md:19
msgid ""
"The second token stream is the item the attribute is attached to _without_ "
"the attribute this proc macro defines. As this is an "
"[`active`](https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes) "
"attribute, the attribute will be stripped from the item before it is being "
"passed to the proc macro."
msgstr ""

#: src/proc-macros/methodical/attr.md:22
msgid ""
"The returned token stream will **replace** the annotated item fully. Note "
"that the replacement does not have to be a single item, it can be 0 or more."
msgstr ""

#: src/proc-macros/methodical/derive.md:3
msgid ""
"Derive procedural macros define new inputs for the "
"[`derive`](https://doc.rust-lang.org/reference/attributes/derive.html) "
"attribute. This type can be invoked by feeding it to a derive attribute's "
"input, e.g. `#[derive(TlbormDerive)]`."
msgstr ""

#: src/proc-macros/methodical/derive.md:6
msgid "A simple skeleton of a derive procedural macro looks like the following:"
msgstr ""

#: src/proc-macros/methodical/derive.md:16
msgid ""
"The `proc_macro_derive` is a bit more special in that it requires an extra "
"identifier, this identifier will become the actual name of the derive proc "
"macro. The input token stream is the item the derive attribute is attached "
"to, that is, it will always be an `enum`, `struct` or `union` as these are "
"the only items a derive attribute can annotate. The returned token stream "
"will be **appended** to the containing block or module of the annotated item "
"with the requirement that the token stream consists of a set of valid items."
msgstr ""

#: src/proc-macros/methodical/derive.md:28
msgid "Helper Attributes"
msgstr ""

#: src/proc-macros/methodical/derive.md:30
msgid ""
"Derive proc macros are a bit more special in that they can add additional "
"attributes visible only in the scope of the item definition. These "
"attributes are called _derive macro helper attributes_ and are "
"[inert](https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes). "
"Their purpose is to give derive proc macros additional customizability on a "
"per field or variant basis, that is these attributes can be used to annotate "
"fields or enum variants while having no effect on their own. As they are "
"`inert` they will not be stripped and are visible to all macros."
msgstr ""

#: src/proc-macros/methodical/derive.md:35
msgid ""
"They can be defined by adding an `attributes(helper0, helper1, ..)` argument "
"to the `proc_macro_derive` attribute containing a comma separated list of "
"identifiers which are the names of the helper attributes."
msgstr ""

#: src/proc-macros/methodical/derive.md:37
msgid ""
"Thus a simple skeleton of a derive procedural macro with helper attributes "
"looks like the following:"
msgstr ""

#: src/proc-macros/methodical/derive.md:47
msgid ""
"That is all there is to helper attributes, to consume them in the proc macro "
"the implementation will then have to check the attributes of fields and "
"variants to see whether they are attributed with the corresponding helper. "
"It is an error to use a helper attribute if none of the used derive macros "
"of the given item declare it as such, as the compiler will then instead try "
"to resolve it as a normal attribute."
msgstr ""

#: src/proc-macros/third-party-crates.md:3
msgid ""
"**Note**: Crates beyond the automatically linked "
"[`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate are not required "
"to write procedural macros. The crates listed here merely make writing them "
"simpler and more concise, while potentially adding to the compilation time "
"of the procedural macro due to added dependencies."
msgstr ""

#: src/proc-macros/third-party-crates.md:6
msgid ""
"As procedural macros live in a crate they can naturally depend on "
"([crates.io](https://crates.io/)) crates. turns out the crate ecosystem has "
"some really helpful crates tailored towards procedural macros that this "
"chapter will quickly go over, most of which will be used in the following "
"chapters to implement the example macros. As these are merely quick "
"introductions it is advised to look at each crate's documentation for more "
"in-depth information if required."
msgstr ""

#: src/proc-macros/third-party-crates.md:10
msgid "[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/)"
msgstr ""

#: src/proc-macros/third-party-crates.md:12
msgid ""
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/), the successor "
"of the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate! Or so "
"you might think but that is of course not correct, the name might be a bit "
"misleading. This crate is actually just a wrapper around the "
"[`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate serving two "
"specific purposes, taken from the documentation:"
msgstr ""

#: src/proc-macros/third-party-crates.md:14
msgid ""
"Bring proc-macro-like functionality to other contexts like build.rs and "
"main.rs."
msgstr ""

#: src/proc-macros/third-party-crates.md:15
msgid "Make procedural macros unit testable."
msgstr ""

#: src/proc-macros/third-party-crates.md:17
msgid ""
"As the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate is "
"exclusive to [`proc_macro`](https://doc.rust-lang.org/proc_macro/) type "
"crates, making them unit testable or accessing them from non-proc macro code "
"is next to impossible. With that in mind the "
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/) crate mimics the "
"original [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate's api, "
"acting as a wrapper in proc-macro crates and standing on its own in "
"non-proc-macro crates. Hence it is advised to build libraries targeting "
"proc-macro code to be built against "
"[`proc-macro2`](https://docs.rs/proc-macro2/*/proc_macro2/) instead as that "
"will enable those libraries to be unit testable, which is also the reason "
"why the following listed crates take and emit "
"[`proc-macro2::TokenStream`](https://docs.rs/proc-macro2/1.0.27/proc_macro2/struct.TokenStream.html)s "
"instead. When a `proc_macro` token stream is required, one can simply "
"`.into()` the `proc-macro2` token stream to get the `proc_macro` version and "
"vice-versa."
msgstr ""

#: src/proc-macros/third-party-crates.md:22
msgid ""
"Procedural macros using the `proc-macro2` crate will usually import the "
"`proc-macro2::TokenStream` in an aliased form like `use "
"proc-macro2::TokenStream as TokenStream2`."
msgstr ""

#: src/proc-macros/third-party-crates.md:24
msgid "[`quote`](https://docs.rs/quote/*/quote/)"
msgstr ""

#: src/proc-macros/third-party-crates.md:26
msgid ""
"The [`quote`](https://docs.rs/quote/*/quote/) crate mainly exposes just one "
"macro, the [`quote!`](https://docs.rs/quote/1/quote/macro.quote.html) macro."
msgstr ""

#: src/proc-macros/third-party-crates.md:28
msgid ""
"This little macro allows you to easily create token streams by writing the "
"actual source out as syntax while also giving you the power of interpolating "
"tokens right into the written syntax. "
"[Interpolation](https://docs.rs/quote/1/quote/macro.quote.html#interpolation) "
"can be done by using the `#local` syntax where local refers to a local in "
"the current scope. Likewise `#( #local )*` can be used to interpolate over "
"an iterator of types that implement "
"[`ToTokens`](https://docs.rs/quote/1/quote/trait.ToTokens.html), this works "
"similar to declarative `macro_rules!` repetitions in that they allow a "
"separator as well as extra tokens inside the repetition."
msgstr ""

#: src/proc-macros/third-party-crates.md:32
msgid ""
"```rs\n"
"let name = /* some identifier */;\n"
"let exprs = /* an iterator over expressions tokenstreams */;\n"
"let expanded = quote! {\n"
"    impl SomeTrait for #name { // #name interpolates the name local from "
"above\n"
"        fn some_function(&self) -> usize {\n"
"            #( #exprs )* // #name interpolates exprs by iterating the "
"iterator\n"
"        }\n"
"    }\n"
"};\n"
"```"
msgstr ""

#: src/proc-macros/third-party-crates.md:44
msgid ""
"This a very useful tool when preparing macro output avoiding the need of "
"creating a token stream by inserting tokens one by one."
msgstr ""

#: src/proc-macros/third-party-crates.md:46
msgid ""
"**Note**: As stated earlier, this crate makes use of `proc_macro2` and thus "
"the `quote!` macro returns a `proc-macro2::TokenStream`."
msgstr ""

#: src/proc-macros/third-party-crates.md:48
msgid "[`syn`](https://docs.rs/syn/*/syn/)"
msgstr ""

#: src/proc-macros/third-party-crates.md:50
msgid ""
"The [`syn`](https://docs.rs/syn/*/syn/) crate is a parsing library for "
"parsing a stream of Rust tokens into a syntax tree of Rust source code. It "
"is a very powerful library that makes parsing proc-macro input quite a bit "
"easier, as the [`proc_macro`](https://doc.rust-lang.org/proc_macro/) crate "
"itself does not expose any kind of parsing capabilities, merely the tokens. "
"As the library can be a heavy compilation dependency, it makes heavy use of "
"feature gates to allow users to cut it as small as required."
msgstr ""

#: src/proc-macros/third-party-crates.md:54
msgid "So what does it offer? A bunch of things."
msgstr ""

#: src/proc-macros/third-party-crates.md:56
msgid ""
"First of all it has definitions and parsing for all standard Rust syntax "
"nodes(when the `full` feature is enabled), as well as a "
"[`DeriveInput`](https://docs.rs/syn/1/syn/struct.DeriveInput.html) type "
"which encapsulates all the information a derive macro gets passed as an "
"input stream as a structured input(requires the `derive` feature, enabled by "
"default). These can be used right out of the box with the "
"[`parse_macro_input!`](https://docs.rs/syn/1/syn/macro.parse_macro_input.html) "
"macro(requires the `parsing` and `proc-macro` features, enabled by default) "
"to parse token streams into these types."
msgstr ""

#: src/proc-macros/third-party-crates.md:58
msgid ""
"If Rust syntax doesn't cut it, and instead one wishes to parse custom "
"non-Rust syntax the crate also offers a generic [parsing "
"API](https://docs.rs/syn/1/syn/parse/index.html), mainly in the form of the "
"[`Parse`](https://docs.rs/syn/1/syn/parse/trait.Parse.html) trait(requires "
"the `parsing` feature, enabled by default)."
msgstr ""

#: src/proc-macros/third-party-crates.md:60
msgid ""
"Aside from this the types exposed by the library keep location information "
"and spans which allows procedural macros to emit detailed error messages "
"pointing at the macro input at the points of interest."
msgstr ""

#: src/proc-macros/third-party-crates.md:62
msgid ""
"As this is again a library for procedural macros, it makes use of the "
"`proc_macro2` token streams and spans and as such, conversions may be "
"required."
msgstr ""

#: src/proc-macros/hygiene.md:3
msgid ""
"This chapter talks about procedural macro "
"[hygiene](../syntax-extensions/hygiene.md) and the type that encodes it, "
"[`Span`](https://doc.rust-lang.org/proc_macro/struct.Span.html)."
msgstr ""

#: src/proc-macros/hygiene.md:5
msgid ""
"Every token in a "
"[`TokenStream`](https://doc.rust-lang.org/proc_macro/struct.TokenStream.html) "
"has an associated `Span` holding some additional info. A span, as its "
"documentation states, is `A region of source code, along with macro "
"expansion information`. It points into a region of the original source "
"code(important for displaying diagnostics at the correct places) as well as "
"holding the kind of _hygiene_ for this location. The hygiene is relevant "
"mainly for identifiers, as it allows or forbids the identifier from "
"referencing things or being referenced by things defined outside of the "
"invocation."
msgstr ""

#: src/proc-macros/hygiene.md:10
msgid ""
"There are 3 kinds of hygiene(which can be seen by the constructors of the "
"`Span` type):"
msgstr ""

#: src/proc-macros/hygiene.md:11
msgid ""
"[`definition "
"site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method.def_site)(_**unstable**_): "
"A span that resolves at the macro definition site. Identifiers with this "
"span will not be able to reference things defined outside or be referenced "
"by things outside of the invocation. This is what one would call "
"\"hygienic\"."
msgstr ""

#: src/proc-macros/hygiene.md:12
msgid ""
"[`mixed "
"site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method.mixed_site): "
"A span that has the same hygiene as `macro_rules` declarative macros, that "
"is it may resolve to definition site or call site depending on the type of "
"identifier. See [here](../decl-macros/minutiae/hygiene.md) for more "
"information."
msgstr ""

#: src/proc-macros/hygiene.md:13
msgid ""
"[`call "
"site`](https://doc.rust-lang.org/proc_macro/struct.Span.html#method.call_site): "
"A span that resolves to the invocation site. Identifiers in this case will "
"behave as if written directly at the call site, that is they freely resolve "
"to things defined outside of the invocation and can be referenced from the "
"outside as well. This is what one would call \"unhygienic\"."
msgstr ""

#: src/glossary.md:3
msgid ""
"A place for obscure words and their descriptions. If you feel like there is "
"an important word missing here, please open an "
"[issue](https://github.com/Veykril/tlborm/issues/new) or a pull request."
msgstr ""

#: src/glossary.md:6
msgid "Function-like macro"
msgstr ""

#: src/glossary.md:7
msgid ""
"A function like macro describes a syntax extension that can be invoked via "
"the form `identifier!(...)`. It is called this way due to its resemblance of "
"a function call."
msgstr ""

#: src/glossary.md:10
msgid "Syntax Extension"
msgstr ""

#: src/glossary.md:11
msgid "The mechanism Rust's `macro_rules!` and procedural macros are built on."
msgstr ""

